<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>SELECT A DESTINATION</title>
    <link id="favicon" rel="icon" href="data:,">
    <script>
        (function () {
            const link = document.getElementById('favicon');
            function loadFavicon(src, isFallback = false) {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = 64; canvas.height = 64;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, 64, 64);
                    link.href = canvas.toDataURL();
                };
                img.onerror = () => {
                    dFavicon('./thumb.png', true);
                };
                img.src = src;
            }
            loadFavicon('./favicon.png');
        })();
    </script>
    <script>
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                window.location.href = 'https://sandbox.zakknowlton.com/';
            }
        });
    </script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&family=Orbitron:wght@400;700&display=swap"
        rel="stylesheet">

    <style>
        /* --- RESET & MOBILE FIXES --- */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            outline: none;
        }

        body,
        html {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #e0e0e0;
            font-family: 'Inter', sans-serif;
            cursor: none;
            user-select: none;
            -webkit-user-select: none;
            overscroll-behavior: none;
            touch-action: none;
        }

        /* --- CRT / GRAIN OVERLAY --- */
        #analog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9000;
            opacity: 0.2;
        }

        #scanlines {
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom,
                    rgba(255, 255, 255, 0),
                    rgba(255, 255, 255, 0) 50%,
                    rgba(0, 0, 0, 0.02) 50%,
                    /* FIXED: 0.02 Opacity */
                    rgba(0, 0, 0, 0.02));
            background-size: 100% 4px;
            position: absolute;
            top: 0;
            left: 0;
        }

        #noise {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('data:image/svg+xml,%3Csvg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg"%3E%3Cfilter id="noiseFilter"%3E%3CfeTurbulence type="fractalNoise" baseFrequency="0.85" numOctaves="3" stitchTiles="stitch"/%3E%3C/filter%3E%3Crect width="100%25" height="100%25" filter="url(%23noiseFilter)" opacity="0.15"/%3E%3C/svg%3E');
            opacity: 0.02;
            /* FIXED: 0.02 Opacity */
            mix-blend-mode: overlay;
            animation: noiseAnimation 2.5s linear infinite;
        }

        @keyframes noiseAnimation {
            0% {
                transform: translate(0, 0);
            }

            100% {
                transform: translate(0, 0);
            }
        }

        /* --- VERTICAL SCROLL HINT --- */
        @keyframes bobVertical {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(10px);
            }
        }

        #scroll-hint {
            position: fixed;
            top: 50%;
            right: -60px;
            transform: translateY(-50%);
            color: #7ec1d9;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.8rem;
            letter-spacing: 2px;
            z-index: 8000;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            opacity: 0;
            transition: right 0.6s cubic-bezier(0.2, 0.8, 0.2, 1), opacity 0.5s ease;
        }

        #scroll-hint.visible {
            right: 15px;
            opacity: 1;
        }

        #scroll-hint-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            animation: bobVertical 2s ease-in-out infinite;
        }

        #scroll-hint span {
            writing-mode: vertical-rl;
            text-orientation: mixed;
            transform: rotate(180deg);
        }

        #scroll-hint svg {
            width: 18px;
            height: 18px;
            fill: currentColor;
            margin-top: 5px;
        }

        /* --- RADIO PLAYER --- */
        #radio-player {
            position: fixed;
            bottom: 30px;
            left: 30px;
            background-color: #f0f0f0;
            border: 2px solid #ffffff;
            padding: 8px 12px;
            border-radius: 0;
            display: flex;
            align-items: center;
            gap: 12px;
            z-index: 8500;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;
            transform: translateY(100px);
            opacity: 0;
            transition: transform 0.8s cubic-bezier(0.2, 0.8, 0.2, 1), opacity 0.8s ease;
        }

        #radio-player.slide-in {
            transform: translateY(0);
            opacity: 1;
        }

        /* hide radio on mobile */
        @media (max-width: 768px) {
            #radio-player {
                display: none !important;
            }
        }

        .radio-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .radio-btn {
            width: 20px;
            height: 20px;
            fill: #000;
            opacity: 0.6;
            transition: opacity 0.2s, transform 0.1s;
        }

        .radio-btn:hover {
            opacity: 1;
        }

        .radio-btn:active {
            transform: scale(0.86);
        }

        .eq-container {
            display: flex;
            gap: 2px;
            align-items: flex-end;
            height: 14px;
        }

        .eq-bar {
            width: 3px;
            background-color: #7ec1d9;
            animation: eq 0.8s ease-in-out infinite;
        }

        .eq-bar:nth-child(1) {
            height: 8px;
            animation-duration: 0.6s;
        }

        .eq-bar:nth-child(2) {
            height: 14px;
            animation-duration: 0.9s;
        }

        .eq-bar:nth-child(3) {
            height: 6px;
            animation-duration: 0.7s;
        }

        @keyframes eq {

            0%,
            100% {
                transform: scaleY(1);
            }

            50% {
                transform: scaleY(0.5);
            }
        }

        .player-stopped .eq-bar {
            animation: none;
            height: 3px;
        }

        .icon-play {
            display: none;
        }

        .icon-pause {
            display: block;
        }

        .player-stopped .icon-play {
            display: block;
        }

        .player-stopped .icon-pause {
            display: none;
        }

        #radio-info {
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        #radio-label {
            font-size: 0.55rem;
            color: #888;
            letter-spacing: 1px;
            line-height: 1;
            margin-bottom: 3px;
        }

        #radio-track {
            font-size: 0.7rem;
            font-weight: 700;
            line-height: 1;
        }

        /* --- PRELOADER --- */
        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        #preloader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #f0f0f0;
            color: #000000;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            z-index: 100000;
            opacity: 1;
            transition: opacity 0.5s ease;
        }

        #preloader.fade-out {
            opacity: 0;
            visibility: hidden;
        }

        #preloader-spinner {
            border: 4px solid #f0f0f0;
            border-top: 4px solid #7ec1d9;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        #preloader-text {
            color: #888;
            font-size: 0.8rem;
            margin-top: 10px;
            letter-spacing: 1px;
        }

        /* --- LAYOUT --- */
        #scene-container {
            position: relative;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        #primary-panel {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, #ffffff 0%, #f0f0f0 100%);
            clip-path: url(#panel-mask);
            -webkit-clip-path: url(#panel-mask);
            filter: drop-shadow(0px 10px 20px rgba(0, 0, 0, 0.15));
            z-index: 1;
        }

        #canvas-wrapper {
            width: 100%;
            height: 100%;
            display: block;
        }

        #tile-label-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 40;
        }

        /* --- CLOCK --- */
        #clock {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Orbitron', sans-serif;
            font-size: 3rem;
            color: #000000;
            pointer-events: none;
            z-index: 30;
            white-space: nowrap;
            opacity: 0.8;
        }

        /* === MUSIC WIDGET (bottom left) === */
        #music-widget {
            position: fixed;
            left: 30px;
            bottom: 30px;
            transform: translateY(150px);
            z-index: 100;
            background: #f0f0f0;
            border: 2px solid #ffffff;
            padding: 8px;
            border-radius: 0;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
            opacity: 0;
            transition: transform 0.8s cubic-bezier(0.2, 0.8, 0.2, 1), opacity 0.8s ease;
        }

        #music-widget.slide-in {
            transform: translateY(0);
            opacity: 1;
        }

        #music-widget iframe {
            display: block;
            border-radius: 0;
        }

        /* hide spotify widget on desktop (radio player used instead) */
        @media (min-width: 769px) {
            #music-widget {
                display: none !important;
            }
        }

        /* === RIGHT WIDGET STACK (contact + settings) === */
        #right-widget-stack {
            position: fixed;
            bottom: 30px;
            right: 30px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 8px;
            transform: translateY(150px);
            opacity: 0;
            transition: transform 0.8s cubic-bezier(0.2, 0.8, 0.2, 1), opacity 0.8s ease;
        }

        #right-widget-stack.slide-in {
            transform: translateY(0);
            opacity: 1;
        }

        #mail-widget a {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: #f0f0f0;
            border: 2px solid #ffffff;
            color: #888;
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            letter-spacing: 1px;
            text-transform: uppercase;
            text-decoration: none;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
            transition: color 0.2s ease;
        }

        #settings-link {
            display: flex;
            align-items: center;
            gap: 4px;
            color: #aaa;
            font-family: sans-serif;
            font-size: 11px;
            text-decoration: none;
            cursor: pointer;
            transition: color 0.2s ease;
        }

        #settings-link:hover {
            color: #7ec1d9;
        }

        #settings-link svg {
            width: 12px;
            height: 12px;
            fill: currentColor;
        }

        #mail-widget a:hover {
            color: #7ec1d9;
        }

        #mail-widget svg {
            width: 16px;
            height: 16px;
            stroke: currentColor;
            fill: none;
        }

        /* hide widgets on mobile */
        @media (max-width: 768px) {
            #music-widget,
            #right-widget-stack {
                display: none !important;
            }
        }

        /* --- CUSTOM CURSOR --- */
        #custom-cursor {
            position: fixed;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 9999;
            will-change: transform;
            transform-origin: 0% 0%;
            transition: opacity 0.2s ease;
        }

        #custom-cursor img {
            display: block;
            width: 66px;
            height: auto;
        }

        #debug-hotspot {
            display: none;
            position: absolute;
            top: -2px;
            left: -2px;
            width: 4px;
            height: 4px;
            background: red;
            border-radius: 50%;
        }

        /* --- GUI CONTAINER --- */
        #gui-container {
            position: absolute;
            top: 0;
            right: 0;
            z-index: 20000;
            display: none;
        }

        .tile-index-label {
            position: absolute;
            color: rgba(0, 0, 0, 0.4);
            font-size: 18px;
            font-weight: 700;
            z-index: 50;
            pointer-events: none;
            display: none;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);
        }

        .tile-hidden {
            display: none !important;
        }

        #footer-text {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            color: #888;
            letter-spacing: 1px;
            pointer-events: none;
            z-index: 30;
            opacity: 0.6;
            white-space: nowrap;
        }

        /* MOBILE GRID */
        #mobile-grid {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 20px;
            overflow-y: auto;
            z-index: 50;
            background: linear-gradient(to bottom, #ffffff 0%, #f0f0f0 100%);
            box-sizing: border-box;
        }

        #mobile-grid-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            max-width: 500px;
            margin: 0 auto;
            padding-top: 0;
            padding-bottom: 100px; /* space for fixed bottom section */
        }

        .mobile-tile {
            aspect-ratio: 1;
            background: #d4d4d4;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
            cursor: pointer;
            transition: transform 0.15s ease, opacity 0.2s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .mobile-tile:active {
            transform: scale(0.95);
            opacity: 0.8;
        }

        .mobile-tile:nth-child(n+11) {
            display: none;
        }

        .mobile-tile img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* mobile tile ticker */
        .mobile-tile-ticker {
            position: absolute;
            left: 0;
            right: 0;
            height: 18px;
            background: rgba(20, 20, 20, 0.85);
            display: flex;
            align-items: center;
            overflow: hidden;
            pointer-events: none;
        }

        .mobile-tile-ticker.top {
            top: 8px;
        }

        .mobile-tile-ticker.bottom {
            bottom: 8px;
        }

        .mobile-tile-ticker-content {
            display: flex;
            white-space: nowrap;
            animation: mobile-ticker-scroll 24s linear infinite;
            font-family: 'Orbitron', sans-serif;
            font-size: 9px;
            font-weight: 700;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            color: #ffffff;
        }

        .mobile-tile-ticker.bottom .mobile-tile-ticker-content {
            animation-direction: reverse;
        }

        .mobile-tile-ticker-content span {
            padding: 0 20px;
        }

        @keyframes mobile-ticker-scroll {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }

        #mobile-sound-toggle {
            display: none;
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 50px;
            height: 50px;
            background: #f0f0f0;
            border: 2px solid #ffffff;
            border-radius: 50%;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            transition: transform 0.15s ease, opacity 0.2s ease;
        }

        #mobile-sound-toggle:active {
            transform: scale(0.9);
        }

        #mobile-sound-toggle svg {
            width: 24px;
            height: 24px;
        }

        #mobile-sound-toggle .sound-on {
            fill: #7ec1d9;
        }

        #mobile-sound-toggle .sound-off {
            fill: #888888;
        }

        #mobile-bottom-section {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background: linear-gradient(to bottom, #f0f0f0 0%, #e0e0e0 100%);
            z-index: 99;
            padding-bottom: 20px;
        }

        #mobile-blue-line {
            width: 100%;
            height: 2px;
            background-color: #7ec1d9;
        }

        #mobile-clock {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            color: #000000;
            text-align: center;
            margin-top: 20px;
            opacity: 0.8;
        }

        #mobile-footer-text {
            font-family: 'Orbitron', sans-serif;
            font-size: 8px;
            color: #888;
            letter-spacing: 1px;
            text-align: center;
            margin-top: 8px;
            opacity: 0.6;
        }

        /* MOBILE ADJUSTMENTS */
        @media (max-width: 768px) {
            #custom-cursor {
                display: none !important;
            }

            body,
            html {
                cursor: auto;
            }

            #scene-container {
                display: none;
            }

            #mobile-grid {
                display: block;
            }

            #mobile-sound-toggle {
                display: none; /* temporarily disabled */
            }

            #mobile-bottom-section {
                display: block;
            }

            #radio-player {
                display: none;
            }

            #scroll-hint {
                background: #f0f0f0;
                border: 2px solid #ffffff;
                border-radius: 25px;
                padding: 12px 15px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            }

            #clock {
                font-size: 1.5rem;
                bottom: 35px;
            }

            #footer-text {
                bottom: 18px;
                font-size: 8px;
            }

            #instructions {
                display: none;
            }
        }

        /* DEBUG MODE TOGGLE */
        body.debug-mode {
            cursor: auto !important;
        }

        body.debug-mode #gui-container {
            display: block !important;
        }

        body.debug-mode #debug-hotspot {
            display: block;
        }

        body.debug-mode #custom-cursor {
            opacity: 0.5;
        }

        body.debug-mode .tile-index-label {
            display: block;
        }

        /* TILE VIDEO OVERLAY */
        #tile-video-overlay {
            position: absolute;
            pointer-events: none;
            z-index: 35;
            opacity: 0;
            transition: opacity 0.3s ease;
            overflow: hidden;
        }

        #tile-video-overlay video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #tile-video-overlay.playing {
            opacity: 1;
        }

        /* TILE TICKER OVERLAY */
        #tile-ticker-overlay {
            position: absolute;
            pointer-events: none;
            z-index: 40;
            overflow: hidden;
        }

        .ticker-band {
            position: absolute;
            left: 0;
            right: 0;
            height: 24px;
            background: rgba(20, 20, 20, 0.85);
            display: flex;
            align-items: center;
            overflow: hidden;
        }

        .ticker-band.top {
            top: 10px;
        }

        .ticker-band.bottom {
            bottom: 10px;
        }

        .ticker-content {
            display: flex;
            white-space: nowrap;
            animation: ticker-scroll 24s linear infinite;
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            font-weight: 700;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            color: #ffffff;
        }

        .ticker-band.bottom .ticker-content {
            animation-direction: reverse;
        }

        .ticker-content span {
            padding: 0 30px;
        }

        @keyframes ticker-scroll {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }
    </style>
</head>

<body>
    <script>
        // ESC to return to portfolio if coming from sandbox
        if (document.referrer && document.referrer.includes('sandbox.zakknowlton.com')) {
            window.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') window.location.href = document.referrer;
            });
        }
    </script>

    <div id="preloader">
        <div id="preloader-spinner"></div>
        LOADING OS
        <div id="preloader-text">ZAK KNOWLTON &copy; 2026</div>
    </div>

    <div id="analog-overlay">
        <div id="scanlines"></div>
        <div id="noise"></div>
    </div>

    <div id="scroll-hint">
        <div id="scroll-hint-content">
            <span>SCROLL</span>
            <svg viewBox="0 0 24 24">
                <path d="M12 16l-6-6h12z" />
            </svg>
        </div>
    </div>

    <div id="radio-player">
        <div class="radio-controls">
            <div id="btn-toggle" class="radio-btn">
                <svg class="icon-play" viewBox="0 0 24 24">
                    <path d="M8 5v14l11-7z" />
                </svg>
                <svg class="icon-pause" viewBox="0 0 24 24">
                    <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z" />
                </svg>
            </div>
        </div>

        <div class="eq-container">
            <div class="eq-bar"></div>
            <div class="eq-bar"></div>
            <div class="eq-bar"></div>
        </div>

        <div id="radio-info">
            <span id="radio-label">PTASINSKI, RJ PASIN</span>
            <span id="radio-track">TOOTHPASTE</span>
        </div>
    </div>

    <svg style="position: absolute; width: 100%; height: 100%; pointer-events: none; z-index: 15; top: 0; left: 0;">
        <defs>
            <clipPath id="panel-mask" clipPathUnits="userSpaceOnUse">
                <path id="mask-path-el" d="" />
            </clipPath>
        </defs>
        <path id="border-path-el" fill="none" stroke="#7ec1d9" stroke-width="2" stroke-linecap="square" />
    </svg>

    <div id="scene-container">
        <div id="primary-panel">
            <div id="canvas-wrapper"></div>
        </div>
        <div id="tile-label-container"></div>
        <div id="tile-video-overlay">
            <video muted playsinline preload="auto">
                <source src="assets/anim_01.mp4" type="video/mp4">
            </video>
        </div>
        <div id="tile-ticker-overlay">
            <div class="ticker-band top">
                <div class="ticker-content">
                    <span>MY WORK</span><span>MY WORK</span><span>MY WORK</span><span>MY WORK</span><span>MY WORK</span><span>MY WORK</span><span>MY WORK</span><span>MY WORK</span><span>MY WORK</span><span>MY WORK</span>
                </div>
            </div>
            <div class="ticker-band bottom">
                <div class="ticker-content">
                    <span>MY WORK</span><span>MY WORK</span><span>MY WORK</span><span>MY WORK</span><span>MY WORK</span><span>MY WORK</span><span>MY WORK</span><span>MY WORK</span><span>MY WORK</span><span>MY WORK</span>
                </div>
            </div>
        </div>

        <div id="clock">12:00</div>
        <div id="footer-text">ZAK KNOWLTON &copy; 2026</div>
    </div>

    <!-- music widget (centered left) -->
    <div id="music-widget">
        <iframe src="https://open.spotify.com/embed/playlist/3yRE6S9e2bB3oAo3dSSgMD?utm_source=generator&theme=0" width="300" height="152" frameBorder="0" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" loading="lazy"></iframe>
    </div>

    <!-- right widget stack: contact + settings -->
    <div id="right-widget-stack">
        <div id="mail-widget">
            <a href="mailto:zakeryk@gmail.com">
                <svg viewBox="0 0 24 24" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="2" y="4" width="20" height="16" rx="2"/>
                    <path d="M22 6l-10 7L2 6"/>
                </svg>
                CONTACT
            </a>
        </div>
        <a id="settings-link" href="https://sandbox.zakknowlton.com/">
            <svg viewBox="0 0 24 24"><path d="M19.14 12.94c.04-.31.06-.63.06-.94 0-.31-.02-.63-.06-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.04.31-.06.63-.06.94s.02.63.06.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/></svg>
            settings
        </a>
    </div>

    <div id="gui-container"></div>

    <div id="custom-cursor">
        <img src="assets/wiicursor_sprite.png" alt="cursor">
        <div id="debug-hotspot"></div>
    </div>

    <div id="mobile-grid">
        <div id="mobile-grid-container"></div>
    </div>

    <div id="mobile-sound-toggle">
        <svg viewBox="0 0 24 24">
            <path class="sound-on" d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02z"/>
            <path class="sound-off" style="display:none;" d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/>
        </svg>
    </div>

    <div id="mobile-bottom-section">
        <div id="mobile-blue-line"></div>
        <div id="mobile-clock">12:00</div>
        <div id="mobile-footer-text">ZAK KNOWLTON &copy; 2026</div>
    </div>

    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
        "dat.gui": "https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.module.js"
      }
    }
  </script>

    <script type="module">
        import * as THREE from 'three';
        import { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry.js';
        import { GUI } from 'dat.gui';

        // --- DS-STYLE TAB ANIMATION WITH WAVES ---
        const baseTitle = 'SELECT A DESTINATION';
        const waveFrames = [
            '・ SELECT A DESTINATION',
            '∴ SELECT A DESTINATION',
            '∵ SELECT A DESTINATION',
            '≋ SELECT A DESTINATION',
            '∿ SELECT A DESTINATION',
            '〰 SELECT A DESTINATION',
            '～ SELECT A DESTINATION',
            '≈ SELECT A DESTINATION',
            '∼ SELECT A DESTINATION',
            '⋯ SELECT A DESTINATION',
            '⋰ SELECT A DESTINATION',
            '⋱ SELECT A DESTINATION',
            baseTitle,
            '◐ SELECT A DESTINATION',
            '◓ SELECT A DESTINATION',
            '◑ SELECT A DESTINATION',
            '◒ SELECT A DESTINATION',
            baseTitle,
            '⊹ SELECT A DESTINATION',
            '✦ SELECT A DESTINATION',
            '✧ SELECT A DESTINATION',
            '◆ SELECT A DESTINATION',
            baseTitle,
        ];

        let titleIndex = 0;
        let animPhase = 0;

        function animateTitle() {
            if (animPhase < waveFrames.length) {
                document.title = waveFrames[animPhase];
                animPhase++;
                setTimeout(animateTitle, 120);
            } else {
                // After intro, subtle wave pulse
                const pulseStates = [
                    baseTitle,
                    '～ ' + baseTitle,
                    '≋ ' + baseTitle,
                    '∿ ' + baseTitle,
                    baseTitle,
                    baseTitle,
                ];
                setInterval(() => {
                    document.title = pulseStates[titleIndex % pulseStates.length];
                    titleIndex++;
                }, 1800);
            }
        }

        setTimeout(animateTitle, 800);

        const MAX_TILES = 12;

        // utah time helper (mountain time)
        function isUtahDaytime() {
            const now = new Date();
            const utahTime = new Date(now.toLocaleString('en-US', { timeZone: 'America/Denver' }));
            const hour = utahTime.getHours();
            return hour >= 6 && hour < 20; // day: 6am-8pm
        }

        function getUtahTimeIcon() {
            return isUtahDaytime() ? 'assets/icon-time-day.png' : 'assets/icon-time-night.png';
        }

        // tiles to temporarily hide (by index)
        const HIDDEN_TILES = [];

        const ASSETS = {
            0: 'assets/anim_01_still.jpg',
            1: null,
            2: null,
            3: null,
            4: null, 5: null, 6: null, 7: null, 8: null, 9: null, 10: null, 11: null,
        };

        const LINKS = {
            0: 'https://sandbox.zakknowlton.com/PROJECTS/FEATURED/concept_files/',
            1: null,
            2: null,
            3: null,
            4: null, 5: null, 6: null, 7: null, 8: null, 9: null, 10: null, 11: null
        };

        // populate mobile grid
        const mobileGridContainer = document.getElementById('mobile-grid-container');
        let mobileTile1Img = null; // reference for tile 1's time icon

        for (let i = 0; i < MAX_TILES; i++) {
            const tile = document.createElement('div');
            tile.className = 'mobile-tile';

            if (ASSETS[i]) {
                const img = document.createElement('img');
                img.src = ASSETS[i];
                img.alt = '';
                tile.appendChild(img);

                // store reference to tile 1 for dynamic updates
                if (i === 1) {
                    mobileTile1Img = img;
                }
            }

            // add ticker to tile 0 (MY WORK)
            if (i === 0) {
                const tickerText = '<span>MY WORK</span>'.repeat(10);
                tile.insertAdjacentHTML('beforeend', `
                    <div class="mobile-tile-ticker top">
                        <div class="mobile-tile-ticker-content">${tickerText}</div>
                    </div>
                    <div class="mobile-tile-ticker bottom">
                        <div class="mobile-tile-ticker-content">${tickerText}</div>
                    </div>
                `);
            }

            if (LINKS[i]) {
                tile.style.cursor = 'pointer';
                tile.addEventListener('click', () => {
                    window.location.href = LINKS[i];
                });
            } else {
                tile.style.cursor = 'default';
            }

            mobileGridContainer.appendChild(tile);
        }

        // update tile 1 icon periodically (check every minute)
        setInterval(() => {
            if (mobileTile1Img) {
                const newIcon = getUtahTimeIcon();
                if (mobileTile1Img.src !== newIcon && !mobileTile1Img.src.endsWith(newIcon)) {
                    mobileTile1Img.src = newIcon;
                }
            }
        }, 60000); // check every minute

        // mobile sound toggle
        const mobileSoundToggle = document.getElementById('mobile-sound-toggle');
        const soundOnIcon = mobileSoundToggle.querySelector('.sound-on');
        const soundOffIcon = mobileSoundToggle.querySelector('.sound-off');

        mobileSoundToggle.addEventListener('click', () => {
            if (isPlaying) {
                audio.pause();
                soundOnIcon.style.display = 'none';
                soundOffIcon.style.display = 'block';
            } else {
                audio.play().catch(e => console.log("Audio play blocked:", e));
                soundOnIcon.style.display = 'block';
                soundOffIcon.style.display = 'none';
            }
            isPlaying = !isPlaying;
        });

        const PARAMS = {
            camX: 0, camY: -1.5, camZ: 10,
            aimX: 0, aimY: -1.5, aimZ: 0,
            camZoom: 2.7,
            gridSpacing: 1.2,
            gridOffsetX: 0.0,
            gridOffsetY: -1.2,
            borderRadius: 0.018,
            activeSlot: 1,
            splitHeight: 0.86,
            // tile 0 animation params
            animTriggerMode: 'hover', // 'hover' or 'interval'
            animFrequency: 4000,
            animEnabled: true,
            animBrightness: 0.73,
            animSaturation: 1.3,
            animSizeAdjust: 1.45,
            animBorderRadius: 150,
            animEdgeInset: 120,
            animTriggerNow: null // set after function is defined
        };

        const cursorState = {
            x: 0, y: 0, prevX: 0, targetX: 0, targetY: 0,
            angle: 0, scale: 1, targetScale: 1
        };

        let INTERSECTED = null;
        let cameraTween = null;
        let lastMoveTime = performance.now();
        let isMouseDown = false;
        let isMobile = false;

        let COLS = 4;
        let ROWS = 3;

        const scrollState = {
            current: 0,
            target: 0,
            max: 0,
            lastTouchY: 0,
            isScrolling: false
        };

        // --- RADIO LOGIC ---
        const audio = new Audio('assets/toothpaste.mp3');
        audio.loop = true;
        audio.volume = 0.15;

        const radioEl = document.getElementById('radio-player');
        const btnToggle = document.getElementById('btn-toggle');
        let isPlaying = true;

        radioEl.addEventListener('click', () => { togglePlay(); });

        function togglePlay() {
            if (isPlaying) {
                audio.pause();
                radioEl.classList.add('player-stopped');
            } else {
                audio.play().catch(e => console.log("Audio autoplay blocked:", e));
                radioEl.classList.remove('player-stopped');
            }
            isPlaying = !isPlaying;
        }

        // scroll hint idle timer (mobile only)
        let scrollHintTimeout = null;
        const scrollHintEl = document.getElementById('scroll-hint');

        function resetScrollHintTimer() {
            if (!isMobile) return;
            scrollHintEl.classList.remove('visible');
            clearTimeout(scrollHintTimeout);
            scrollHintTimeout = setTimeout(() => {
                scrollHintEl.classList.add('visible');
            }, 1000);
        }

        window.addEventListener('load', () => {
            document.getElementById('preloader').classList.add('fade-out');

            if (isMobile) {
                setTimeout(() => {
                    scrollHintEl.classList.add('visible');
                }, 500);
            }

            setTimeout(() => {
                document.getElementById('radio-player')?.classList.add('slide-in');
                document.getElementById('music-widget')?.classList.add('slide-in');
                document.getElementById('right-widget-stack')?.classList.add('slide-in');
                // autoplay on desktop
                if (!isMobile) {
                    audio.play().catch(e => console.log("Audio autoplay blocked:", e));
                }
            }, 1200);
        });


        // --- SETUP ---
        const container = document.getElementById('canvas-wrapper');
        const labelContainer = document.getElementById('tile-label-container');
        const scene = new THREE.Scene();
        const aspect = container.clientWidth / container.clientHeight;
        const baseSize = 5;
        const camera = new THREE.OrthographicCamera(-aspect * baseSize, aspect * baseSize, baseSize, -baseSize, 0.1, 1000);
        camera.position.set(PARAMS.camX, PARAMS.camY, PARAMS.camZ);
        camera.zoom = PARAMS.camZoom;
        camera.updateProjectionMatrix();

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 1.6));
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.8);
        dirLight.position.set(-5, 10, 10);
        scene.add(dirLight);

        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        const worldPosition = new THREE.Vector3();

        // --- BORDERS ---
        function updateBorders() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            // FIXED: Mobile split UP to 0.78
            const splitFactor = isMobile ? 0.88 : PARAMS.splitHeight;
            const splitY = h * splitFactor;
            document.getElementById('mask-path-el').setAttribute('d', `M 0,0 L ${w},0 L ${w},${splitY} L 0,${splitY} Z`);
            document.getElementById('border-path-el').setAttribute('d', `M 0,${splitY} L ${w},${splitY}`);
        }

        // --- GRID MANAGEMENT ---
        const textureLoader = new THREE.TextureLoader();
        const channelBlocks = [];
        const BASE_BLOCK_WIDTH = 1.12;
        const BASE_BLOCK_HEIGHT = 0.72;
        const MOBILE_SCALE_FACTOR = 1.35;
        const TILE_ASPECT = BASE_BLOCK_WIDTH / BASE_BLOCK_HEIGHT;

        for (let i = 0; i < MAX_TILES; i++) {
            const geo = new RoundedBoxGeometry(BASE_BLOCK_WIDTH, BASE_BLOCK_HEIGHT, 0.2, 4, PARAMS.borderRadius);
            let mat = new THREE.MeshPhongMaterial({
                color: 0xe0e0e0, specular: 0x222222, shininess: 10
            });

            if (ASSETS[i]) {
                textureLoader.load(ASSETS[i], (tex) => {
                    tex.colorSpace = THREE.SRGBColorSpace;
                    tex.wrapS = THREE.RepeatWrapping;
                    tex.wrapT = THREE.RepeatWrapping;

                    const ZOOM_FACTOR = i === 1 ? 0.97 : 0.9;
                    const imageAspect = tex.image.width / tex.image.height;
                    const tileAspect = TILE_ASPECT;

                    let rX = 1, rY = 1;
                    if (imageAspect / tileAspect > 1) {
                        rX = tileAspect / imageAspect;
                    } else {
                        rY = imageAspect / tileAspect;
                    }

                    tex.repeat.set(rX * ZOOM_FACTOR, rY * ZOOM_FACTOR);
                    tex.offset.set(
                        0.5 - (rX * ZOOM_FACTOR) / 2,
                        0.5 - (rY * ZOOM_FACTOR) / 2
                    );

                    mat.map = tex;
                    mat.needsUpdate = true;
                }, undefined, (err) => { mat.color.setHex(0xe0e0e0); mat.needsUpdate = true; });
            }

            const mesh = new THREE.Mesh(geo, mat);
            mesh.userData.index = i;
            mesh.userData.velocity = new THREE.Vector3();
            mesh.userData.targetScale = new THREE.Vector3(1, 1, 1);
            mesh.userData.wasClicked = false;
            mesh.userData.isSpringing = false;
            // Store base positions for magnetic effect
            mesh.userData.baseX = 0;
            mesh.userData.baseY = 0;

            scene.add(mesh);
            channelBlocks.push(mesh);

            const labelDiv = document.createElement('div');
            labelDiv.className = 'tile-index-label';
            labelDiv.textContent = i;
            labelContainer.appendChild(labelDiv);
            mesh.userData.label = labelDiv;
        }

        function updateGrid() {
            isMobile = window.innerWidth <= 768;

            if (isMobile) {
                COLS = 2;
                ROWS = Math.ceil(MAX_TILES / COLS);
            } else {
                COLS = 4;
                ROWS = 3;
            }

            let scaleFactor = 1.0;
            let scaleX = 1.0;
            let scaleY = 1.0;
            let mobileTileWidth = 0;

            if (isMobile) {
                // calculate tile size to fit screen with padding
                const visibleWidth = (camera.right - camera.left) / camera.zoom;
                const edgePadding = 0.4; // padding on sides
                const tilePadding = 0.25; // padding between tiles

                const availableWidth = visibleWidth - (edgePadding * 2) - (tilePadding * (COLS - 1));
                mobileTileWidth = availableWidth / COLS;

                // make tiles square - scale both x and y by same factor
                const squareScale = mobileTileWidth / BASE_BLOCK_WIDTH;
                scaleX = squareScale;
                scaleY = squareScale * (BASE_BLOCK_WIDTH / BASE_BLOCK_HEIGHT); // compensate for original aspect
            } else {
                scaleFactor = 1.0;
                scaleX = 1.0;
                scaleY = 1.0;
            }

            const gap = isMobile ? 0.25 : (PARAMS.gridSpacing - BASE_BLOCK_WIDTH);
            const autoSpacingY = gap + (isMobile ? mobileTileWidth : BASE_BLOCK_HEIGHT);
            const totalContentHeight = isMobile ? (ROWS * (mobileTileWidth + gap)) : (ROWS * autoSpacingY * scaleFactor);
            scrollState.max = isMobile ? Math.max(0, totalContentHeight - 4) : 0;

            channelBlocks.forEach((b, i) => {
                b.visible = true;
                if (b.userData.label) b.userData.label.classList.remove('tile-hidden');

                if (isMobile) {
                    b.scale.set(scaleX, scaleY, 1);
                } else {
                    b.scale.set(scaleFactor, scaleFactor, 1);
                }

                if (isMobile) {
                    const col = i % COLS;
                    const row = Math.floor(i / COLS);

                    const visibleWidth = (camera.right - camera.left) / camera.zoom;
                    const edgePadding = 0.4;
                    const tilePadding = 0.25;
                    const tileWidth = (visibleWidth - (edgePadding * 2) - (tilePadding * (COLS - 1))) / COLS;

                    const startX = -(visibleWidth / 2) + edgePadding + (tileWidth / 2);
                    const startY = 1.0;

                    b.userData.baseX = startX + col * (tileWidth + tilePadding);
                    b.userData.baseY = startY - row * (tileWidth + tilePadding);
                } else {
                    const totalW = (COLS - 1) * PARAMS.gridSpacing * scaleFactor;
                    const xOffset = -totalW / 2 + PARAMS.gridOffsetX;
                    const startY = ((ROWS - 1) * autoSpacingY) / 2 + PARAMS.gridOffsetY;

                    const col = i % COLS;
                    const row = Math.floor(i / COLS);

                    b.userData.baseX = xOffset + col * PARAMS.gridSpacing * scaleFactor;
                    b.userData.baseY = startY - row * autoSpacingY * scaleFactor;
                }

                b.position.set(b.userData.baseX, b.userData.baseY, 0);
            });
        }

        updateGrid();

        // --- TILE 0 VIDEO ANIMATION SYSTEM ---
        const videoOverlay = document.getElementById('tile-video-overlay');
        const videoEl = videoOverlay.querySelector('video');
        const tickerOverlay = document.getElementById('tile-ticker-overlay');
        let animInterval = null;
        let isAnimPlaying = false;
        let isTile0Hovered = false;

        function updateVideoPosition() {
            if (!channelBlocks[0]) return;

            const tile = channelBlocks[0];
            tile.updateWorldMatrix(true, false);
            tile.getWorldPosition(worldPosition);

            const screenPos = worldPosition.clone();
            screenPos.project(camera);

            const x = (screenPos.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
            const y = (-screenPos.y * 0.5 + 0.5) * renderer.domElement.clientHeight;

            const scaleFactor = isMobile ? MOBILE_SCALE_FACTOR : 1.0;
            const visibleWidth = (camera.right - camera.left) / camera.zoom;
            const visibleHeight = (camera.top - camera.bottom) / camera.zoom;

            // calculate dimensions - size adjust is applied to match tile visually
            const baseWidthPx = (BASE_BLOCK_WIDTH * scaleFactor * tile.scale.x) * (renderer.domElement.clientWidth / visibleWidth);
            const baseHeightPx = (BASE_BLOCK_HEIGHT * scaleFactor * tile.scale.y) * (renderer.domElement.clientHeight / visibleHeight);

            const widthPx = baseWidthPx * PARAMS.animSizeAdjust;
            const heightPx = baseHeightPx * PARAMS.animSizeAdjust;

            // calculate border radius to match tile's rounded corners
            const radiusInWorldUnits = PARAMS.borderRadius * PARAMS.animBorderRadius;
            const borderRadiusPx = radiusInWorldUnits * scaleFactor * tile.scale.x * (renderer.domElement.clientWidth / visibleWidth) * PARAMS.animSizeAdjust;

            videoOverlay.style.left = `${x - widthPx / 2}px`;
            videoOverlay.style.top = `${y - heightPx / 2}px`;
            videoOverlay.style.width = `${widthPx}px`;
            videoOverlay.style.height = `${heightPx}px`;
            videoOverlay.style.borderRadius = `${borderRadiusPx}px`;

            // apply edge inset to pull video content away from edges uniformly
            if (PARAMS.animEdgeInset > 0) {
                videoEl.style.clipPath = `inset(${PARAMS.animEdgeInset}px round ${borderRadiusPx}px)`;
            } else {
                videoEl.style.clipPath = 'none';
            }

            // position ticker overlay to match tile exactly (not scaled video)
            tickerOverlay.style.left = `${x - baseWidthPx / 2}px`;
            tickerOverlay.style.top = `${y - baseHeightPx / 2}px`;
            tickerOverlay.style.width = `${baseWidthPx}px`;
            tickerOverlay.style.height = `${baseHeightPx}px`;
        }

        function triggerTileAnimation() {
            if (!PARAMS.animEnabled) return;

            if (!isAnimPlaying) {
                isAnimPlaying = true;
                videoOverlay.classList.add('playing');
                videoEl.currentTime = 0;
                videoEl.loop = PARAMS.animTriggerMode === 'hover';
                videoEl.play();
            }

            if (PARAMS.animTriggerMode !== 'hover') {
                videoEl.onended = () => {
                    videoOverlay.classList.remove('playing');
                    isAnimPlaying = false;
                };
            }
        }

        function stopTileAnimation() {
            if (isAnimPlaying) {
                videoEl.pause();
                videoEl.currentTime = 0;
                videoOverlay.classList.remove('playing');
                isAnimPlaying = false;
            }
        }

        function startAnimationLoop() {
            if (animInterval) clearInterval(animInterval);

            if (PARAMS.animEnabled && PARAMS.animTriggerMode === 'interval' && PARAMS.animFrequency > 0) {
                animInterval = setInterval(() => {
                    if (PARAMS.animEnabled) triggerTileAnimation();
                }, PARAMS.animFrequency);
            }
        }

        function updateAnimFilters() {
            videoEl.style.filter = `brightness(${PARAMS.animBrightness}) saturate(${PARAMS.animSaturation})`;
        }

        // now set the callback
        PARAMS.animTriggerNow = () => { triggerTileAnimation(); };

        // apply initial filters
        updateAnimFilters();

        startAnimationLoop();

        // --- INPUT & SCROLL LOGIC ---
        window.addEventListener('resize', () => {
            const asp = container.clientWidth / container.clientHeight;
            camera.left = -asp * baseSize; camera.right = asp * baseSize;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
            updateBorders();
            updateGrid();
        });

        window.addEventListener('keydown', (e) => {
            if (e.key === '`' || e.key === '~') {
                document.body.classList.toggle('debug-mode');
            }
        });

        window.addEventListener('mousedown', (e) => {
            if (isMobile || (document.body.classList.contains('debug-mode') && e.target.closest('.dg'))) return;
            isMouseDown = true;
            lastMoveTime = performance.now();
            cursorState.targetScale = 0.8;
        });

        window.addEventListener('mouseup', () => {
            if (isMobile) return;
            isMouseDown = false;
            lastMoveTime = performance.now();
            cursorState.targetScale = 1.0;

            if (INTERSECTED) {
                const targetLink = LINKS[INTERSECTED.userData.index];
                if (targetLink) setTimeout(() => { window.location.href = targetLink; }, 300);
                INTERSECTED.userData.wasClicked = true;
            }
        });

        window.addEventListener('mousemove', (e) => {
            if (isMobile) return;
            cursorState.targetX = e.clientX;
            cursorState.targetY = e.clientY;
            lastMoveTime = performance.now();

            const rect = container.getBoundingClientRect();
            pointer.x = ((e.clientX - rect.left) / container.clientWidth) * 2 - 1;
            pointer.y = -((e.clientY - rect.top) / container.clientHeight) * 2 + 1;

            // hide custom cursor below blue line, show default
            const splitY = window.innerHeight * PARAMS.splitHeight;
            const cursorEl = document.getElementById('custom-cursor');
            if (e.clientY > splitY) {
                cursorEl.style.opacity = '0';
                document.body.style.cursor = 'auto';
            } else {
                cursorEl.style.opacity = '1';
                document.body.style.cursor = 'none';
            }
        });

        window.addEventListener('wheel', (e) => {
            if (isMobile) {
                scrollState.target += e.deltaY * 0.005;
                scrollState.target = Math.max(0, Math.min(scrollState.target, scrollState.max));
                resetScrollHintTimer();
            }
        });

        window.addEventListener('touchstart', (e) => {
            if (!isMobile) return;
            // Removed unconditional hide


            scrollState.isScrolling = false;
            scrollState.lastTouchY = e.touches[0].clientY;

            const rect = container.getBoundingClientRect();
            pointer.x = ((e.touches[0].clientX - rect.left) / container.clientWidth) * 2 - 1;
            pointer.y = -((e.touches[0].clientY - rect.top) / container.clientHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(channelBlocks, false);

            if (intersects.length > 0) {
                INTERSECTED = intersects[0].object;
                isMouseDown = true;
            }
        }, { passive: false });

        window.addEventListener('touchmove', (e) => {
            if (!isMobile) return;
            const touchY = e.touches[0].clientY;
            const delta = scrollState.lastTouchY - touchY;

            if (Math.abs(delta) > 5) {
                scrollState.isScrolling = true;
                isMouseDown = false;
                INTERSECTED = null;
            }

            scrollState.target += delta * 0.018;
            scrollState.target = Math.max(0, Math.min(scrollState.target, scrollState.max));
            scrollState.lastTouchY = touchY;
            resetScrollHintTimer();
        }, { passive: false });

        window.addEventListener('touchend', () => {
            if (!isMobile) return;

            if (!scrollState.isScrolling && INTERSECTED) {
                isMouseDown = false;

                INTERSECTED.userData.isSpringing = true;
                const popForce = 0.05;
                INTERSECTED.userData.velocity.x += popForce;

                const targetLink = LINKS[INTERSECTED.userData.index];
                if (targetLink) setTimeout(() => { window.location.href = targetLink; }, 300);
            }

            isMouseDown = false;
            setTimeout(() => { INTERSECTED = null; }, 300);
        });


        // --- ANIMATION ---
        function animate() {
            requestAnimationFrame(animate);

            if (isMobile) {
                scrollState.current += (scrollState.target - scrollState.current) * 0.1;
                camera.position.y = PARAMS.camY - scrollState.current;
            } else {
                camera.position.y = PARAMS.camY;
                scrollState.target = 0;
                scrollState.current = 0;
            }

            updateVideoPosition();

            if (!isMobile) {
                camera.lookAt(PARAMS.aimX, PARAMS.aimY, PARAMS.aimZ);
                raycaster.setFromCamera(pointer, camera);
                const intersects = raycaster.intersectObjects(channelBlocks, false);

                const DEFAULT_SHININESS = 10;
                const HOVER_SHININESS = 90;
                const DEFAULT_EMISSIVE = 0x000000;
                const HOVER_EMISSIVE = 0x555555;
                const LERP_FACTOR = 0.15;

                // MAGNETIC LOGIC
                let hoveredTile = null;
                const wasHoveringTile0 = isTile0Hovered;

                if (intersects.length > 0) {
                    hoveredTile = intersects[0].object;
                    const hitPoint = intersects[0].point;

                    // only apply magnetic effect when clicking and holding
                    if (isMouseDown) {
                        const magX = hoveredTile.userData.baseX + (hitPoint.x - hoveredTile.userData.baseX) * 0.05;
                        const magY = hoveredTile.userData.baseY + (hitPoint.y - hoveredTile.userData.baseY) * 0.05;
                        hoveredTile.position.lerp(new THREE.Vector3(magX, magY, 0), 0.1);
                    }

                    // track tile 0 hover state
                    isTile0Hovered = hoveredTile.userData.index === 0;

                    if (INTERSECTED !== hoveredTile) {
                        INTERSECTED = hoveredTile;
                    }

                    // start animation when hovering tile 0
                    if (PARAMS.animTriggerMode === 'hover' && isTile0Hovered && !wasHoveringTile0) {
                        triggerTileAnimation();
                    }
                } else {
                    isTile0Hovered = false;
                    INTERSECTED = null;
                }

                // stop animation when leaving tile 0 (moved outside else block to ensure it always runs)
                if (PARAMS.animTriggerMode === 'hover' && wasHoveringTile0 && !isTile0Hovered) {
                    stopTileAnimation();
                }

                channelBlocks.forEach(b => {
                    if (b !== hoveredTile) {
                        b.position.lerp(new THREE.Vector3(b.userData.baseX, b.userData.baseY, 0), 0.1);
                    }

                    const currentlyHovered = b === INTERSECTED;
                    const hasImage = !!b.material.map;
                    // FIXED: Only glow if hovered AND no image
                    const shouldGlow = currentlyHovered && !hasImage;

                    const targetShin = shouldGlow ? HOVER_SHININESS : DEFAULT_SHININESS;
                    b.material.shininess += (targetShin - b.material.shininess) * LERP_FACTOR;
                    const currentEmissive = b.material.emissive;
                    const targetHex = shouldGlow ? HOVER_EMISSIVE : DEFAULT_EMISSIVE;
                    const targetColor = new THREE.Color(targetHex);
                    currentEmissive.lerp(targetColor, LERP_FACTOR);
                    b.material.needsUpdate = true;
                });
            }

            const SPRING_TENSION = isMobile ? 0.6 : 0.25;
            const SPRING_DAMPING = isMobile ? 0.5 : 0.80;
            const OVERSHOOT_SCALE = 1.03;
            const LERP_CLICK = isMobile ? 0.4 : 0.2;
            const LERP_NORMAL = 0.08;

            channelBlocks.forEach(b => {
                let targetS = 1.0;
                const activeTarget = INTERSECTED === b;

                if (activeTarget) {
                    if (isMouseDown) {
                        targetS = isMobile ? 0.99 : 0.95;
                        b.userData.isSpringing = false;
                        b.userData.velocity.set(0, 0, 0);
                    } else {
                        targetS = 1.05;
                        if (b.userData.wasClicked) {
                            b.userData.isSpringing = true;
                            const launchForce = OVERSHOOT_SCALE - b.scale.x;
                            b.userData.velocity.x += launchForce * 0.5;
                            b.userData.wasClicked = false;
                        }
                    }
                } else {
                    targetS = 1.0;
                    b.userData.wasClicked = false;
                }

                if (b.userData.isSpringing) {
                    const tension = SPRING_TENSION;
                    const damping = SPRING_DAMPING;
                    const dist = targetS - b.scale.x;
                    b.userData.velocity.x += dist * tension;
                    b.userData.velocity.x *= damping;

                    if (Math.abs(b.userData.velocity.x) < 0.001 && Math.abs(dist) < 0.005) {
                        b.userData.isSpringing = false;
                        b.scale.set(targetS, targetS, targetS);
                    } else {
                        const next = b.scale.x + b.userData.velocity.x;
                        b.scale.set(next, next, next);
                    }
                } else {
                    let lerpFactor = activeTarget && isMouseDown ? LERP_CLICK : LERP_NORMAL;
                    const scaleBase = isMobile ? MOBILE_SCALE_FACTOR : 1.0;
                    const finalTarget = targetS * scaleBase;
                    const currentX = b.scale.x;
                    const nextX = currentX + (finalTarget - currentX) * lerpFactor;
                    b.scale.set(nextX, nextX, 1);
                }

                b.updateWorldMatrix(true, false);
                b.getWorldPosition(worldPosition);
                const screenPosition = worldPosition.clone();
                screenPosition.project(camera);
                const x = (screenPosition.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
                const y = (-screenPosition.y * 0.5 + 0.5) * renderer.domElement.clientHeight;
                if (b.userData.label) {
                    b.userData.label.style.transform = `translate3d(${x}px, ${y}px, 0) translate(-50%, -50%) scale(${b.scale.x})`;
                }
            });

            renderer.render(scene, camera);
        }
        animate();

        const cursorEl = document.getElementById('custom-cursor');
        const IDLE_TIMEOUT = 300;

        function animateCursor() {
            if (isMobile) return;
            cursorState.x = cursorState.targetX;
            cursorState.y = cursorState.targetY;
            cursorState.scale += (cursorState.targetScale - cursorState.scale) * 0.2;

            if (cursorState.prevX === undefined) cursorState.prevX = cursorState.x;
            const dx = cursorState.x - cursorState.prevX;
            cursorState.prevX = cursorState.x;

            const isTrulyIdle = performance.now() - lastMoveTime > IDLE_TIMEOUT;
            const isIdle = isTrulyIdle && !isMouseDown;

            let targetBaseRotation = -10;
            if (isIdle) targetBaseRotation = 0;

            const decayFactor = isIdle ? 0.1 : 1;
            const baseRotation = THREE.MathUtils.lerp(cursorState.angle, targetBaseRotation, decayFactor);
            const velocityTilt = dx * 1.5;
            const targetAngle = baseRotation + velocityTilt;

            cursorState.angle += (targetAngle - cursorState.angle) * 0.2;

            if (cursorEl) {
                cursorEl.style.transform = `translate3d(${cursorState.x}px, ${cursorState.y}px, 0) translateX(-35%) rotate(${cursorState.angle}deg) scale(${cursorState.scale})`;
            }
            requestAnimationFrame(animateCursor);
        }
        animateCursor();

        function updateClock() {
            const d = new Date();
            let h = d.getHours(); const m = d.getMinutes();
            const ampm = h >= 12 ? 'PM' : 'AM';
            h = h % 12 || 12;
            const mStr = m < 10 ? '0' + m : m;
            const timeHTML = `${h}:${mStr} <span style="font-size:0.4em; vertical-align: top;">${ampm}</span>`;
            document.getElementById('clock').innerHTML = timeHTML;
            const mobileClockEl = document.getElementById('mobile-clock');
            if (mobileClockEl) mobileClockEl.innerHTML = timeHTML;
        }
        setInterval(updateClock, 1000);
        updateClock();
        updateBorders();

        // --- GUI SETUP ---
        const gui = new GUI({ autoPlace: false });
        document.getElementById('gui-container').appendChild(gui.domElement);

        const folder = gui.addFolder('Layout');
        folder.add(PARAMS, 'gridSpacing', 1, 3).onChange(updateGrid);
        folder.add(PARAMS, 'gridOffsetY', -5, 5).onChange(updateGrid);
        folder.add(PARAMS, 'splitHeight', 0.5, 1.0).onChange(updateBorders);
        folder.open();

        const animFolder = gui.addFolder('Tile 0 Animation');
        animFolder.add(PARAMS, 'animEnabled').name('Enable Animation');
        animFolder.add(PARAMS, 'animTriggerMode', ['hover', 'interval']).name('Trigger Mode').onChange(startAnimationLoop);
        animFolder.add(PARAMS, 'animFrequency', 1000, 30000).name('Interval (ms)').onChange(startAnimationLoop);
        animFolder.add(PARAMS, 'animBrightness', 0.5, 1.5).name('Brightness').onChange(updateAnimFilters);
        animFolder.add(PARAMS, 'animSaturation', 0.5, 2.0).name('Saturation').onChange(updateAnimFilters);
        animFolder.add(PARAMS, 'animSizeAdjust', 0.95, 3.0).name('Size Adjust');
        animFolder.add(PARAMS, 'animBorderRadius', 1, 150).name('Border Radius');
        animFolder.add(PARAMS, 'animEdgeInset', 0, 200).name('Edge Inset (px)');
        animFolder.add(PARAMS, 'animTriggerNow').name('▶ Trigger Now');
        animFolder.open();
    </script>
</body>

</html>