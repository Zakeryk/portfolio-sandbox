<!DOCTYPE html>
<html lang="en">

<head>
    <script>
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                window.location.href = 'https://sandbox.zakknowlton.com/PROJECTS/FEATURED/concept_wii/';
            }
        });
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>CLICK AND DRAG</title>
    <link id="favicon" rel="icon" href="favicon.png">
    <link rel="apple-touch-icon" href="favicon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="favicon.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&display=swap" rel="stylesheet">

    <style>
        /* === RESET === */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body,
        html {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #0a0a0a;
            font-family: 'Courier Prime', monospace;
            cursor: default;
            user-select: none;
            -webkit-user-select: none;
            overscroll-behavior: none;
            touch-action: none;
        }

        /* === BACKGROUND IMAGE === */
        body {
            background-image: url('assets/background.jpg');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 10, 0.7);
            z-index: 0;
            pointer-events: none;
        }

        /* === NOISE OVERLAY === */
        #grain-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('data:image/svg+xml,%3Csvg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg"%3E%3Cfilter id="noiseFilter"%3E%3CfeTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="4" stitchTiles="stitch"/%3E%3C/filter%3E%3Crect width="100%25" height="100%25" filter="url(%23noiseFilter)"/%3E%3C/svg%3E');
            opacity: 0.08;
            pointer-events: none;
            z-index: 100;
            mix-blend-mode: overlay;
        }

        /* === AMBIENT GLOW === */
        #desk-light {
            display: none;
        }

        /* === DOT MATRIX BACKGROUND === */
        #dot-matrix {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        #dot-matrix.visible {
            opacity: 1;
        }

        /* === DESK CONTAINER === */
        #desk-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: transparent;
            overflow: hidden;
            z-index: 1;
        }

        /* === FILING AREA === */
        #filing-area {
            position: fixed;
            left: calc(-1 * var(--menu-width, 260px));
            top: var(--top-menu-height, 50px);
            bottom: 0;
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 1000;
            padding: 20px;
            width: var(--menu-width, 260px);
            background: rgba(10, 20, 15, 0.98);
            border-right: 1px solid rgba(50, 150, 100, 0.3);
            box-shadow: 4px 0 20px rgba(0, 0, 0, 0.7);
            overflow-y: auto;
            transition: left 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #filing-area.visible {
            left: 0;
        }

        /* desktop menu arrow hint */
        #menu-arrow {
            position: fixed;
            left: 8px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 999;
            display: flex;
            align-items: center;
            gap: 8px;
            pointer-events: none;
            opacity: 0.7;
            transition: opacity 0.3s ease, left 0.3s ease;
        }

        #menu-arrow.hidden {
            opacity: 0;
            left: -50px;
        }

        #menu-arrow svg {
            width: 20px;
            height: 20px;
            fill: none;
            stroke: rgba(100, 200, 150, 0.8);
            stroke-width: 2;
            animation: arrow-pulse 2s ease-in-out infinite;
        }

        #menu-arrow span {
            font-size: 10px;
            color: rgba(100, 200, 150, 0.8);
            letter-spacing: 1px;
            text-transform: uppercase;
            white-space: nowrap;
        }

        @keyframes arrow-pulse {
            0%, 100% { transform: translateX(0); opacity: 0.7; }
            50% { transform: translateX(5px); opacity: 1; }
        }

        /* hide arrow when menu visible */
        #filing-area.visible ~ #menu-arrow,
        body:has(#filing-area.visible) #menu-arrow {
            opacity: 0;
            pointer-events: none;
        }

        /* right menu arrow hint (clients) */
        #menu-arrow-right {
            position: fixed;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 999;
            display: flex;
            flex-direction: row-reverse;
            align-items: center;
            gap: 8px;
            pointer-events: none;
            opacity: 0.7;
            transition: opacity 0.3s ease, right 0.3s ease;
        }

        #menu-arrow-right.hidden {
            opacity: 0;
            right: -50px;
        }

        #menu-arrow-right svg {
            width: 20px;
            height: 20px;
            fill: none;
            stroke: rgba(100, 200, 150, 0.8);
            stroke-width: 2;
            animation: arrow-pulse-right 2s ease-in-out infinite;
        }

        #menu-arrow-right span {
            font-size: 10px;
            color: rgba(100, 200, 150, 0.8);
            letter-spacing: 1px;
            text-transform: uppercase;
            white-space: nowrap;
        }

        @keyframes arrow-pulse-right {
            0%, 100% { transform: translateX(0); opacity: 0.7; }
            50% { transform: translateX(-5px); opacity: 1; }
        }

        /* hide right arrow when menu visible */
        #right-menu.visible ~ #menu-arrow-right,
        body:has(#right-menu.visible) #menu-arrow-right {
            opacity: 0;
            pointer-events: none;
        }

        /* top menu - persistent on desktop */
        #top-menu {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: var(--top-menu-height, 50px);
            z-index: 1001;
            padding: 0 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(10, 20, 15, 0.98);
            border-bottom: 1px solid rgba(50, 150, 100, 0.3);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.7);
        }

        #top-menu .clock {
            font-size: 12px;
            font-weight: 500;
            letter-spacing: 2px;
            color: rgba(100, 200, 150, 0.8);
            font-variant-numeric: tabular-nums;
        }

        /* right menu */
        #right-menu {
            position: fixed;
            right: calc(-1 * var(--right-menu-width, 220px));
            top: var(--top-menu-height, 50px);
            bottom: 0;
            width: var(--right-menu-width, 220px);
            z-index: 1000;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            background: rgba(10, 20, 15, 0.98);
            border-left: 1px solid rgba(50, 150, 100, 0.3);
            box-shadow: -4px 0 20px rgba(0, 0, 0, 0.7);
            overflow-y: auto;
            transition: right 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #right-menu.visible {
            right: 0;
        }

        #right-menu .menu-header {
            font-size: 10px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: #7a9;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(50, 150, 100, 0.2);
            margin-bottom: 5px;
        }

        #right-menu .menu-item {
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 1px;
            color: rgba(100, 150, 120, 0.7);
            padding: 10px 0;
            text-decoration: none;
            transition: color 0.2s ease;
            cursor: pointer;
        }

        #right-menu a.menu-item:hover {
            color: rgba(100, 200, 150, 1);
        }

        #right-menu-trash {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 24px;
            height: 24px;
            background: none;
            border: none;
            padding: 0;
            cursor: pointer;
            color: rgba(100, 150, 120, 0.5);
            transition: color 0.2s ease, transform 0.2s ease;
            opacity: 0;
            pointer-events: none;
        }

        #right-menu-trash.visible {
            opacity: 1;
            pointer-events: auto;
        }

        #right-menu-trash:hover {
            color: rgba(201, 85, 77, 0.9);
            transform: scale(1.1);
        }

        #right-menu-trash svg {
            width: 100%;
            height: 100%;
        }

        .folder-stack {
            position: relative;
            width: 100%;
            background: rgba(20, 40, 30, 0.5);
            border: 1px solid rgba(50, 150, 100, 0.3);
            border-radius: 2px;
            padding: 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            overflow: hidden;
        }

        .folder-header {
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: #7a9;
            cursor: pointer;
            transition: box-shadow 0.15s ease, background 0.15s ease;
        }

        .folder-header:active {
            background: rgba(50, 150, 100, 0.15);
            box-shadow: inset 0 0 20px rgba(50, 150, 100, 0.3), 0 0 15px rgba(50, 150, 100, 0.2);
        }

        .folder-header,
        .folder-header *,
        .folder-stack,
        .folder-stack * {
            cursor: pointer !important;
        }

        @media (min-width: 769px) {
            .folder-stack:hover {
                box-shadow: 0 0 12px rgba(50, 150, 100, 0.25);
            }
        }

        .file-list {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            cursor: pointer !important;
        }

        .folder-stack.expanded .file-list {
            max-height: 600px;
        }

        .file-list-item {
            padding: 10px 15px;
            border-top: 1px solid rgba(50, 150, 100, 0.2);
            cursor: pointer;
            transition: background 0.2s ease;
            font-size: 11px;
            color: #8ab;
        }

        @media (min-width: 769px) {
            .file-list-item:hover {
                box-shadow: inset 0 0 8px rgba(50, 150, 100, 0.2);
                background: rgba(50, 150, 100, 0.08);
            }
        }

        .file-list-item:active {
            cursor: pointer;
            background: rgba(50, 150, 100, 0.15);
            box-shadow: inset 0 0 15px rgba(50, 150, 100, 0.25), 0 0 10px rgba(50, 150, 100, 0.15);
        }

        .file-item-title {
            font-weight: 600;
            margin-bottom: 3px;
            cursor: pointer;
        }

        .file-item-year {
            font-size: 9px;
            opacity: 0.6;
            cursor: pointer;
        }

        .folder-stack[data-category="saas"] {
            background: rgba(58, 124, 165, 0.15);
            border-color: rgba(58, 124, 165, 0.4);
        }

        .folder-stack[data-category="ecommerce"] {
            background: rgba(201, 85, 77, 0.15);
            border-color: rgba(201, 85, 77, 0.4);
        }

        .folder-stack[data-category="design"] {
            background: rgba(138, 43, 226, 0.15);
            border-color: rgba(138, 43, 226, 0.4);
        }

        .folder-stack.drag-over {
            transform: scale(1);
        }

        .file-count {
            font-size: 9px;
            opacity: 0.6;
            font-weight: 400;
            letter-spacing: 1px;
        }

        .filing-footer {
            margin-top: auto;
            padding: 15px;
            border-top: 1px solid rgba(50, 150, 100, 0.2);
        }

        .filing-footer a {
            color: #8ab;
            text-decoration: none;
            font-size: 10px;
            letter-spacing: 1px;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }

        .filing-footer a:hover {
            opacity: 1;
        }

        .mobile-footer-bar {
            display: none;
        }

        /* === MOBILE HAMBURGER MENU === */
        #hamburger-btn {
            display: none;
            position: fixed;
            bottom: 24px;
            right: 24px;
            width: 56px;
            height: 56px;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 5px;
            background: rgba(10, 20, 15, 0.98);
            border: 1px solid rgba(50, 150, 100, 0.4);
            border-radius: 50%;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5), 0 0 20px rgba(50, 150, 100, 0.15);
            z-index: 2000;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        #hamburger-btn span {
            display: block;
            width: 18px;
            height: 2px;
            background: rgba(50, 150, 100, 0.8);
            transition: all 0.3s ease;
        }

        #hamburger-btn:hover {
            background: rgba(50, 150, 100, 0.2);
            border-color: rgba(50, 150, 100, 0.6);
        }

        #hamburger-btn:hover span {
            background: rgba(50, 150, 100, 1);
        }

        #hamburger-btn.active span:nth-child(1) {
            transform: translateY(7px) rotate(45deg);
        }

        #hamburger-btn.active span:nth-child(2) {
            opacity: 0;
        }

        #hamburger-btn.active span:nth-child(3) {
            transform: translateY(-7px) rotate(-45deg);
        }

        #hamburger-btn.active {
            background: rgba(50, 150, 100, 0.15);
        }

        /* === MOBILE MENU HINT === */
        #menu-hint {
            display: none;
            position: fixed;
            bottom: 90px;
            right: 24px;
            z-index: 1999;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.4s ease;
        }

        #menu-hint.visible {
            opacity: 1;
        }

        #menu-hint-text {
            color: rgba(50, 150, 100, 0.9);
            font-size: 13px;
            font-family: 'Courier Prime', monospace;
            white-space: nowrap;
            text-align: right;
            margin-bottom: 8px;
        }

        #menu-hint-arrow {
            width: 24px;
            height: 24px;
            margin-left: auto;
            margin-right: 16px;
            animation: bounce-arrow 1s ease-in-out infinite;
        }

        #menu-hint-arrow svg {
            width: 100%;
            height: 100%;
            color: rgba(50, 150, 100, 0.9);
        }

        @keyframes bounce-arrow {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(6px); }
        }

        /* === DESKTOP MENU HINT === */
        #desktop-hint {
            position: fixed;
            left: calc(var(--menu-width, 260px) + 24px);
            top: 50%;
            transform: translateY(-50%);
            z-index: 1999;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.4s ease;
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 12px;
        }

        #desktop-hint.visible {
            opacity: 1;
        }

        #desktop-hint-arrow {
            width: 24px;
            height: 24px;
            animation: bounce-arrow-left 1s ease-in-out infinite;
        }

        #desktop-hint-arrow svg {
            width: 100%;
            height: 100%;
            color: rgba(50, 150, 100, 0.9);
        }

        #desktop-hint-text {
            color: rgba(50, 150, 100, 0.9);
            font-size: 13px;
            font-family: 'Courier Prime', monospace;
            white-space: nowrap;
        }

        @keyframes bounce-arrow-left {
            0%, 100% { transform: translateX(0); }
            50% { transform: translateX(-6px); }
        }

        /* hide desktop hint on mobile */
        @media (max-width: 768px) {
            #desktop-hint {
                display: none;
            }
        }

        #menu-backdrop {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.35);
            z-index: 900;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        #menu-backdrop.visible {
            opacity: 1;
            pointer-events: all;
        }

        /* === WASTEBIN === */
        #wastebin {
            display: flex;
            position: fixed;
            bottom: -120px;
            left: 0;
            right: 0;
            width: 100%;
            height: 100px;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 8px;
            background: linear-gradient(to bottom,
                rgba(201, 85, 77, 0) 0%,
                rgba(201, 85, 77, 0.15) 30%,
                rgba(201, 85, 77, 0.3) 100%);
            border: none;
            color: rgba(201, 85, 77, 0.8);
            z-index: 950;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #wastebin svg {
            width: 28px;
            height: 28px;
        }

        #wastebin span {
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #wastebin.visible {
            bottom: 0;
        }

        #wastebin.active {
            background: linear-gradient(to bottom,
                rgba(201, 85, 77, 0) 0%,
                rgba(201, 85, 77, 0.4) 30%,
                rgba(201, 85, 77, 0.6) 100%);
            color: rgba(255, 255, 255, 1);
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.7;
            }
        }

        /* === CLEAR ALL BUTTON === */
        #clear-all-btn {
            display: flex;
            position: fixed;
            bottom: -100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(201, 85, 77, 0.3);
            border: 2px solid rgba(201, 85, 77, 0.6);
            color: rgba(201, 85, 77, 0.9);
            padding: 12px 24px;
            font-family: 'Courier Prime', monospace;
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            border-radius: 4px;
            cursor: pointer;
            z-index: 960;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            letter-spacing: 1px;
            pointer-events: all;
            align-items: center;
            justify-content: center;
        }

        #clear-all-btn.visible {
            bottom: 30px;
        }

        #clear-all-btn:hover {
            background: rgba(201, 85, 77, 0.5);
            border-color: rgba(201, 85, 77, 0.9);
            color: rgba(201, 85, 77, 1);
            transform: translateX(-50%) scale(1.05);
        }

        #clear-all-btn:active {
            transform: translateX(-50%) scale(0.95);
        }

        /* hide wastebin and clear all when lightbox is active */
        body:has(#lightbox-overlay.visible) #wastebin,
        body:has(#lightbox-overlay.visible) #clear-all-btn {
            display: none !important;
        }

        /* === DOCUMENTS AREA === */
        #documents-area {
            position: absolute;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        .document {
            position: absolute;
            width: 220px;
            height: 160px;
            background: rgb(15, 25, 20);
            border-radius: 2px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.8);
            cursor: pointer;
            transition: box-shadow 0.15s ease;
            will-change: transform;
            padding: 16px;
        }

        .document:hover {
            /* hover animation disabled - conflicts with gsap transforms */
        }

        .document::before {
            content: '';
            position: absolute;
            top: 3px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            box-shadow:
                inset 0 1px 2px rgba(0, 0, 0, 0.4),
                0 2px 4px rgba(0, 0, 0, 0.3);
            pointer-events: none;
        }

        .document:active {
            cursor: grabbing !important;
        }

        .doc-title {
            font-size: 14px;
            font-weight: 700;
            color: #8fc;
            margin-bottom: 5px;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .doc-year {
            font-size: 11px;
            font-weight: 400;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 10px;
            letter-spacing: 2px;
        }

        .category-tag {
            position: absolute;
            bottom: 10px;
            right: 10px;
            padding: 4px 10px;
            font-size: 9px;
            font-weight: 700;
            letter-spacing: 1.5px;
            border-radius: 3px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
            color: rgba(255, 255, 255, 0.6);
        }

        .category-tag.saas {
            background: rgba(58, 124, 165, 0.2);
            border: 1px solid rgba(58, 124, 165, 0.5);
            color: #5a9fd4;
        }

        .category-tag.ecommerce {
            background: rgba(201, 85, 77, 0.2);
            border: 1px solid rgba(201, 85, 77, 0.5);
            color: #e88a82;
        }

        .category-tag.design {
            background: rgba(138, 43, 226, 0.2);
            border: 1px solid rgba(138, 43, 226, 0.5);
            color: #a060ea;
        }

        /* === UI OVERLAY === */
        #ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }

        #filter-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 20, 15, 0.95);
            color: #8ab;
            padding: 10px 20px;
            font-size: 11px;
            border-radius: 2px;
            border: 1px solid rgba(50, 150, 100, 0.3);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.6);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 99999;
        }

        #filter-hint.visible {
            opacity: 1;
        }

        #back-link {
            position: absolute;
            top: 20px;
            right: 20px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 99999;
        }

        #back-link.visible {
            opacity: 1;
            pointer-events: all;
        }

        #back-link a {
            color: #8ab;
            text-decoration: none;
            font-size: 13px;
            padding: 10px 20px;
            background: rgba(10, 20, 15, 0.95);
            border: 1px solid rgba(50, 150, 100, 0.3);
            border-radius: 2px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: inline-block;
        }

        #back-link a:hover {
            background: rgba(50, 150, 100, 0.15);
            border-color: rgba(50, 150, 100, 0.6);
            color: #8fc;
        }

        #cleanup-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(20, 40, 30, 0.8);
            color: #8ab;
            border: 1px solid rgba(50, 150, 100, 0.4);
            padding: 12px 24px;
            font-family: 'Courier Prime', monospace;
            font-size: 14px;
            font-weight: 700;
            text-transform: uppercase;
            border-radius: 2px;
            cursor: pointer;
            pointer-events: none;
            transition: all 0.3s ease;
            letter-spacing: 1px;
            opacity: 0;
            z-index: 99999;
        }

        #cleanup-btn.visible {
            opacity: 1;
            pointer-events: all;
        }

        #cleanup-btn:hover {
            background: rgba(50, 150, 100, 0.3);
            border-color: rgba(50, 150, 100, 0.7);
            color: #8fc;
            transform: scale(1.05);
        }

        #cleanup-btn:active {
            transform: scale(0.95);
        }

        /* === SPILLED IMAGES === */
        .spilled-image {
            position: absolute;
            max-width: 180px;
            max-height: 140px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.6);
            cursor: pointer;
            will-change: transform;
            z-index: 50;
            object-fit: contain;
            border-radius: 2px;
            image-rendering: crisp-edges;
            image-rendering: -webkit-optimize-contrast;
        }

        .spilled-image.pseudo-spill {
            z-index: 5;
            pointer-events: none;
        }

        .spilled-image:active {
            cursor: grabbing !important;
        }

        /* === PEEK IMAGES === */
        .peek-image {
            position: absolute;
            max-width: 100px;
            max-height: 80px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            pointer-events: none;
            z-index: 4;
            object-fit: cover;
            border-radius: 2px;
            opacity: 0.9;
        }


        /* === LIGHTBOX OVERLAY === */
        #lightbox-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 10, 8, 0.25);
            opacity: 0;
            pointer-events: none;
            z-index: 1002;
            transition: opacity 0.2s ease;
            backdrop-filter: blur(2px);
        }

        #lightbox-overlay.visible {
            opacity: 1;
            pointer-events: all;
            cursor: pointer;
        }

        /* === LIGHTBOX GALLERY === */
        #lightbox-gallery {
            position: fixed;
            top: 50%;
            left: 0;
            right: 0;
            transform: translateY(-50%);
            display: flex;
            gap: clamp(15px, 2vw, 30px);
            align-items: center;
            justify-content: center;
            z-index: 1002;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            padding: 10vh clamp(20px, 2vw, 40px);
            overflow-x: auto;
            overflow-y: visible;
            scroll-behavior: smooth;
        }

        #lightbox-gallery::-webkit-scrollbar {
            display: none;
        }

        #lightbox-gallery.visible {
            opacity: 1;
            pointer-events: none;
        }

        .lightbox-image {
            max-width: clamp(280px, 28vw, 600px);
            max-height: 70vh;
            cursor: pointer;
            transition: all 0.15s ease;
            object-fit: contain;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6);
            border: none;
            pointer-events: all;
            flex-shrink: 0;
        }

        .lightbox-image:hover {
            transform: scale(1.05) translateY(-8px);
            box-shadow: 0 12px 32px rgba(0, 0, 0, 0.8);
        }

        .lightbox-image.focused {
            transform: scale(1.4);
            z-index: 1003;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.9);
        }

        /* === LIGHTBOX TIP === */
        #lightbox-tip {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.5);
            font-size: 12px;
            font-family: 'Courier Prime', monospace;
            z-index: 1004;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            text-align: center;
        }

        #lightbox-tip.visible {
            opacity: 1;
        }

        /* === SCROLL HINT (mobile lightbox only) === */
        #scroll-hint {
            display: none;
            position: fixed;
            top: 50%;
            right: -80px;
            transform: translateY(-50%);
            color: rgba(50, 150, 100, 1);
            font-family: 'Courier Prime', monospace;
            font-size: 10px;
            letter-spacing: 2px;
            z-index: 1005;
            pointer-events: none;
            opacity: 0;
            transition: right 0.5s cubic-bezier(0.2, 0.8, 0.2, 1), opacity 0.4s ease;
        }

        #scroll-hint.visible {
            right: 8px;
            opacity: 1;
        }

        #scroll-hint-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            background: rgba(10, 20, 15, 0.9);
            border: 1px solid rgba(50, 150, 100, 0.4);
            border-radius: 4px;
            padding: 10px 8px;
            animation: bobVertical 2s ease-in-out infinite;
        }

        #scroll-hint span {
            writing-mode: vertical-rl;
            text-orientation: mixed;
            transform: rotate(180deg);
        }

        #scroll-hint svg {
            width: 14px;
            height: 14px;
            transform: rotate(180deg);
        }

        @keyframes bobVertical {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(8px); }
        }

        /* Remove shadow from PNGs */
        .spilled-image[src$=".png"],
        .spilled-image[src*=".png?"],
        .spilled-image[src*=".png#"],
        .peek-image[src$=".png"],
        .peek-image[src*=".png?"],
        .peek-image[src*=".png#"],
        .lightbox-image[src$=".png"],
        .lightbox-image[src*=".png?"],
        .lightbox-image[src*=".png#"] {
            box-shadow: none !important;
        }

        /* === LIGHTBOX CLOSE BUTTON === */
        #lightbox-close {
            display: flex;
            position: fixed;
            top: -60px;
            right: 20px;
            width: 44px;
            height: 44px;
            background: rgba(20, 40, 30, 0.8);
            border: 1px solid rgba(50, 150, 100, 0.4);
            border-radius: 2px;
            z-index: 1004;
            cursor: pointer;
            pointer-events: none;
            transition: top 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: 6px;
        }

        #lightbox-close span {
            display: block;
            width: 20px;
            height: 2px;
            background: rgba(50, 150, 100, 0.8);
            transition: all 0.3s ease;
        }

        #lightbox-close span:nth-child(1) {
            transform: translateY(8px) rotate(45deg);
        }

        #lightbox-close span:nth-child(2) {
            opacity: 0;
        }

        #lightbox-close span:nth-child(3) {
            transform: translateY(-8px) rotate(-45deg);
        }

        #lightbox-close.visible {
            top: calc(var(--top-menu-height, 50px) + 10px);
            pointer-events: all;
        }

        #lightbox-close:hover {
            background: rgba(50, 150, 100, 0.2);
            border-color: rgba(50, 150, 100, 0.6);
        }

        #lightbox-close:hover span {
            background: rgba(50, 150, 100, 1);
        }

        /* === RESPONSIVE === */
        @media (max-width: 768px) {
            body {
                background-image: url('background-mobile.jpg');
            }

            .document {
                width: 170px;
                height: 123px;
                padding: 11px;
            }

            .doc-title {
                font-size: 12px;
            }

            .doc-year {
                font-size: 10px;
            }

            .category-tag {
                font-size: 8px;
                padding: 2px 5px;
            }

            /* mobile: show hamburger, convert filing area to offcanvas */
            #hamburger-btn {
                display: flex;
            }

            #menu-hint {
                display: block;
            }

            #menu-backdrop {
                display: block;
            }

            #wastebin {
                display: flex;
            }

            /* hide esc hint on mobile */
            .esc-hint {
                display: none;
            }

            /* hide top and right menus on mobile */
            #top-menu,
            #right-menu {
                display: none;
            }

            #filing-area {
                left: 0 !important;
                right: 0 !important;
                top: auto !important;
                bottom: 0 !important;
                transform: translateY(100%) !important;
                width: 100% !important;
                max-height: 100vh;
                flex-direction: column;
                gap: 10px;
                padding: 20px 15px 100px 15px;
                border-right: none;
                border-top: 1px solid rgba(50, 150, 100, 0.3);
                border-radius: 16px 16px 0 0;
                box-shadow: 0 -4px 30px rgba(0, 0, 0, 0.5);
                transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                z-index: 1001 !important;
                overflow-y: auto;
            }

            #filing-area.visible {
                transform: translateY(0) !important;
            }

            #menu-arrow,
            #menu-arrow-right {
                display: none;
            }

            .folder-stack {
                width: 100%;
                font-size: 10px;
                padding: 0;
                flex-shrink: 0;
            }

            .folder-header {
                padding: 14px 12px;
                font-size: 10px;
            }

            .folder-stack.expanded .file-list {
                max-height: 200px;
                overflow-y: auto;
            }

            .file-count {
                font-size: 10px;
            }

            .filing-footer {
                width: 100%;
                text-align: center;
                padding: 15px 0 0 0;
                border-top: 1px solid rgba(50, 150, 100, 0.2);
                margin-top: 10px;
            }

            .mobile-footer-bar {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                padding: 12px 0 16px 0;
                font-size: 9px;
                letter-spacing: 0.5px;
                color: rgba(136, 170, 187, 0.5);
                text-transform: lowercase;
                gap: 4px;
                background: linear-gradient(to top, rgba(8, 16, 12, 0.95) 0%, rgba(8, 16, 12, 0) 100%);
                z-index: 100;
                pointer-events: none;
            }

            .mobile-clock {
                font-family: inherit;
                opacity: 0.7;
                order: -1;
            }

            .mobile-copyright {
                opacity: 0.7;
            }

            #filter-hint {
                display: none;
            }

            #back-link {
                display: none;
            }

            #cleanup-btn {
                display: none;
            }

            /* mobile lightbox - vertical scroll */
            #lightbox-gallery {
                flex-direction: column;
                justify-content: flex-start;
                align-items: center;
                overflow-y: auto;
                overflow-x: hidden;
                padding: 30px 20px 60px 20px;
                gap: 20px;
                top: 0;
                transform: none;
                height: 100%;
            }

            #lightbox-gallery.visible {
                pointer-events: auto;
            }

            .lightbox-image {
                max-width: 100%;
                width: auto;
                max-height: none;
                height: auto;
                cursor: default;
            }

            /* disable hover/focus transforms on mobile - keep static size */
            .lightbox-image:hover,
            .lightbox-image.focused {
                transform: none;
                box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6);
            }

            /* mobile tip - match scroll hint style */
            #lightbox-tip {
                font-size: 0;
                bottom: 20px;
                background: rgba(10, 20, 15, 0.9);
                border: 1px solid rgba(50, 150, 100, 0.4);
                border-radius: 4px;
                padding: 10px 14px;
                color: rgba(50, 150, 100, 1);
            }
            #lightbox-tip.visible {
                opacity: 1;
            }
            #lightbox-tip::after {
                content: 'tap anywhere to dismiss';
                font-size: 10px;
                letter-spacing: 2px;
            }

            /* mobile scroll hint - only in lightbox */
            body:has(#lightbox-overlay.visible) #scroll-hint {
                display: flex;
            }

            /* hide hamburger, wastebin, and clear all when lightbox active */
            #lightbox-overlay.visible ~ #hamburger-btn,
            body:has(#lightbox-overlay.visible) #hamburger-btn,
            body:has(#lightbox-overlay.visible) #wastebin,
            body:has(#lightbox-overlay.visible) #clear-all-btn {
                display: none;
            }

            /* hide close button on mobile - tap to dismiss instead */
            #lightbox-close {
                display: none !important;
            }
        }

        /* welcome overlay */
        #welcome-overlay {
            position: fixed;
            inset: 0;
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 1;
            transition: opacity 0.4s ease;
        }

        #welcome-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #welcome-content {
            max-width: 500px;
            background: rgba(10, 20, 15, 0.98);
            border: 1px solid rgba(50, 150, 100, 0.4);
            border-radius: 2px;
            box-shadow:
                0 0 30px rgba(50, 150, 100, 0.15),
                0 10px 40px rgba(0, 0, 0, 0.5);
            padding: 0;
            text-align: center;
            overflow: hidden;
        }

        #welcome-content .window-title {
            background: rgba(20, 40, 30, 0.6);
            border-bottom: 1px solid rgba(50, 150, 100, 0.3);
            padding: 10px 16px;
            font-size: 10px;
            font-weight: 700;
            letter-spacing: 1.5px;
            color: #7a9;
        }

        #welcome-content .window-body {
            padding: 24px 28px;
        }

        #welcome-content h1 {
            font-family: 'EB Garamond', Georgia, serif;
            font-size: 1.6rem;
            font-weight: 400;
            margin-bottom: 16px;
            letter-spacing: 0.02em;
            color: rgba(100, 200, 150, 0.9);
        }

        #welcome-content p {
            font-size: 0.85rem;
            line-height: 1.6;
            color: rgba(150, 180, 160, 0.8);
            margin-bottom: 12px;
        }

        #welcome-content .hint {
            font-size: 0.75rem;
            color: rgba(100, 150, 120, 0.6);
            margin-top: 20px;
            margin-bottom: 0;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        @media (max-width: 768px) {
            #welcome-content {
                margin: 20px;
                max-width: calc(100% - 40px);
            }
            #welcome-content .window-body {
                padding: 20px;
            }
            #welcome-content h1 {
                font-size: 1.4rem;
            }
        }
    </style>
</head>

<body>
    <!-- welcome overlay -->
    <div id="welcome-overlay">
        <div id="welcome-content">
            <div class="window-title">hello</div>
            <div class="window-body">
                <p>updating my website to be more of a tech demo, still adding and updating ,, feel free to look around</p>
                <p>zak</p>
                <p class="hint"><span id="click-tap">click</span> anywhere to continue</p>
            </div>
        </div>
    </div>

    <!-- film grain overlay -->
    <div id="grain-overlay"></div>

    <!-- desk lamp light cone -->
    <div id="desk-light"></div>

    <!-- mobile hamburger menu -->
    <button id="hamburger-btn" aria-label="Toggle menu">
        <span></span>
        <span></span>
        <span></span>
    </button>

    <!-- mobile menu hint -->
    <div id="menu-hint">
        <div id="menu-hint-text">tap to view projects</div>
        <div id="menu-hint-arrow">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 4v16m0 0l-6-6m6 6l6-6"/></svg>
        </div>
    </div>

    <!-- desktop menu hint -->
    <div id="desktop-hint">
        <div id="desktop-hint-arrow">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 12H4m0 0l6-6m-6 6l6 6"/></svg>
        </div>
        <div id="desktop-hint-text">click to view projects</div>
    </div>

    <!-- mobile menu backdrop -->
    <div id="menu-backdrop"></div>

    <!-- mobile wastebin -->
    <div id="wastebin">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="3 6 5 6 21 6"></polyline>
            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
        </svg>
        <span>drop to remove</span>
    </div>

    <!-- clear all button -->
    <button id="clear-all-btn">clear all</button>

    <!-- filing system (drop zones) - outside desk-container for proper z-index stacking -->
    <div id="filing-area">
        <div class="folder-stack" data-category="design">
            <div class="folder-header">
                <span>DESIGN</span>
                <span class="file-count">0</span>
            </div>
            <div class="file-list"></div>
        </div>
        <div class="folder-stack" data-category="ecommerce">
            <div class="folder-header">
                <span>ECOMMERCE</span>
                <span class="file-count">0</span>
            </div>
            <div class="file-list"></div>
        </div>
        <div class="folder-stack" data-category="saas">
            <div class="folder-header">
                <span>SAAS</span>
                <span class="file-count">0</span>
            </div>
            <div class="file-list"></div>
        </div>
        <div class="filing-footer">
            <a href="https://sandbox.zakknowlton.com/PROJECTS/FEATURED/concept_wii/">← back to dashboard</a>
            <div class="mobile-footer-bar">
                <span class="mobile-copyright">© zak knowlton 2026</span>
                <span class="mobile-clock" id="mobile-clock"></span>
            </div>
        </div>
    </div>

    <!-- desktop menu arrow hint -->
    <div id="menu-arrow">
        <svg viewBox="0 0 24 24"><polyline points="9 18 15 12 9 6"></polyline></svg>
        <span>projects</span>
    </div>

    <!-- top menu -->
    <div id="top-menu">
        <span class="clock" id="clock"></span>
    </div>

    <!-- right menu -->
    <div id="right-menu">
        <div class="menu-header">MENU</div>
        <a href="https://sandbox.zakknowlton.com/PROJECTS/FEATURED/concept_wii/" class="menu-item">DASHBOARD</a>
        <a href="https://sandbox.zakknowlton.com/" class="menu-item">ZAK'S PC</a>
        <button id="right-menu-trash" aria-label="Clear all">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="3 6 5 6 21 6"></polyline>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
            </svg>
        </button>
    </div>

    <!-- right menu arrow hint -->
    <div id="menu-arrow-right">
        <svg viewBox="0 0 24 24"><polyline points="15 18 9 12 15 6"></polyline></svg>
        <span>menu</span>
    </div>

    <!-- reactive dot matrix background -->
    <canvas id="dot-matrix"></canvas>

    <!-- desk surface -->
    <div id="desk-container">
        <!-- draggable documents container -->
        <div id="documents-area"></div>
    </div>

    <!-- ui overlay -->
    <div id="ui-overlay">
        <div id="filter-hint">click to spill • double-click to open • drag anywhere</div>
        <div id="back-link"><a href="https://sandbox.zakknowlton.com/PROJECTS/FEATURED/concept_wii/">← back to dashboard</a></div>
        <button id="cleanup-btn">clean up desk</button>
    </div>

    <!-- lightbox overlay -->
    <div id="lightbox-overlay"></div>

    <!-- lightbox gallery -->
    <div id="lightbox-gallery"></div>

    <!-- lightbox close button -->
    <button id="lightbox-close" aria-label="Close gallery">
        <span></span>
        <span></span>
        <span></span>
    </button>

    <!-- lightbox tip -->
    <div id="lightbox-tip">use arrow keys to navigate • click to focus</div>

    <!-- mobile scroll hint -->
    <div id="scroll-hint">
        <div id="scroll-hint-content">
            <span>SCROLL</span>
            <svg viewBox="0 0 24 24">
                <path d="M12 16l-6-6h12z" fill="currentColor"/>
            </svg>
        </div>
    </div>

    <!-- gsap cdn -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/Draggable.min.js"></script>

    <script>
        // register gsap plugin
        gsap.registerPlugin(Draggable);

        // placeholders (used if no real images found in manifest)
        const PLACEHOLDER_BASE = 'https://picsum.photos/seed/';
        const PLACEHOLDER_SIZE = '/400/300';

        function getPlaceholder(seed) {
            return PLACEHOLDER_BASE + seed + PLACEHOLDER_SIZE;
        }

        // work data (14 items from main index.html)
        // images will be loaded from manifest if available, otherwise use placeholders
        let WORK_ITEMS = [
            {
                title: 'Reveo', url: 'https://reveo.com', category: 'saas', type: 'folder', year: '2025',
                images: ['https://picsum.photos/seed/reveo1/400/300', 'https://picsum.photos/seed/reveo2/400/300', 'https://picsum.photos/seed/reveo3/400/300']
            },
            {
                title: 'Snowie', url: 'https://zakknowlton.com/snowie', category: 'ecommerce', type: 'folder', year: '2024',
                images: ['https://picsum.photos/seed/snowie1/400/300', 'https://picsum.photos/seed/snowie2/400/300', 'https://picsum.photos/seed/snowie3/400/300', 'https://picsum.photos/seed/snowie4/400/300']
            },
            {
                title: 'Green Philosophy Co', url: 'https://zakknowlton.com/green-philosophy', category: 'ecommerce', type: 'folder', year: '2023',
                images: ['https://picsum.photos/seed/green1/400/300', 'https://picsum.photos/seed/green2/400/300', 'https://picsum.photos/seed/green3/400/300']
            },
            {
                title: 'Raveyard Sounds', url: 'https://zakknowlton.com/raveyard-sounds', category: 'ecommerce', type: 'folder', year: '2023',
                images: ['https://picsum.photos/seed/raveyard1/400/300', 'https://picsum.photos/seed/raveyard2/400/300', 'https://picsum.photos/seed/raveyard3/400/300', 'https://picsum.photos/seed/raveyard4/400/300']
            },
            {
                title: 'gothparade', url: 'https://zakknowlton.com/gothparade', category: 'design', type: 'photo', year: '2023',
                images: ['https://picsum.photos/seed/goth1/400/300', 'https://picsum.photos/seed/goth2/400/300', 'https://picsum.photos/seed/goth3/400/300', 'https://picsum.photos/seed/goth4/400/300']
            },
            {
                title: 'Shockwav Sound Co', url: 'https://zakknowlton.com/shockwav', category: 'ecommerce', type: 'folder', year: '2022',
                images: ['https://picsum.photos/seed/shockwav1/400/300', 'https://picsum.photos/seed/shockwav2/400/300', 'https://picsum.photos/seed/shockwav3/400/300']
            },
            {
                title: 'us2', url: 'https://zakknowlton.com/us2', category: 'design', type: 'photo', year: '2022',
                images: ['https://picsum.photos/seed/us2a/400/300', 'https://picsum.photos/seed/us2b/400/300', 'https://picsum.photos/seed/us2c/400/300', 'https://picsum.photos/seed/us2d/400/300']
            },
            {
                title: 'Rave Water', url: 'https://zakknowlton.com/rave-water', category: 'design', type: 'photo', year: '2022',
                images: ['https://picsum.photos/seed/ravewater1/400/300', 'https://picsum.photos/seed/ravewater2/400/300', 'https://picsum.photos/seed/ravewater3/400/300']
            },
            {
                title: 'Beat Secrets', url: 'https://zakknowlton.com/beat-secrets', category: 'design', type: 'photo', year: '2021',
                images: ['https://picsum.photos/seed/beat1/400/300', 'https://picsum.photos/seed/beat2/400/300', 'https://picsum.photos/seed/beat3/400/300']
            },
            {
                title: 'Glass Heart', url: 'https://zakknowlton.com/glass-heart', category: 'design', type: 'photo', year: '2021',
                images: ['https://picsum.photos/seed/glass1/400/300', 'https://picsum.photos/seed/glass2/400/300', 'https://picsum.photos/seed/glass3/400/300', 'https://picsum.photos/seed/glass4/400/300']
            },
            {
                title: 'Polar Culture', url: 'https://zakknowlton.com/polar-culture', category: 'design', type: 'photo', year: '2021',
                images: ['https://picsum.photos/seed/polar1/400/300', 'https://picsum.photos/seed/polar2/400/300', 'https://picsum.photos/seed/polar3/400/300']
            },
            {
                title: 'School of Bass', url: 'https://zakknowlton.com/school-of-bass', category: 'design', type: 'photo', year: '2021',
                images: ['https://picsum.photos/seed/bass1/400/300', 'https://picsum.photos/seed/bass2/400/300', 'https://picsum.photos/seed/bass3/400/300']
            },
            {
                title: 'Crywolf', url: 'https://zakknowlton.com/crywolf', category: 'design', type: 'photo', year: '2020',
                images: ['https://picsum.photos/seed/crywolf1/400/300', 'https://picsum.photos/seed/crywolf2/400/300', 'https://picsum.photos/seed/crywolf3/400/300', 'https://picsum.photos/seed/crywolf4/400/300']
            }
        ];

        // load manifest and replace placeholder images with real ones
        async function loadImageManifest() {
            try {
                const response = await fetch('./assets/file-assets-manifest.json');
                if (!response.ok) throw new Error('Manifest not found');

                const manifest = await response.json();

                // update each work item with real images if available
                WORK_ITEMS.forEach(item => {
                    if (manifest[item.title] && manifest[item.title].length > 0) {
                        // replace placeholders with real images
                        item.images = manifest[item.title];
                        console.log(`✓ Loaded ${item.images.length} real image(s) for ${item.title}`);
                    } else {
                        console.log(`  Using placeholders for ${item.title}`);
                    }
                });

            } catch (error) {
                console.log('No manifest found, using placeholder images');
            }
        }

        // state management
        const state = {
            draggables: [],
            currentZIndex: 10,
            selectedDoc: null,
            isMobile: window.innerWidth <= 768,
            spilledFolders: new Set(), // track which folders have spilled
            spilledImages: {}, // map folder index to array of spilled image elements
            heldStack: [], // items collected via shake
            shakeContext: {
                history: [],
                lastX: 0,
                direction: 0, // 1 for right, -1 for left
                reversals: 0,
                lastReversalTime: 0
            },
            isHoveringParent: false, // tracks if currently hovering valid parent folder
            hoveredParentId: null, // tracks which folder is being hovered
            galleryActive: false, // tracks if gallery is open
            galleryImages: null, // stores original images while gallery is open
            isDragging: false, // tracks if currently dragging a document
            isDeleting: false, // tracks if delete animation in progress (prevents menu flicker)
            isDeletingStack: false, // tracks if stack deletion in progress
            menuUserClosed: false, // tracks if user explicitly closed mobile menu
            isClearingAll: false, // tracks if clearing all docs in progress
            heldImageStack: [], // items collected via shake for images
            imageShakeContext: {
                lastX: 0,
                direction: 0,
                reversals: 0,
                lastReversalTime: 0
            },
            isHoveringParentDoc: false, // tracks if image is hovering over its parent document
            hoveredParentDoc: null, // the parent document being hovered
            preloadedImages: {}, // cache of preloaded images
            currentGalleryIndex: 0, // current focused image in gallery
            gallerySourceDoc: null, // document that opened the gallery
            galleryKeyHandler: null, // keyboard handler for gallery
            hoverCollectTarget: null, // doc being hovered over for collection
            hoverCollectStart: null // timestamp when hover started
        };

        // preload images for a document
        function preloadImages(images) {
            images.forEach(src => {
                if (!state.preloadedImages[src]) {
                    const img = new Image();
                    img.src = src;
                    state.preloadedImages[src] = img;
                }
            });
        }

        // add peek effect to document (desktop only)
        function addPeekEffect(doc) {
            // no peek/tilt on mobile - hover not supported
            if (state.isMobile) return;

            let peekImages = [];

            doc.addEventListener('mouseenter', () => {
                // Don't show peek if already spilled, dragging, document not in DOM, or being deleted
                if (!doc.parentNode || state.isDragging || doc.dataset.beingDeleted === 'true') return;

                const folderIndex = doc.dataset.index;
                if (state.spilledFolders.has(folderIndex)) return;

                const images = JSON.parse(doc.dataset.images);
                if (!images || images.length === 0) return;

                // Tilt the document slightly
                const tiltAngle = (Math.random() - 0.5) * 8; // ±4 degrees
                gsap.to(doc, {
                    rotation: tiltAngle,
                    scale: 1.02,
                    duration: 0.3,
                    ease: 'power2.out'
                });

                // Get document position
                const docRect = doc.getBoundingClientRect();
                const containerRect = document.getElementById('desk-container').getBoundingClientRect();

                // Show up to 3 peek images at the edges
                const numPeeks = Math.min(3, images.length);
                const peekPositions = [
                    { x: -30, y: -20, rotation: -8 },  // top-left
                    { x: 20, y: -25, rotation: 5 },    // top-right
                    { x: -20, y: 15, rotation: -3 }    // bottom-left
                ];

                for (let i = 0; i < numPeeks; i++) {
                    const peekImg = document.createElement('img');
                    peekImg.className = 'peek-image';
                    peekImg.src = images[i];
                    peekImg.loading = 'eager';
                    peekImg.dataset.parent = folderIndex; // track parent doc

                    const baseX = docRect.left - containerRect.left;
                    const baseY = docRect.top - containerRect.top;
                    const pos = peekPositions[i];

                    gsap.set(peekImg, {
                        x: baseX + pos.x,
                        y: baseY + pos.y,
                        rotation: pos.rotation,
                        scale: 0.5,
                        opacity: 0,
                        zIndex: parseInt(gsap.getProperty(doc, 'zIndex')) - 1
                    });

                    document.getElementById('documents-area').appendChild(peekImg);
                    peekImages.push(peekImg);

                    // Animate in
                    gsap.to(peekImg, {
                        scale: 1,
                        opacity: 0.9,
                        duration: 0.3,
                        delay: i * 0.05,
                        ease: 'back.out(1.5)'
                    });
                }
            });

            doc.addEventListener('mouseleave', () => {
                // don't animate if we're dragging (onPress already cleaned up)
                if (state.isDragging) {
                    peekImages = [];
                    return;
                }

                // Reset document
                gsap.to(doc, {
                    rotation: 0,
                    scale: 1,
                    duration: 0.3,
                    ease: 'power2.out'
                });

                // Remove peek images - only if they're still in the DOM
                peekImages.forEach((img, i) => {
                    if (img.parentNode) {
                        gsap.killTweensOf(img);
                        gsap.to(img, {
                            scale: 0.5,
                            opacity: 0,
                            duration: 0.2,
                            delay: i * 0.02,
                            ease: 'power2.in',
                            onComplete: () => img.remove()
                        });
                    }
                });
                peekImages = [];
            });
        }

        // mobile menu functions
        function setupMobileMenu() {
            if (!state.isMobile) return;

            const hamburgerBtn = document.getElementById('hamburger-btn');
            const menuBackdrop = document.getElementById('menu-backdrop');
            const filingArea = document.getElementById('filing-area');

            // toggle menu
            function toggleMenu(show) {
                if (show) {
                    hamburgerBtn.classList.add('active');
                    menuBackdrop.classList.add('visible');
                    filingArea.classList.add('visible');
                } else {
                    hamburgerBtn.classList.remove('active');
                    menuBackdrop.classList.remove('visible');
                    filingArea.classList.remove('visible');
                    // collapse all accordions when menu closes
                    filingArea.querySelectorAll('.folder-stack.expanded').forEach(f => f.classList.remove('expanded'));
                }
            }

            // Store in state for external access
            state.toggleMobileMenu = toggleMenu;

            // hamburger click
            hamburgerBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const isOpen = filingArea.classList.contains('visible');
                toggleMenu(!isOpen);
            });

            // backdrop click to close
            menuBackdrop.addEventListener('click', () => {
                if (state.isDeleting) return; // don't close during delete animation
                state.menuUserClosed = true; // user explicitly closed menu
                toggleMenu(false);
            });

            // also close menu when tapping anywhere outside filing area (only if no docs)
            document.addEventListener('click', (e) => {
                if (state.isDeleting) return; // don't close during delete animation
                const isClickInsideMenu = filingArea.contains(e.target);
                const isClickOnHamburger = hamburgerBtn.contains(e.target);
                const isMenuOpen = filingArea.classList.contains('visible');
                const docsOnDesk = document.querySelectorAll('.document').length;

                if (isMenuOpen && !isClickInsideMenu && !isClickOnHamburger && docsOnDesk === 0) {
                    toggleMenu(false);
                }
            });

            // update mobile menu visibility based on docs on desk
            function updateMobileMenuVisibility() {
                if (state.isDeleting) return; // don't toggle during delete animation
                const docsOnDesk = document.querySelectorAll('.document').length;
                // close if no docs on desk, otherwise respect user's choice
                if (docsOnDesk === 0) {
                    state.menuUserClosed = false; // reset flag when desk is cleared
                    toggleMenu(false);
                } else if (!state.menuUserClosed) {
                    // only auto-open if user hasn't explicitly closed
                    toggleMenu(true);
                }
            }
            state.updateMobileMenu = updateMobileMenuVisibility;

            // mobile footer clock (military time)
            const mobileClockEl = document.getElementById('mobile-clock');
            if (mobileClockEl) {
                function updateMobileClock() {
                    const now = new Date();
                    const hours = now.getHours().toString().padStart(2, '0');
                    const minutes = now.getMinutes().toString().padStart(2, '0');
                    mobileClockEl.textContent = `${hours}:${minutes}`;
                }
                updateMobileClock();
                setInterval(updateMobileClock, 1000);
            }
        }

        // mobile scroll hint (lightbox only)
        function setupScrollHint() {
            if (!state.isMobile) return;

            const scrollHint = document.getElementById('scroll-hint');
            const lightboxGallery = document.getElementById('lightbox-gallery');
            let idleTimeout = null;

            const resetIdleTimer = () => {
                scrollHint.classList.remove('visible');
                clearTimeout(idleTimeout);
                if (state.galleryActive) {
                    idleTimeout = setTimeout(() => {
                        if (state.galleryActive) {
                            scrollHint.classList.add('visible');
                        }
                    }, 1000);
                }
            };

            // store show/hide in state for lightbox to call
            state.showScrollHint = () => {
                // only show hint if more than 2 images
                const imageCount = lightboxGallery.querySelectorAll('.lightbox-image').length;
                if (imageCount <= 2) return;
                resetIdleTimer();
            };

            state.hideScrollHint = () => {
                clearTimeout(idleTimeout);
                scrollHint.classList.remove('visible');
            };

            // hide hint on any interaction and restart timer
            ['touchstart', 'scroll'].forEach(evt => {
                lightboxGallery.addEventListener(evt, resetIdleTimer, { passive: true });
            });
        }

        // desktop offcanvas menu - stays open when docs on desk
        function setupDesktopMenu() {
            if (state.isMobile) return;

            const filingArea = document.getElementById('filing-area');
            const menuArrow = document.getElementById('menu-arrow');

            // collapse all accordions
            function collapseAccordions() {
                filingArea.querySelectorAll('.folder-stack.expanded').forEach(f => f.classList.remove('expanded'));
            }

            // expose globally so other functions can call it
            state.collapseAccordions = collapseAccordions;

            // show menu permanently (called after welcome dismissed)
            function updateMenuVisibility() {
                filingArea.classList.add('visible');
                menuArrow.classList.add('hidden');
            }

            // expose globally so other functions can call it
            state.updateDesktopMenu = updateMenuVisibility;

            // edge detection for when no docs on desk
            const triggerWidth = 60;
            const triggerZone = document.createElement('div');
            triggerZone.id = 'menu-trigger-zone';
            triggerZone.style.cssText = `
                position: fixed;
                left: 0;
                top: 0;
                width: ${triggerWidth}px;
                height: 100%;
                z-index: 999;
            `;
            document.body.appendChild(triggerZone);

            // edge triggers menu open (disabled - menu now opens after welcome dismissed)
            triggerZone.addEventListener('mouseenter', () => {
                // do nothing - edge trigger disabled
            });

            // menu stays open always on desktop - no close behavior
            filingArea.addEventListener('mouseleave', () => {
                // do nothing - menu stays open
            });

            // menu starts closed, opens after welcome dismissed
        }

        // top menu - persistent with clock (desktop only)
        function setupTopMenu() {
            if (state.isMobile) return;

            const clockEl = document.getElementById('clock');
            if (!clockEl) return;

            function updateClock() {
                const now = new Date();
                const hours = now.getHours().toString().padStart(2, '0');
                const minutes = now.getMinutes().toString().padStart(2, '0');
                const seconds = now.getSeconds().toString().padStart(2, '0');
                clockEl.textContent = `${hours}:${minutes}:${seconds}`;
            }

            updateClock();
            setInterval(updateClock, 1000);
        }

        // right menu - same logic as left menu
        function setupRightMenu() {
            if (state.isMobile) return;

            const rightMenu = document.getElementById('right-menu');
            const menuArrowRight = document.getElementById('menu-arrow-right');
            if (!rightMenu) return;

            // show menu permanently (called after welcome dismissed)
            function updateVisibility() {
                rightMenu.classList.add('visible');
                if (menuArrowRight) menuArrowRight.classList.add('hidden');
            }

            state.updateRightMenu = updateVisibility;

            // menu starts closed, opens after welcome dismissed
        }

        // mobile single-tap to open lightbox
        function setupMobileLightboxTap() {
            if (!state.isMobile) return;

            // track touch start/end for tap detection
            let touchStartTime = 0;
            let touchStartX = 0;
            let touchStartY = 0;

            document.addEventListener('touchstart', (e) => {
                const doc = e.target.closest('.document');
                if (!doc) return;

                touchStartTime = Date.now();
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            }, { passive: true });

            document.addEventListener('touchend', (e) => {
                const doc = e.target.closest('.document');
                if (!doc) return;

                const touchDuration = Date.now() - touchStartTime;
                const touchEndX = e.changedTouches[0].clientX;
                const touchEndY = e.changedTouches[0].clientY;
                const distance = Math.sqrt(
                    Math.pow(touchEndX - touchStartX, 2) +
                    Math.pow(touchEndY - touchStartY, 2)
                );

                // tap detected: quick touch with minimal movement
                if (touchDuration < 300 && distance < 10) {
                    e.preventDefault();
                    openGalleryFromDocument(doc);
                }
            });
        }

        // shake to clear all documents (mobile only)
        function setupShakeToClear() {
            if (!state.isMobile) return;

            let lastX = 0, lastY = 0, lastZ = 0;
            let lastUpdate = 0;
            let shakeCount = 0;
            let lastShakeTime = 0;
            const shakeThreshold = 15; // lowered for sensitivity
            const shakeResetTime = 800;
            const shakesRequired = 2;

            function handleMotion(e) {
                const acc = e.accelerationIncludingGravity || e.acceleration;
                if (!acc) return;

                const now = Date.now();

                // throttle to ~60fps
                if (now - lastUpdate < 16) return;
                lastUpdate = now;

                const x = acc.x || 0;
                const y = acc.y || 0;
                const z = acc.z || 0;

                const deltaX = Math.abs(x - lastX);
                const deltaY = Math.abs(y - lastY);
                const deltaZ = Math.abs(z - lastZ);
                const totalDelta = deltaX + deltaY + deltaZ;

                lastX = x;
                lastY = y;
                lastZ = z;

                // detect shake - use combined delta
                if (totalDelta > shakeThreshold) {
                    if (now - lastShakeTime > 150) { // debounce
                        shakeCount++;
                        lastShakeTime = now;

                        if (shakeCount >= shakesRequired) {
                            shakeCount = 0;
                            // only clear if not in gallery, menu closed, and not already deleting
                            const menuOpen = document.getElementById('filing-area').classList.contains('visible');
                            const galleryOpen = state.galleryActive;
                            if (!menuOpen && !galleryOpen && !state.isDeleting) {
                                clearAllDocuments();
                            }
                        }
                    }
                }

                // reset shake count if no shake for a while
                if (now - lastShakeTime > shakeResetTime) {
                    shakeCount = 0;
                }
            }

            function enableMotion() {
                window.addEventListener('devicemotion', handleMotion);
            }

            // request permission on iOS 13+ (disabled for now)
            if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                // TODO: re-enable shake permission button later
            } else {
                enableMotion();
            }
        }

        // wastebin drag detection (works for both mobile and desktop)
        function setupWastebin() {
            const wastebin = document.getElementById('wastebin');

            // show wastebin when dragging starts
            function showWastebin() {
                wastebin.classList.add('visible');
            }

            // hide wastebin when dragging ends
            function hideWastebin() {
                wastebin.classList.remove('visible', 'active');
            }

            // check if drag position is near bottom edge
            function updateWastebinState(x, y) {
                const screenHeight = window.innerHeight;
                const dropZoneHeight = 100; // matches wastebin height

                // activate when within bottom 100px of screen
                const isOver = y >= screenHeight - dropZoneHeight;

                if (isOver) {
                    wastebin.classList.add('active');
                } else {
                    wastebin.classList.remove('active');
                }

                return isOver;
            }

            // return functions for drag lifecycle
            return { showWastebin, hideWastebin, updateWastebinState };
        }

        // clear all button setup (desktop only)
        function setupClearAllButton() {
            const clearAllBtn = document.getElementById('clear-all-btn');
            const wastebin = document.getElementById('wastebin');
            let hoverTimeout = null;

            // show button when hovering over wastebin area (not while dragging)
            document.addEventListener('mousemove', (e) => {
                // don't show if dragging, no documents, or wastebin is visible
                if (state.isDragging || wastebin.classList.contains('visible')) {
                    clearAllBtn.classList.remove('visible');
                    return;
                }

                const docs = document.querySelectorAll('.document');
                if (docs.length === 0) {
                    clearAllBtn.classList.remove('visible');
                    return;
                }

                // check if mouse is in bottom center area where wastebin would appear
                const windowHeight = window.innerHeight;
                const windowWidth = window.innerWidth;
                const isInBottomCenter = e.clientY > windowHeight - 150 &&
                    e.clientX > (windowWidth / 2) - 100 &&
                    e.clientX < (windowWidth / 2) + 100;

                if (isInBottomCenter) {
                    clearTimeout(hoverTimeout);
                    clearAllBtn.classList.add('visible');
                } else {
                    // delay hiding slightly for smoother UX
                    hoverTimeout = setTimeout(() => {
                        clearAllBtn.classList.remove('visible');
                    }, 200);
                }
            });

            // handle click
            clearAllBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                clearAllDocuments();
                clearAllBtn.classList.remove('visible');
            });
        }

        // right menu trash button setup (desktop only)
        function setupRightMenuTrash() {
            const trashBtn = document.getElementById('right-menu-trash');
            if (!trashBtn) return;

            const updateTrashVisibility = () => {
                const docs = document.querySelectorAll('.document');
                if (docs.length > 0) {
                    trashBtn.classList.add('visible');
                } else {
                    trashBtn.classList.remove('visible');
                }
            };

            // watch for document changes
            const observer = new MutationObserver(updateTrashVisibility);
            observer.observe(document.getElementById('documents-area'), {
                childList: true,
                subtree: true
            });

            // handle click
            trashBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                clearAllDocuments();
            });

            // initial check
            updateTrashVisibility();
        }

        // clear all documents from desk with shuffleboard animation
        function clearAllDocuments() {
            const docs = Array.from(document.querySelectorAll('.document'));
            if (docs.length === 0) return;

            // prevent interaction during clear
            state.isDeleting = true;
            state.isClearingAll = true;

            // instantly remove all peek images
            const peekImages = document.querySelectorAll('.peek-image');
            peekImages.forEach(img => {
                gsap.killTweensOf(img);
                img.remove();
            });

            docs.forEach((doc, i) => {
                // random direction - mostly horizontal with some vertical
                const angle = (Math.random() - 0.5) * Math.PI * 0.6;
                const goLeft = Math.random() > 0.5;
                const speed = 800 + Math.random() * 400;

                const targetX = goLeft ? -speed : speed;
                const targetY = Math.sin(angle) * speed * 0.5;
                const rotation = (goLeft ? -1 : 1) * (15 + Math.random() * 20);

                // stagger the animations
                gsap.to(doc, {
                    x: `+=${targetX}`,
                    y: `+=${targetY}`,
                    rotation: rotation,
                    opacity: 0,
                    duration: 0.5,
                    delay: i * 0.05,
                    ease: 'power2.in',
                    onComplete: () => {
                        removeDocumentToMenu(doc);
                    }
                });
            });

            // reset state after all animations
            setTimeout(() => {
                state.isDeleting = false;
                state.isClearingAll = false;
                updateFileCounts();
                if (state.updateMobileMenu) state.updateMobileMenu();
            }, docs.length * 50 + 600);
        }

        // welcome overlay dismiss
        function setupWelcomeOverlay() {
            const overlay = document.getElementById('welcome-overlay');
            if (!overlay) return;

            // change "click" to "tap" on mobile
            if (state.isMobile) {
                const clickTap = document.getElementById('click-tap');
                if (clickTap) clickTap.textContent = 'tap';
            }

            overlay.addEventListener('click', () => {
                overlay.classList.add('hidden');
                setTimeout(() => overlay.remove(), 400);

                // show menu hint on mobile after welcome dismissed
                if (state.isMobile) {
                    const hint = document.getElementById('menu-hint');
                    if (hint) {
                        setTimeout(() => hint.classList.add('visible'), 500);

                        let idleTimer = null;

                        const hideHint = () => {
                            hint.classList.remove('visible');
                            // reset idle timer on any interaction
                            clearTimeout(idleTimer);
                            idleTimer = setTimeout(() => {
                                const docsOnDesk = document.querySelectorAll('.document').length;
                                const menuOpen = document.getElementById('filing-area').classList.contains('visible');
                                if (docsOnDesk === 0 && !menuOpen) {
                                    hint.classList.add('visible');
                                }
                            }, 3000);
                        };

                        ['touchstart', 'click', 'scroll'].forEach(evt => {
                            document.addEventListener(evt, hideHint, { passive: true });
                        });
                    }
                } else {
                    // desktop: open both menus permanently after welcome dismissed
                    setTimeout(() => {
                        if (state.updateDesktopMenu) state.updateDesktopMenu();
                        if (state.updateRightMenu) state.updateRightMenu();
                    }, 300);

                    // desktop hint - show with menus, hide only when accordion item clicked (doc added)
                    const desktopHint = document.getElementById('desktop-hint');
                    if (desktopHint) {
                        let hasInteracted = false;

                        const updateHintVisibility = () => {
                            const docsOnDesk = document.querySelectorAll('.document').length;
                            if (docsOnDesk > 0) {
                                hasInteracted = true;
                                desktopHint.classList.remove('visible');
                            } else if (hasInteracted) {
                                // only reshow after user has interacted once
                                desktopHint.classList.add('visible');
                            }
                        };

                        // show hint when menus appear
                        setTimeout(() => {
                            desktopHint.classList.add('visible');
                        }, 400);

                        // watch for document changes (accordion clicks add/remove docs)
                        const observer = new MutationObserver(() => {
                            updateHintVisibility();
                        });

                        observer.observe(document.getElementById('documents-area'), {
                            childList: true,
                            subtree: true
                        });
                    }
                }
            });
        }

        // reactive dot matrix background
        function setupDotMatrix() {
            const canvas = document.getElementById('dot-matrix');
            const ctx = canvas.getContext('2d');

            // slightly larger spacing on mobile for performance
            const dotSpacing = state.isMobile ? 22 : 25;
            const dotBaseRadius = 1;
            const glowRadius = state.isMobile ? 120 : 150;
            const baseBrightness = 0.15; // faint visibility across whole board when files present
            let dots = [];
            let animationId = null;
            let globalFade = 0; // smooth fade in/out
            let dragFade = 1; // fades down when dragging (files "lifted" from desk)

            function resize() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;

                // regenerate dot grid
                dots = [];
                for (let x = dotSpacing; x < canvas.width; x += dotSpacing) {
                    for (let y = dotSpacing; y < canvas.height; y += dotSpacing) {
                        dots.push({ x, y, brightness: 0 });
                    }
                }
            }

            function getElementCenters() {
                const centers = [];

                // get all documents
                document.querySelectorAll('.document').forEach(doc => {
                    const rect = doc.getBoundingClientRect();
                    centers.push({
                        x: rect.left + rect.width / 2,
                        y: rect.top + rect.height / 2,
                        size: Math.max(rect.width, rect.height)
                    });
                });

                // get all spilled images
                document.querySelectorAll('.spilled-image').forEach(img => {
                    const rect = img.getBoundingClientRect();
                    centers.push({
                        x: rect.left + rect.width / 2,
                        y: rect.top + rect.height / 2,
                        size: Math.max(rect.width, rect.height) * 0.5
                    });
                });

                return centers;
            }

            function render() {
                const elements = getElementCenters();
                const hasElements = elements.length > 0;

                // smooth global fade in/out
                const targetFade = hasElements ? 1 : 0;
                globalFade += (targetFade - globalFade) * 0.03; // slower fade

                // fade dots when dragging (files "lifted" from desk)
                const targetDragFade = state.isDragging ? 0.6 : 1;
                dragFade += (targetDragFade - dragFade) * 0.15;

                // show/hide canvas
                if (globalFade > 0.001) {
                    canvas.classList.add('visible');
                } else {
                    canvas.classList.remove('visible');
                }

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // only render if fading in/out or visible
                if (globalFade > 0.001) {
                    dots.forEach(dot => {
                        // base brightness for all dots when files present, plus proximity boost
                        let targetBrightness = hasElements ? baseBrightness : 0;

                        elements.forEach(el => {
                            const dx = dot.x - el.x;
                            const dy = dot.y - el.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            const effectRadius = glowRadius + el.size * 0.3;

                            if (distance < effectRadius) {
                                const intensity = 1 - (distance / effectRadius);
                                targetBrightness = Math.max(targetBrightness, intensity);
                            }
                        });

                        // smooth transition for individual dot brightness
                        dot.brightness += (targetBrightness - dot.brightness) * 0.1;

                        // apply global fade and drag fade to everything
                        const alpha = (0.054 + dot.brightness * 0.27) * globalFade * dragFade;

                        // shimmer effect - scale oscillation based on position and time
                        const shimmerPhase = (dot.x * 0.03 + dot.y * 0.03 + performance.now() * 0.002);
                        const shimmerAmount = dot.brightness * 0.8 * Math.sin(shimmerPhase);
                        const radius = dotBaseRadius + dot.brightness * 1.5 + shimmerAmount;

                        // glow effect for brighter dots
                        if (dot.brightness > 0.2) {
                            const glowSize = dot.brightness * 6;
                            ctx.beginPath();
                            ctx.arc(dot.x, dot.y, radius + glowSize, 0, Math.PI * 2);
                            ctx.fillStyle = `rgba(50, 150, 100, ${alpha * 0.2})`;
                            ctx.fill();
                        }

                        // dot
                        ctx.beginPath();
                        ctx.arc(dot.x, dot.y, radius, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(50, 150, 100, ${alpha})`;
                        ctx.fill();
                    });
                }

                animationId = requestAnimationFrame(render);
            }

            window.addEventListener('resize', resize);
            resize();
            render();

            // expose stop function if needed
            state.stopDotMatrix = () => {
                if (animationId) cancelAnimationFrame(animationId);
            };
        }

        // initialization
        async function init() {
            // welcome overlay
            setupWelcomeOverlay();

            // load real images from manifest first
            await loadImageManifest();

            setupFilingAreaInteractions();
            addKeyboardShortcuts();

            // wastebin setup (both mobile and desktop)
            state.wastebin = setupWastebin();

            // safety check to ensure wastebin is only visible when actually dragging
            setInterval(() => {
                const wastebin = document.getElementById('wastebin');
                if (!state.isDragging && wastebin.classList.contains('visible')) {
                    wastebin.classList.remove('visible', 'active');
                }
            }, 100);

            // clear all button setup (desktop only)
            if (!state.isMobile) {
                setupClearAllButton();
                setupRightMenuTrash();
            }

            // mobile-specific setup
            if (state.isMobile) {
                setupMobileMenu();
                setupMobileLightboxTap();
                setupShakeToClear();
                setupScrollHint();
            } else {
                setupDesktopMenu();
                setupTopMenu();
                setupRightMenu();
            }

            // dot matrix (both mobile and desktop)
            setupDotMatrix();

            // cleanup button
            document.getElementById('cleanup-btn').addEventListener('click', cleanupAllImages);

            // lightbox dismissal
            document.getElementById('lightbox-overlay').addEventListener('click', exitLightbox);
            document.getElementById('lightbox-close').addEventListener('click', exitLightbox);

            // mobile: tap anywhere on gallery to dismiss
            if (state.isMobile) {
                document.getElementById('lightbox-gallery').addEventListener('click', exitLightbox);
            }

            // click on desk background to cleanup
            document.getElementById('desk-container').addEventListener('click', (e) => {
                // only if clicking directly on the desk or background elements
                if (e.target.id === 'desk-container' ||
                    e.target.id === 'desk-light' ||
                    e.target.id === 'grain-overlay' ||
                    e.target.id === 'documents-area') {
                    gatherAllContents();
                }
            });
        }

        // gather all spilled contents back to their documents (without removing documents)
        function gatherAllContents() {
            const docs = document.querySelectorAll('.document');
            docs.forEach(doc => {
                gatherImagesToFolder(doc);
            });
        }

        // helper to manage filing area visibility based on all states
        // NOTE: on desktop, menus never close after welcome dismissed
        function updateFilingAreaVisibility(mouseX = null) {
            // disabled on desktop - menus stay open permanently
            return;
        }

        // filing area mouse interactions
        function setupFilingAreaInteractions() {
            const filingArea = document.getElementById('filing-area');
            const folders = document.querySelectorAll('.folder-stack');

            // mouse proximity detection
            document.addEventListener('mousemove', (e) => {
                updateFilingAreaVisibility(e.clientX);
            });

            // click folder header to toggle expand/collapse
            folders.forEach(folder => {
                const header = folder.querySelector('.folder-header');
                header.addEventListener('click', () => {
                    // close other folders
                    folders.forEach(f => {
                        if (f !== folder) {
                            f.classList.remove('expanded');
                        }
                    });

                    folder.classList.toggle('expanded');
                });
            });

            // populate file lists
            populateFileLists();
        }

        // insert list item sorted by year (desc) then alphabetically within year
        function insertSortedAlpha(fileList, listItem) {
            const year = parseInt(listItem.dataset.year) || 0;
            const title = (listItem.dataset.title || '').toLowerCase();
            const existingItems = fileList.querySelectorAll('.file-list-item');

            let insertBefore = null;
            for (const item of existingItems) {
                const itemYear = parseInt(item.dataset.year) || 0;
                const itemTitle = (item.dataset.title || '').toLowerCase();

                // newer year comes first
                if (year > itemYear) {
                    insertBefore = item;
                    break;
                }
                // same year - sort alphabetically
                if (year === itemYear && title < itemTitle) {
                    insertBefore = item;
                    break;
                }
            }

            if (insertBefore) {
                fileList.insertBefore(listItem, insertBefore);
            } else {
                fileList.appendChild(listItem);
            }
        }

        // populate file lists in buckets
        function populateFileLists() {
            // sort by year (desc) then alphabetically within year
            const sortedItems = [...WORK_ITEMS].sort((a, b) => {
                const yearDiff = (b.year || 0) - (a.year || 0);
                if (yearDiff !== 0) return yearDiff;
                return (a.title || '').localeCompare(b.title || '');
            });

            sortedItems.forEach(item => {
                const folder = document.querySelector(`.folder-stack[data-category="${item.category}"]`);
                const fileList = folder.querySelector('.file-list');

                const listItem = document.createElement('div');
                listItem.className = 'file-list-item';
                listItem.dataset.index = WORK_ITEMS.indexOf(item);
                listItem.dataset.category = item.category;
                listItem.dataset.url = item.url;
                listItem.dataset.images = JSON.stringify(item.images);
                listItem.dataset.title = item.title;
                listItem.dataset.year = item.year;

                listItem.innerHTML = `
                    <div class="file-item-title">${item.title}</div>
                    <div class="file-item-year">${item.year}</div>
                `;

                // make list item draggable - creates document on drag (desktop) or click (mobile)
                const eventType = state.isMobile ? 'click' : 'mousedown';
                listItem.addEventListener(eventType, (e) => {
                    handleListItemInteraction(listItem, e);
                });

                fileList.appendChild(listItem);
            });

            updateFileCounts();
        }

        function calculateOptimalMenuWidth() {
            const measureEl = document.createElement('div');
            measureEl.style.cssText = 'position:absolute; visibility:hidden; white-space:nowrap; font-family:"Courier Prime",monospace; font-size:11px; padding:10px 15px;';
            document.body.appendChild(measureEl);

            let maxWidth = 0;
            const folderHeaders = ['SAAS', 'ECOMMERCE', 'DESIGN'];

            folderHeaders.forEach(header => {
                measureEl.textContent = header;
                maxWidth = Math.max(maxWidth, measureEl.scrollWidth);
            });

            WORK_ITEMS.forEach(item => {
                measureEl.innerHTML = `<div>${item.title}</div><div>${item.year}</div>`;
                maxWidth = Math.max(maxWidth, measureEl.scrollWidth);
            });

            measureEl.remove();
            return Math.max(300, Math.min(450, maxWidth + 60));
        }

        // setup draggable for document element
        function setupDocumentDraggable(doc) {
            let isOverWastebin = false;

            // on mobile, show wastebin on touchstart (before drag)
            if (state.isMobile && state.wastebin) {
                doc.addEventListener('touchstart', () => {
                    state.wastebin.showWastebin();
                }, { passive: true });
            }

            // custom bounds to avoid menus
            const menuWidth = state.isMobile ? 0 : 260;
            const rightMenuWidth = state.isMobile ? 0 : 220;
            const topMenuHeight = state.isMobile ? 0 : 50;

            const draggable = Draggable.create(doc, {
                type: 'x,y',
                cursor: 'pointer',
                bounds: {
                    left: menuWidth,
                    top: topMenuHeight,
                    width: window.innerWidth - menuWidth - rightMenuWidth,
                    height: window.innerHeight - topMenuHeight
                },
                inertia: state.isMobile ? false : true,
                edgeResistance: 0.8,

                onPress: function () {
                    state.isDragging = true;
                    state.currentZIndex++;

                    // collapse accordions when interacting with board items
                    if (state.collapseAccordions) state.collapseAccordions();

                    // show wastebin when dragging
                    if (state.wastebin) {
                        state.wastebin.showWastebin();
                    }

                    // immediately kill and remove ALL peek images (no animation to avoid race conditions)
                    const peekImages = document.querySelectorAll('.peek-image');
                    peekImages.forEach(img => {
                        gsap.killTweensOf(img);
                        img.remove();
                    });

                    // slight tilt on pickup (mobile gets a small random tilt)
                    const pickupTilt = state.isMobile ? (Math.random() - 0.5) * 6 : 0;

                    gsap.to(this.target, {
                        zIndex: state.currentZIndex,
                        scale: 1.05,
                        rotation: pickupTilt,
                        boxShadow: '0 20px 40px rgba(0,0,0,0.7)',
                        duration: 0.1
                    });

                    // Reset shake context
                    state.shakeContext.history = [];
                    state.shakeContext.lastX = this.x;
                    state.shakeContext.reversals = 0;
                    state.shakeContext.direction = 0;
                },

                onDrag: function () {
                    // Check for shake gesture
                    checkShake(this);

                    // Check for hover-to-collect
                    checkHoverCollect(this);

                    // Move collected stack if any
                    updateHeldStackPosition(this.target);

                    // Move spilled images with document
                    updateSpilledImagesPosition(this.target);

                    // Check wastebin overlap
                    if (state.wastebin) {
                        const wasOverBin = isOverWastebin;
                        isOverWastebin = state.wastebin.updateWastebinState(this.pointerX, this.pointerY);

                        // scale document down when over wastebin
                        if (isOverWastebin && !wasOverBin) {
                            gsap.to(this.target, {
                                scale: 0.8,
                                duration: 0.2,
                                ease: 'power2.out'
                            });
                        } else if (!isOverWastebin && wasOverBin) {
                            gsap.to(this.target, {
                                scale: 1.05,
                                duration: 0.2,
                                ease: 'power2.out'
                            });
                        }
                    }

                    // Check drop zone overlap
                    checkDropZoneOverlap(this.target);
                },

                onDragEnd: function () {
                    // hide wastebin
                    if (state.wastebin) {
                        state.wastebin.hideWastebin();
                    }

                    // reset hover collect state
                    if (state.hoverCollectTarget) {
                        gsap.to(state.hoverCollectTarget, { scale: 1, duration: 0.2 });
                    }
                    state.hoverCollectTarget = null;
                    state.hoverCollectStart = null;

                    // check if dropped on wastebin - do this BEFORE setting isDragging = false
                    if (isOverWastebin) {
                        state.isDragging = false;
                        // reset folder glow states
                        resetFolderStates();
                        // delete entire stack if holding one, otherwise just the single doc
                        if (state.heldStack.length > 0) {
                            deleteStackToMenu(this.target);
                        } else {
                            removeDocumentToMenu(this.target);
                        }
                        isOverWastebin = false;
                        return;
                    }

                    // mobile: flick downward to delete
                    if (state.isMobile && typeof InertiaPlugin !== 'undefined') {
                        const velocityY = InertiaPlugin.getVelocity(this.target, 'y');
                        const velocityX = InertiaPlugin.getVelocity(this.target, 'x');

                        // flicking downward fast enough (mostly vertical direction)
                        if (velocityY > 600 && Math.abs(velocityY) > Math.abs(velocityX) * 1.2) {
                            state.isDragging = false;
                            // reset folder glow states
                            resetFolderStates();

                            // animate off screen with momentum
                            gsap.to(this.target, {
                                y: '+=400',
                                opacity: 0,
                                scale: 0.7,
                                rotation: (Math.random() - 0.5) * 15,
                                duration: 0.25,
                                ease: 'power2.in',
                                onComplete: () => {
                                    removeDocumentToMenu(this.target);
                                }
                            });
                            return;
                        }
                    }

                    // not deleting, so now safe to mark as not dragging
                    state.isDragging = false;

                    // Update filing area immediately (no longer dragging)
                    updateFilingAreaVisibility();

                    // slight tilt on set down (mobile only)
                    const setdownTilt = state.isMobile ? (Math.random() - 0.5) * 5 : 0;

                    gsap.to(this.target, {
                        scale: 1,
                        rotation: setdownTilt,
                        boxShadow: '0 8px 16px rgba(0,0,0,0.4)',
                        duration: 0.15
                    });

                    // Check if mouse is still over file - manually trigger hover state
                    setTimeout(() => {
                        const rect = this.target.getBoundingClientRect();
                        const mouseX = this.pointerX;
                        const mouseY = this.pointerY;

                        if (mouseX >= rect.left && mouseX <= rect.right &&
                            mouseY >= rect.top && mouseY <= rect.bottom) {
                            // Trigger mouseenter event to show peek
                            this.target.dispatchEvent(new MouseEvent('mouseenter', {
                                bubbles: true,
                                cancelable: true
                            }));
                        }
                    }, 50);

                    // Check if dropped on parent
                    const droppedOnParent = handleDropZoneSnap(this.target);

                    // Release stack (scatter or return to list)
                    releaseStack(droppedOnParent);
                },

                onClick: function () {
                    // Open gallery directly on click (desktop only, mobile uses tap detection)
                    if (!state.isMobile) {
                        const images = JSON.parse(this.target.dataset.images);
                        if (images && images.length > 0) {
                            openGalleryFromDocument(this.target);
                        }
                    }
                }
            })[0];

            return draggable;
        }

        // remove document and return it to menu (mobile wastebin)
        function removeDocumentToMenu(doc) {
            const index = doc.dataset.index;
            const item = WORK_ITEMS[index];
            const hasImages = item.images && item.images.length > 0;

            // prevent menu flicker during delete animation
            state.isDeleting = true;

            // CRITICAL: mark document as being deleted to prevent peek images from being created
            doc.dataset.beingDeleted = 'true';

            // instantly remove all peek images, especially those belonging to this doc
            const peekImages = document.querySelectorAll('.peek-image');
            peekImages.forEach(img => {
                gsap.killTweensOf(img);
                img.remove();
            });

            // double check - remove any peek images specifically for this doc
            const parentPeeks = document.querySelectorAll(`.peek-image[data-parent="${index}"]`);
            parentPeeks.forEach(img => {
                gsap.killTweensOf(img);
                if (img.parentNode) img.remove();
            });

            // instantly remove any spilled images (no animation)
            const folderIndex = doc.dataset.index;
            if (state.spilledFolders.has(folderIndex)) {
                const spilledImgs = state.spilledImages[folderIndex];
                if (spilledImgs) {
                    spilledImgs.forEach(img => {
                        gsap.killTweensOf(img);
                        img.remove();
                    });
                    delete state.spilledImages[folderIndex];
                    state.spilledFolders.delete(folderIndex);
                }
            }

            // kill all existing animations on document before final animation
            gsap.killTweensOf(doc);

            // animate out - quick fade and shrink
            gsap.to(doc, {
                opacity: 0,
                scale: 0.8,
                duration: 0.08,
                ease: 'power2.in',
                onComplete: () => {
                    // final cleanup - kill any remaining animations and remove document
                    gsap.killTweensOf(doc);

                    // CRITICAL: one more sweep to remove any peek images that snuck in during animation
                    const finalPeekCheck = document.querySelectorAll(`.peek-image[data-parent="${index}"]`);
                    finalPeekCheck.forEach(img => {
                        gsap.killTweensOf(img);
                        img.remove();
                    });

                    doc.remove();

                    // add back to file list
                    const folder = document.querySelector(`.folder-stack[data-category="${item.category}"]`);
                    const fileList = folder.querySelector('.file-list');

                    const listItem = document.createElement('div');
                    listItem.className = 'file-list-item';
                    listItem.dataset.category = item.category;
                    listItem.dataset.title = item.title;
                    listItem.dataset.url = item.url;
                    listItem.dataset.year = item.year;
                    listItem.dataset.index = index;
                    listItem.dataset.images = JSON.stringify(item.images);

                    listItem.innerHTML = `
                        <div class="file-item-title">${item.title}</div>
                        <div class="file-item-year">${item.year}</div>
                    `;

                    // CRITICAL: re-attach event listener so item is interactive again
                    const eventType = state.isMobile ? 'click' : 'mousedown';
                    listItem.addEventListener(eventType, (e) => {
                        handleListItemInteraction(listItem, e);
                    });

                    insertSortedAlpha(fileList, listItem);
                    updateFileCounts();

                    // update menu visibility (skip if deleting a stack or clearing all - will update after last one)
                    if (!state.isDeletingStack && !state.isClearingAll) {
                        if (state.updateDesktopMenu) state.updateDesktopMenu();
                        if (state.updateMobileMenu) state.updateMobileMenu();
                        if (state.updateRightMenu) state.updateRightMenu();
                        // allow menu changes again (only when not in bulk operation)
                        state.isDeleting = false;
                    }
                }
            });
        }

        // delete entire stack when dropped on wastebin
        function deleteStackToMenu(leaderDoc) {
            // delete all stack members with staggered animation
            const stackCopy = [...state.heldStack]; // copy before clearing
            state.heldStack = []; // clear immediately to prevent interference

            // prevent menu flicker for entire stack deletion
            state.isDeletingStack = true;

            // delete siblings first with stagger
            stackCopy.forEach((item, idx) => {
                setTimeout(() => {
                    removeDocumentToMenu(item.el);
                }, idx * 50); // 50ms stagger
            });

            // delete leader last for visual clarity
            setTimeout(() => {
                removeDocumentToMenu(leaderDoc);
            }, stackCopy.length * 50);

            // reset flags after all animations complete (stagger + animation duration)
            setTimeout(() => {
                state.isDeletingStack = false;
                state.isDeleting = false;
                if (state.updateMobileMenu) state.updateMobileMenu();
            }, (stackCopy.length * 50) + 150);
        }

        // create draggable document from list item
        // create document at specific position (used by mobile tap-to-add)
        function createDocumentAtPosition(item, index, x, y) {
            const container = document.getElementById('documents-area');

            const doc = document.createElement('div');
            doc.className = `document ${item.type}-style`;
            doc.dataset.category = item.category;
            doc.dataset.url = item.url;
            doc.dataset.index = index;
            doc.dataset.images = JSON.stringify(item.images);

            // preload images immediately
            preloadImages(item.images);

            // shuffleboard slide-in from top
            const startAngle = (Math.random() - 0.5) * 8; // ±4 degrees
            const endAngle = (Math.random() - 0.5) * 6;   // slight final angle

            // set offscreen position via inline style BEFORE adding to DOM
            doc.style.transform = `translate(${x}px, -500px) rotate(${startAngle}deg)`;
            doc.style.zIndex = state.currentZIndex++;

            doc.innerHTML = `
                <div class="doc-content">
                    <h3 class="doc-title">${item.title}</h3>
                    <div class="doc-year">${item.year}</div>
                    <div class="category-tag ${item.category}">${item.category.toUpperCase()}</div>
                </div>
            `;

            container.appendChild(doc);

            // slide in from top
            gsap.to(doc, {
                y: y,
                rotation: endAngle,
                duration: 0.5,
                ease: 'power2.out'
            });

            // setup draggable
            setupDocumentDraggable(doc);

            // update menu visibility
            if (state.updateDesktopMenu) state.updateDesktopMenu();
            if (state.updateMobileMenu) state.updateMobileMenu();
            if (state.updateRightMenu) state.updateRightMenu();

            return doc;
        }

        // handle click vs drag for list items
        function handleListItemInteraction(listItem, e) {
            // On mobile, use direct creation (bypass click/drag detection)
            if (state.isMobile) {
                e.preventDefault(); // prevent any drag behavior
                createDocumentFromListItem(listItem, e, false); // always spawn at center for mobile tap
                return;
            }

            // Desktop: detect click vs drag
            const startX = e.clientX;
            const startY = e.clientY;
            const dragThreshold = 5; // pixels
            let hasMoved = false;
            let handled = false;

            const onMouseMove = (moveEvent) => {
                const deltaX = Math.abs(moveEvent.clientX - startX);
                const deltaY = Math.abs(moveEvent.clientY - startY);

                if (deltaX > dragThreshold || deltaY > dragThreshold) {
                    hasMoved = true;
                    if (!handled) {
                        handled = true;
                        cleanup();
                        // Create at cursor and start drag
                        createDocumentFromListItem(listItem, e, true);
                    }
                }
            };

            const onMouseUp = (upEvent) => {
                if (!handled) {
                    handled = true;
                    cleanup();
                    if (!hasMoved) {
                        // Click - create at center
                        createDocumentFromListItem(listItem, upEvent, false);
                    }
                }
            };

            const cleanup = () => {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            };

            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        }

        function createDocumentFromListItem(listItem, e, isDrag = true) {
            const container = document.getElementById('documents-area');
            const containerRect = container.getBoundingClientRect();

            const doc = document.createElement('div');
            const item = WORK_ITEMS[listItem.dataset.index];
            doc.className = `document ${item.type}-style`;
            doc.dataset.category = listItem.dataset.category;
            doc.dataset.url = listItem.dataset.url;
            doc.dataset.index = listItem.dataset.index;
            doc.dataset.images = listItem.dataset.images;

            // preload images immediately
            preloadImages(JSON.parse(listItem.dataset.images));

            // determine spawn position based on interaction type
            let spawnX, spawnY;
            let startAngle = 0, endAngle = 0;

            if (isDrag) {
                // spawn at cursor position when dragging
                const cursorX = e.clientX - containerRect.left;
                const cursorY = e.clientY - containerRect.top;
                spawnX = cursorX - 110; // cursor position minus half doc width (220/2)
                spawnY = cursorY - 80;  // cursor position minus half doc height (160/2)
            } else {
                // shuffleboard spawn - random x, random y landing
                const docWidth = state.isMobile ? 170 : 220;
                const docHeight = state.isMobile ? 123 : 160;
                const padding = state.isMobile ? 20 : 150; // smaller padding on mobile
                const availableWidth = Math.max(50, containerRect.width - padding * 2 - docWidth);
                // mobile: limit to top 80% of screen
                const maxHeight = state.isMobile ? containerRect.height * 0.8 : containerRect.height;
                const availableHeight = Math.max(50, maxHeight - padding * 2 - docHeight);
                spawnX = padding + Math.random() * availableWidth;
                spawnY = padding + Math.random() * availableHeight;
                startAngle = (Math.random() - 0.5) * 8; // ±4 degrees starting angle
                endAngle = (Math.random() - 0.5) * 6;   // slight final angle
            }

            doc.style.zIndex = state.currentZIndex++;

            doc.innerHTML = `
                <div class="doc-content">
                    <h3 class="doc-title">${listItem.dataset.title}</h3>
                    <div class="doc-year">${listItem.dataset.year}</div>
                    <div class="category-tag ${listItem.dataset.category}">${listItem.dataset.category.toUpperCase()}</div>
                </div>
            `;

            container.appendChild(doc);

            // set initial position via gsap so it properly tracks transforms
            if (isDrag) {
                gsap.set(doc, { x: spawnX, y: spawnY, rotation: startAngle });
            } else {
                // start way off screen top - use container height to guarantee offscreen
                const offscreenY = -(containerRect.height + 200);
                gsap.set(doc, { x: spawnX, y: offscreenY, rotation: startAngle });
            }

            // reset menu closed flag so menu can auto-open for new doc
            state.menuUserClosed = false;

            // setup draggable
            const draggable = setupDocumentDraggable(doc);

            if (isDrag) {
                // trigger drag immediately for drag interaction
                draggable.startDrag(e);
            } else {
                // slide in from top
                gsap.to(doc, {
                    y: spawnY,
                    rotation: endAngle,
                    duration: 0.5,
                    ease: 'power2.out'
                });
            }

            // add peek effect
            addPeekEffect(doc);

            // remove from list
            listItem.remove();
            updateFileCounts();
        }

        // generate document divs dynamically
        function generateDocuments() {
            const container = document.getElementById('documents-area');

            // get folder positions
            const folders = {
                saas: document.querySelector('.folder-stack[data-category="saas"]'),
                ecommerce: document.querySelector('.folder-stack[data-category="ecommerce"]'),
                design: document.querySelector('.folder-stack[data-category="design"]')
            };

            // track count per category
            const counts = { saas: 0, ecommerce: 0, design: 0 };

            WORK_ITEMS.forEach((item, index) => {
                const doc = document.createElement('div');
                doc.className = `document ${item.type}-style`;
                doc.dataset.category = item.category;
                doc.dataset.url = item.url;
                doc.dataset.index = index;

                // store images data
                doc.dataset.images = JSON.stringify(item.images);

                // position in category bucket (stacked)
                const folder = folders[item.category];
                const folderRect = folder.getBoundingClientRect();
                const containerRect = document.getElementById('desk-container').getBoundingClientRect();

                const stackOffset = counts[item.category] * 2;
                const baseX = folderRect.left - containerRect.left + 20;
                const baseY = folderRect.top - containerRect.top + 40;

                gsap.set(doc, {
                    x: baseX + stackOffset,
                    y: baseY + stackOffset,
                    rotation: 0,
                    scale: 0.6, // smaller in bucket
                    zIndex: 10 + index
                });

                counts[item.category]++;

                // content structure
                doc.innerHTML = `
                    <div class="doc-content">
                        <h3 class="doc-title">${item.title}</h3>
                        <div class="doc-year">${item.year}</div>
                        <div class="category-tag ${item.category}">${item.category.toUpperCase()}</div>
                    </div>
                `;

                container.appendChild(doc);
            });

            // update file counts
            updateFileCounts();
        }

        // update file count displays
        function updateFileCounts() {
            const counts = { saas: 0, ecommerce: 0, design: 0 };

            document.querySelectorAll('.file-list-item').forEach(item => {
                counts[item.dataset.category]++;
            });

            Object.keys(counts).forEach(category => {
                const folder = document.querySelector(`.folder-stack[data-category="${category}"]`);
                const countSpan = folder.querySelector('.file-count');
                countSpan.textContent = counts[category];
            });
        }

        // gsap draggable setup (legacy - now using setupDocumentDraggable)
        function setupDraggables() {
            const docs = document.querySelectorAll('.document');

            docs.forEach(doc => {
                const draggable = setupDocumentDraggable(doc);
                state.draggables.push(draggable);

                // add peek effect
                addPeekEffect(doc);
            });
        }

        // === SHAKE & STACK LOGIC ===

        function checkShake(draggable) {
            const currentX = draggable.x;
            const now = Date.now();
            const ctx = state.shakeContext;

            // Calculate delta and direction
            const delta = currentX - ctx.lastX;
            const direction = Math.sign(delta);

            // Only count significant moves
            if (Math.abs(delta) > 10) { // Reduced threshold for sensitivity
                if (direction !== ctx.direction && ctx.direction !== 0) {
                    // Direction reversal detected
                    if (now - ctx.lastReversalTime < 400) { // Increased window slightly
                        ctx.reversals++;
                    } else {
                        ctx.reversals = 1;
                    }
                    ctx.lastReversalTime = now;
                }
                ctx.direction = direction;
            }

            ctx.lastX = currentX;

            // Trigger shake if reversals threshold met
            // Reset reversals immediately to prevent multi-trigger
            if (ctx.reversals >= 3 && state.heldStack.length === 0) { // Reduced to 3
                collectSiblings(draggable.target);
                ctx.reversals = 0;
            }
        }

        function checkHoverCollect(draggable) {
            const draggedDoc = draggable.target;
            const category = draggedDoc.dataset.category;

            // get center of dragged doc
            const draggedRect = draggedDoc.getBoundingClientRect();
            const draggedCenterX = draggedRect.left + draggedRect.width / 2;
            const draggedCenterY = draggedRect.top + draggedRect.height / 2;

            // check all other docs on desk
            const allDocs = document.querySelectorAll('.document');
            let closestDoc = null;
            let closestDist = 100; // threshold distance in px

            allDocs.forEach(doc => {
                if (doc === draggedDoc) return;
                if (state.heldStack.some(item => item.el === doc)) return; // skip already collected

                const docRect = doc.getBoundingClientRect();
                const docCenterX = docRect.left + docRect.width / 2;
                const docCenterY = docRect.top + docRect.height / 2;

                const dist = Math.sqrt(
                    Math.pow(draggedCenterX - docCenterX, 2) +
                    Math.pow(draggedCenterY - docCenterY, 2)
                );

                if (dist < closestDist) {
                    closestDist = dist;
                    closestDoc = doc;
                }
            });

            // clear previous hover state
            if (state.hoverCollectTarget && state.hoverCollectTarget !== closestDoc) {
                gsap.to(state.hoverCollectTarget, {
                    scale: 1,
                    duration: 0.2
                });
            }

            // if hovering over valid target
            if (closestDoc) {
                // visual feedback - pulse the target
                if (state.hoverCollectTarget !== closestDoc) {
                    gsap.to(closestDoc, {
                        scale: 1.08,
                        duration: 0.2,
                        ease: 'power2.out'
                    });
                }
                state.hoverCollectTarget = closestDoc;

                // if held long enough, collect
                const now = Date.now();
                if (!state.hoverCollectStart) {
                    state.hoverCollectStart = now;
                } else if (now - state.hoverCollectStart > 150) {
                    // trigger collection of single hovered doc only
                    collectSingleDoc(draggedDoc, state.hoverCollectTarget);
                    state.hoverCollectTarget = null;
                    state.hoverCollectStart = null;
                }
            } else {
                state.hoverCollectTarget = null;
                state.hoverCollectStart = null;
            }
        }

        // collect single doc to stack (hover-to-collect)
        function collectSingleDoc(leaderDoc, targetDoc) {
            if (!targetDoc || targetDoc === leaderDoc) return;
            if (state.heldStack.some(item => item.el === targetDoc)) return;

            // gather spilled contents from target
            const targetIndex = targetDoc.dataset.index;
            if (state.spilledFolders.has(targetIndex)) {
                gatherImagesToFolder(targetDoc);
            }

            // disable dragging
            const dragInstance = Draggable.get(targetDoc);
            if (dragInstance) dragInstance.disable();

            // add to stack
            state.heldStack.push({
                el: targetDoc,
                offsetX: (Math.random() * 10 - 5),
                offsetY: (Math.random() * 10 - 5) + 5
            });

            // animate to leader
            gsap.to(targetDoc, {
                x: gsap.getProperty(leaderDoc, "x") + (Math.random() * 10 - 5),
                y: gsap.getProperty(leaderDoc, "y") + (Math.random() * 20 - 10) + 10,
                rotation: gsap.getProperty(leaderDoc, "rotation") + (Math.random() * 10 - 5),
                scale: 1,
                zIndex: state.currentZIndex - 1,
                duration: 0.4,
                ease: "back.out(1.2)"
            });

            // pulse leader
            gsap.fromTo(leaderDoc,
                { scale: 1.1 },
                { scale: 1.05, duration: 0.2, ease: "elastic.out(1, 0.3)" }
            );

            updateFilingAreaVisibility();
        }

        function collectSiblings(leaderDoc) {
            const category = leaderDoc.dataset.category;
            const allDocs = document.querySelectorAll('.document');

            // gather spilled contents from leader when stacking
            const leaderIndex = leaderDoc.dataset.index;
            if (state.spilledFolders.has(leaderIndex)) {
                gatherImagesToFolder(leaderDoc);
            }

            // Find valid siblings on the desk (allow any category)
            const siblings = Array.from(allDocs).filter(doc =>
                doc !== leaderDoc &&
                !state.heldStack.some(item => item.el === doc)
            );

            if (siblings.length === 0) return;

            // gather spilled contents from siblings too
            siblings.forEach(doc => {
                const siblingIndex = doc.dataset.index;
                if (state.spilledFolders.has(siblingIndex)) {
                    gatherImagesToFolder(doc);
                }
            });

            // Animate them to the leader
            siblings.forEach((doc, i) => {
                // Disable individual dragging for siblings
                const dragInstance = Draggable.get(doc);
                if (dragInstance) dragInstance.disable();

                // Add to stack
                state.heldStack.push({
                    el: doc,
                    offsetX: (Math.random() * 10 - 5), // Tighter offset
                    offsetY: (Math.random() * 10 - 5) + 5
                });

                // Animate to position
                gsap.to(doc, {
                    x: gsap.getProperty(leaderDoc, "x") + (Math.random() * 10 - 5),
                    y: gsap.getProperty(leaderDoc, "y") + (Math.random() * 20 - 10) + 10,
                    rotation: gsap.getProperty(leaderDoc, "rotation") + (Math.random() * 10 - 5),
                    scale: 1,
                    zIndex: state.currentZIndex - 1 - i,
                    duration: 0.5,
                    ease: "back.out(1.2)"
                });
            });

            // Pulse the leader
            gsap.fromTo(leaderDoc,
                { scale: 1.15 },
                { scale: 1.05, duration: 0.3, ease: "elastic.out(1, 0.3)" }
            );

            // Update filing area visibility (stack collected = should open)
            updateFilingAreaVisibility();
        }

        function gatherSpilledImagesIntoStack(doc) {
            const folderIndex = doc.dataset.index;
            const spilledImgs = state.spilledImages[folderIndex];

            if (!spilledImgs || spilledImgs.length === 0) return;

            const docX = gsap.getProperty(doc, 'x') || 0;
            const docY = gsap.getProperty(doc, 'y') || 0;

            // gather images into stack formation instantly (no animation during drag)
            spilledImgs.forEach((img, i) => {
                const stackOffsetX = i * 5; // horizontal offset for stack
                const stackOffsetY = i * 5 + 20; // vertical offset - stack below

                // update offsets first
                img.dataset.offsetX = stackOffsetX;
                img.dataset.offsetY = stackOffsetY;

                // set position instantly
                gsap.set(img, {
                    x: docX + stackOffsetX,
                    y: docY + stackOffsetY,
                    rotation: 0,
                    scale: 0.95
                });
            });
        }

        function spreadSpilledImagesFromStack(doc) {
            const folderIndex = doc.dataset.index;
            const spilledImgs = state.spilledImages[folderIndex];

            if (!spilledImgs || spilledImgs.length === 0) return;

            const docRect = doc.getBoundingClientRect();
            const docX = gsap.getProperty(doc, 'x');
            const docY = gsap.getProperty(doc, 'y');

            // spread images back to original pattern
            spilledImgs.forEach((img, i) => {
                const totalImages = spilledImgs.length;
                const angleStep = (360 / totalImages);
                const currentAngle = (angleStep * i) * (Math.PI / 180);
                const distance = 150 + Math.random() * 30;

                const centerX = docX + docRect.width / 2;
                const centerY = docY + docRect.height / 2;
                const imgWidth = 220;
                const imgHeight = 160;

                const endX = centerX + Math.cos(currentAngle) * distance - imgWidth / 2;
                const endY = centerY + Math.sin(currentAngle) * distance - imgHeight / 2;

                gsap.to(img, {
                    x: endX,
                    y: endY,
                    rotation: (Math.random() - 0.5) * 20,
                    scale: 1,
                    duration: 0.3,
                    ease: 'power2.out'
                });

                // update offsets for new positions
                img.dataset.offsetX = endX - docX;
                img.dataset.offsetY = endY - docY;
            });
        }

        function updateSpilledImagesPosition(doc) {
            const folderIndex = doc.dataset.index;
            const spilledImgs = state.spilledImages[folderIndex];

            if (!spilledImgs || spilledImgs.length === 0) return;

            // get current document position
            const x = gsap.getProperty(doc, 'x');
            const y = gsap.getProperty(doc, 'y');

            // move each spilled image relative to document
            spilledImgs.forEach(img => {
                const offsetX = parseFloat(img.dataset.offsetX) || 0;
                const offsetY = parseFloat(img.dataset.offsetY) || 0;

                gsap.set(img, {
                    x: x + offsetX,
                    y: y + offsetY
                });
            });
        }

        function updateHeldStackPosition(leaderDoc) {
            if (state.heldStack.length === 0) return;

            const leaderX = gsap.getProperty(leaderDoc, "x");
            const leaderY = gsap.getProperty(leaderDoc, "y");

            state.heldStack.forEach(item => {
                gsap.to(item.el, {
                    x: leaderX + item.offsetX,
                    y: leaderY + item.offsetY,
                    duration: 0.1, // Slight lag for natural feel
                    overwrite: "auto"
                });
            });
        }

        function releaseStack(droppedOnParent) {
            if (state.heldStack.length === 0) return;

            if (droppedOnParent) {
                // If dropped on parent, return all to list is handled by caller logic usually
                // But we can double check here
                state.heldStack.forEach(item => {
                    returnFileToList(item.el);
                });
            } else {
                // Return to desk state
                state.heldStack.forEach(item => {
                    const dragInstance = Draggable.get(item.el);
                    if (dragInstance) dragInstance.enable();

                    gsap.to(item.el, {
                        x: "+=" + (Math.random() * 60 - 30),
                        y: "+=" + (Math.random() * 60 - 30),
                        rotation: "+=" + (Math.random() * 20 - 10),
                        duration: 0.4,
                        ease: "power2.out"
                    });
                });
            }

            state.heldStack = [];

            // Update filing area visibility (stack released = might close)
            updateFilingAreaVisibility();
        }

        // overlap detection for drop zones (specific parent folder)
        function checkDropZoneOverlap(doc) {
            const category = doc.dataset.category;
            const targetFolder = document.querySelector(`.folder-stack[data-category="${category}"]`);

            if (!targetFolder) return;

            const docRect = doc.getBoundingClientRect();
            const folderRect = targetFolder.getBoundingClientRect();

            // QUANTUM PROXIMITY CHECK (Center-to-Center)
            const docCx = docRect.left + docRect.width / 2;
            const docCy = docRect.top + docRect.height / 2;
            const folderCx = folderRect.left + folderRect.width / 2;
            const folderCy = folderRect.top + folderRect.height / 2;

            const distance = Math.hypot(docCx - folderCx, docCy - folderCy);

            // Only glow if within 250px of center (increased for easier targeting)
            const isOverlapping = distance < 250;

            if (isOverlapping) {
                if (!state.isHoveringParent) {
                    state.isHoveringParent = true;
                    // swell glow disabled
                }
            } else {
                if (state.isHoveringParent) {
                    state.isHoveringParent = false;
                }
            }
        }

        // snap to drop zone (return to list) - desktop only
        function handleDropZoneSnap(doc) {
            // mobile: only wastebin can remove files
            if (state.isMobile) return false;

            if (state.isHoveringParent) {
                // Return main file
                returnFileToList(doc);
                state.isHoveringParent = false;
                return true; // Dropped on parent
            }
            return false;
        }

        // reset all folder visuals (called when sidebar hides)
        function resetFolderStates() {
            state.isHoveringParent = false;
            // clear any lingering inline styles
            const folders = document.querySelectorAll('.folder-stack');
            folders.forEach(folder => {
                folder.style.boxShadow = '';
                folder.style.backgroundColor = '';
            });
        }

        // return file to list and remove from desk
        function returnFileToList(doc) {
            const category = doc.dataset.category;
            const folder = document.querySelector(`.folder-stack[data-category="${category}"]`);
            const fileList = folder.querySelector('.file-list');
            const index = doc.dataset.index;

            // CRITICAL: mark document as being filed to prevent peek images from being created
            doc.dataset.beingDeleted = 'true';

            // remove ALL peek images immediately
            const allPeeks = document.querySelectorAll('.peek-image');
            allPeeks.forEach(img => {
                gsap.killTweensOf(img);
                img.remove();
            });

            // double check - remove any peek images specifically for this doc
            const peekImages = document.querySelectorAll(`.peek-image[data-parent="${index}"]`);
            peekImages.forEach(img => {
                gsap.killTweensOf(img);
                if (img.parentNode) img.remove();
            });

            // gather spilled images first
            gatherImagesToFolder(doc);

            // create list item
            const listItem = document.createElement('div');
            listItem.className = 'file-list-item';
            listItem.dataset.index = doc.dataset.index;
            listItem.dataset.category = doc.dataset.category;
            listItem.dataset.url = doc.dataset.url;
            listItem.dataset.images = doc.dataset.images;
            listItem.dataset.title = doc.querySelector('.doc-title').textContent;
            listItem.dataset.year = doc.querySelector('.doc-year').textContent;

            listItem.innerHTML = `
                <div class="file-item-title">${listItem.dataset.title}</div>
                <div class="file-item-year">${listItem.dataset.year}</div>
            `;

            // make draggable (desktop) or clickable (mobile)
            const eventType = state.isMobile ? 'click' : 'mousedown';
            listItem.addEventListener(eventType, (e) => {
                handleListItemInteraction(listItem, e);
            });

            // animate document to list position then remove
            const listRect = fileList.getBoundingClientRect();
            const containerRect = document.getElementById('desk-container').getBoundingClientRect();
            const targetX = listRect.left - containerRect.left;
            const targetY = listRect.bottom - containerRect.top;

            gsap.to(doc, {
                x: targetX,
                y: targetY,
                scale: 0.5,
                opacity: 0,
                duration: 0.08,
                ease: 'power2.in',
                onComplete: () => {
                    // CRITICAL: one more sweep to remove any peek images that snuck in during animation
                    const finalPeekCheck = document.querySelectorAll(`.peek-image[data-parent="${index}"]`);
                    finalPeekCheck.forEach(img => {
                        gsap.killTweensOf(img);
                        img.remove();
                    });

                    doc.remove();
                    insertSortedAlpha(fileList, listItem);
                    updateFileCounts();

                    // expand folder to show file was added
                    folder.classList.add('expanded');

                    // update menu visibility
                    if (state.updateDesktopMenu) state.updateDesktopMenu();
                    if (state.updateMobileMenu) state.updateMobileMenu();
                    if (state.updateRightMenu) state.updateRightMenu();
                }
            });
        }

        // spill images out from document (toggle behavior)
        function spillImages(doc) {
            const folderIndex = doc.dataset.index;

            // if already spilled, gather back instead
            if (state.spilledFolders.has(folderIndex)) {
                gatherImagesToFolder(doc);
                return;
            }

            // return all other spilled contents first
            const allDocs = document.querySelectorAll('.document');
            allDocs.forEach(otherDoc => {
                if (otherDoc !== doc && state.spilledFolders.has(otherDoc.dataset.index)) {
                    gatherImagesToFolder(otherDoc);
                }
            });

            const images = JSON.parse(doc.dataset.images);
            const docRect = doc.getBoundingClientRect();
            const containerRect = document.getElementById('desk-container').getBoundingClientRect();
            const container = document.getElementById('documents-area');

            // track spilled images for this folder
            state.spilledImages[folderIndex] = [];

            images.forEach((imgUrl, i) => {
                const img = document.createElement('img');
                img.className = 'spilled-image';
                img.loading = 'eager';
                img.src = imgUrl;
                img.dataset.parent = folderIndex;

                // image size matches document
                const imgWidth = 220;
                const imgHeight = 160;

                // get document's current GSAP position
                const docX = gsap.getProperty(doc, 'x') || 0;
                const docY = gsap.getProperty(doc, 'y') || 0;

                // document center in GSAP coordinates
                const centerX = docX + docRect.width / 2;
                const centerY = docY + docRect.height / 2;

                // start position (at document center)
                const startX = centerX - imgWidth / 2;
                const startY = centerY - imgHeight / 2;

                // spread evenly in circle around document
                const totalImages = images.length;
                const angleStep = (360 / totalImages);
                const currentAngle = (angleStep * i) * (Math.PI / 180);
                const distance = 150 + Math.random() * 30;

                const endX = centerX + Math.cos(currentAngle) * distance - imgWidth / 2;
                const endY = centerY + Math.sin(currentAngle) * distance - imgHeight / 2;
                const randomRot = (Math.random() - 0.5) * 20;

                // set initial position
                gsap.set(img, {
                    x: startX,
                    y: startY,
                    rotation: 0,
                    scale: 0.3,
                    opacity: 0,
                    zIndex: 50 + i
                });

                container.appendChild(img);

                // store relative offset from parent's GSAP position for dragging
                img.dataset.offsetX = endX - docX;
                img.dataset.offsetY = endY - docY;

                // track this image
                state.spilledImages[folderIndex].push(img);

                // animate spill out
                gsap.to(img, {
                    x: endX,
                    y: endY,
                    rotation: randomRot,
                    scale: 1,
                    opacity: 1,
                    duration: 0.15,
                    delay: i * 0.01,
                    ease: 'power2.out',
                    onComplete: () => {
                        makeImageDraggable(img);
                    }
                });
            });

            // mark as spilled
            state.spilledFolders.add(folderIndex);

            // hide parent document temporarily and send to back
            gsap.to(doc, {
                opacity: 1,
                scale: 0.95,
                zIndex: 5, // send opened files to back
                duration: 0.1
            });
        }

        // make spilled image draggable
        function makeImageDraggable(img) {
            // custom bounds to avoid menus
            const menuWidth = state.isMobile ? 0 : 260;
            const rightMenuWidth = state.isMobile ? 0 : 220;
            const topMenuHeight = state.isMobile ? 0 : 50;

            Draggable.create(img, {
                type: 'x,y',
                cursor: 'pointer',
                bounds: {
                    left: menuWidth,
                    top: topMenuHeight,
                    width: window.innerWidth - menuWidth - rightMenuWidth,
                    height: window.innerHeight - topMenuHeight
                },
                inertia: state.isMobile ? false : true,
                edgeResistance: 0.8,

                onPress: function () {
                    state.currentZIndex++;

                    // collapse accordions when interacting with board items
                    if (state.collapseAccordions) state.collapseAccordions();

                    gsap.to(this.target, {
                        zIndex: state.currentZIndex,
                        scale: 1.05,
                        duration: 0.1
                    });

                    // Reset shake context for images
                    state.imageShakeContext.lastX = this.x;
                    state.imageShakeContext.reversals = 0;
                    state.imageShakeContext.direction = 0;
                },

                onDrag: function () {
                    // Check for shake gesture
                    checkImageShake(this);

                    // Move collected stack if any
                    updateHeldImageStackPosition(this.target);

                    // Check if hovering over parent document
                    checkParentDocOverlap(this.target);
                },

                onDragEnd: function () {
                    // if dragged enough, don't treat as click
                    this.isDragging = false;

                    gsap.to(this.target, {
                        scale: 1,
                        duration: 0.15
                    });

                    // Check if dropped on parent document
                    const droppedOnParent = handleParentDocSnap(this.target);

                    // Release image stack if not dropped on parent
                    if (!droppedOnParent) {
                        releaseImageStack();
                    }
                },

                onClick: function () {
                    // enter lightbox on click
                    enterLightbox(this.target);
                }
            });
        }

        // === IMAGE SHAKE & STACK LOGIC ===

        function checkImageShake(draggable) {
            const currentX = draggable.x;
            const now = Date.now();
            const ctx = state.imageShakeContext;

            // Calculate delta and direction
            const delta = currentX - ctx.lastX;
            const direction = Math.sign(delta);

            // Only count significant moves
            if (Math.abs(delta) > 10) {
                if (direction !== ctx.direction && ctx.direction !== 0) {
                    // Direction reversal detected
                    if (now - ctx.lastReversalTime < 400) {
                        ctx.reversals++;
                    } else {
                        ctx.reversals = 1;
                    }
                    ctx.lastReversalTime = now;
                }
                ctx.direction = direction;
            }

            ctx.lastX = currentX;

            // Trigger shake if reversals threshold met
            if (ctx.reversals >= 3 && state.heldImageStack.length === 0) {
                collectSiblingImages(draggable.target);
                ctx.reversals = 0;
            }
        }

        function collectSiblingImages(leaderImg) {
            const parentIndex = leaderImg.dataset.parent;
            const allImages = document.querySelectorAll('.spilled-image');

            // Find valid siblings (same parent folder)
            const siblings = Array.from(allImages).filter(img =>
                img !== leaderImg &&
                img.dataset.parent === parentIndex &&
                !state.heldImageStack.some(item => item.el === img)
            );

            if (siblings.length === 0) return;

            // Animate them to the leader
            siblings.forEach((img, i) => {
                // Disable individual dragging for siblings
                const dragInstance = Draggable.get(img);
                if (dragInstance) dragInstance.disable();

                // Add to stack
                state.heldImageStack.push({
                    el: img,
                    offsetX: (Math.random() * 10 - 5),
                    offsetY: (Math.random() * 10 - 5) + 5
                });

                // Animate to position
                gsap.to(img, {
                    x: gsap.getProperty(leaderImg, "x") + (Math.random() * 10 - 5),
                    y: gsap.getProperty(leaderImg, "y") + (Math.random() * 20 - 10) + 10,
                    rotation: gsap.getProperty(leaderImg, "rotation") + (Math.random() * 10 - 5),
                    scale: 1,
                    zIndex: state.currentZIndex - 1 - i,
                    duration: 0.5,
                    ease: "back.out(1.2)"
                });
            });

            // Pulse the leader
            gsap.fromTo(leaderImg,
                { scale: 1.15 },
                { scale: 1.05, duration: 0.3, ease: "elastic.out(1, 0.3)" }
            );
        }

        function updateHeldImageStackPosition(leaderImg) {
            if (state.heldImageStack.length === 0) return;

            const leaderX = gsap.getProperty(leaderImg, "x");
            const leaderY = gsap.getProperty(leaderImg, "y");

            state.heldImageStack.forEach(item => {
                gsap.to(item.el, {
                    x: leaderX + item.offsetX,
                    y: leaderY + item.offsetY,
                    duration: 0.1,
                    overwrite: "auto"
                });
            });
        }

        function releaseImageStack() {
            if (state.heldImageStack.length === 0) return;

            // Scatter the stack
            state.heldImageStack.forEach(item => {
                const dragInstance = Draggable.get(item.el);
                if (dragInstance) dragInstance.enable();

                gsap.to(item.el, {
                    x: "+=" + (Math.random() * 60 - 30),
                    y: "+=" + (Math.random() * 60 - 30),
                    rotation: "+=" + (Math.random() * 20 - 10),
                    duration: 0.4,
                    ease: "power2.out"
                });
            });

            state.heldImageStack = [];
        }

        // Check if image is over its parent document
        function checkParentDocOverlap(img) {
            // only show visual indication if holding a stack (single images can't be dropped)
            if (state.heldImageStack.length === 0) {
                if (state.isHoveringParentDoc) {
                    resetParentDocState();
                }
                return;
            }

            const parentIndex = img.dataset.parent;
            const parentDoc = document.querySelector(`.document[data-index="${parentIndex}"]`);

            if (!parentDoc) {
                if (state.isHoveringParentDoc) {
                    resetParentDocState();
                }
                return;
            }

            const imgRect = img.getBoundingClientRect();
            const docRect = parentDoc.getBoundingClientRect();

            // Center-to-center distance check
            const imgCx = imgRect.left + imgRect.width / 2;
            const imgCy = imgRect.top + imgRect.height / 2;
            const docCx = docRect.left + docRect.width / 2;
            const docCy = docRect.top + docRect.height / 2;

            const distance = Math.hypot(imgCx - docCx, imgCy - docCy);

            // Hovering if within 150px of document center
            const isOverlapping = distance < 150;

            if (isOverlapping) {
                if (!state.isHoveringParentDoc) {
                    state.isHoveringParentDoc = true;
                    state.hoveredParentDoc = parentDoc;
                    // Swell animation
                    gsap.to(parentDoc, {
                        scale: 1.15,
                        opacity: 1,
                        boxShadow: '0 20px 40px rgba(255, 255, 255, 0.3)',
                        duration: 0.3,
                        ease: 'back.out(1.7)'
                    });
                }
            } else {
                if (state.isHoveringParentDoc) {
                    resetParentDocState();
                }
            }
        }

        // Reset parent document visual state
        function resetParentDocState() {
            if (state.hoveredParentDoc) {
                gsap.to(state.hoveredParentDoc, {
                    scale: 1,
                    opacity: 0.3,
                    boxShadow: '0 8px 16px rgba(0,0,0,0.4)',
                    duration: 0.2
                });
            }
            state.isHoveringParentDoc = false;
            state.hoveredParentDoc = null;
        }

        // Handle drop on parent document
        function handleParentDocSnap(img) {
            // Only accept stacks, not single images
            if (state.heldImageStack.length === 0) {
                return false;
            }

            if (state.isHoveringParentDoc && state.hoveredParentDoc) {
                const parentDoc = state.hoveredParentDoc;
                const parentIndex = img.dataset.parent;

                // Gather the leader image
                const imagesToGather = [img];

                // Add all stacked images
                state.heldImageStack.forEach(item => {
                    imagesToGather.push(item.el);
                });

                // Animate all images back to parent
                const docRect = parentDoc.getBoundingClientRect();
                const containerRect = document.getElementById('desk-container').getBoundingClientRect();
                const targetX = docRect.left - containerRect.left + (docRect.width - 162) / 2;
                const targetY = docRect.top - containerRect.top + (docRect.height - 126) / 2;

                imagesToGather.forEach((image, i) => {
                    gsap.to(image, {
                        x: targetX,
                        y: targetY,
                        rotation: 0,
                        scale: 0.3,
                        opacity: 0,
                        duration: 0.3,
                        delay: i * 0.02,
                        ease: 'power3.in',
                        onComplete: () => {
                            image.remove();
                        }
                    });
                });

                // Clear the stack
                state.heldImageStack = [];

                // Check if all images are gathered, if so restore document to unopened state
                setTimeout(() => {
                    const stillRemaining = document.querySelectorAll(`.spilled-image[data-parent="${parentIndex}"]`);
                    if (stillRemaining.length === 0) {
                        // Mark as not spilled
                        state.spilledFolders.delete(parentIndex);
                        state.spilledImages[parentIndex] = [];

                        // Restore document to unopened state
                        gsap.to(parentDoc, {
                            opacity: 1,
                            scale: 1,
                            zIndex: state.currentZIndex++,
                            duration: 0.3
                        });
                    }
                }, imagesToGather.length * 20 + 300);

                // Reset parent doc state
                resetParentDocState();

                return true;
            }
            return false;
        }

        // === LIGHTBOX LOGIC ===

        function getHighResUrl(url) {
            // simpler approach: just replace the dimensions if it's picsum
            // picsum format: .../seed/stuff/400/300
            if (url.includes('picsum.photos')) {
                return url.replace('/400/300', '/1600/1200');
            }
            return url;
        }

        function openGalleryFromDocument(doc) {
            if (state.galleryActive) return;

            const images = JSON.parse(doc.dataset.images);
            if (!images || images.length === 0) return;

            const folderIndex = doc.dataset.index;

            // Spill images behind overlay if not already spilled
            if (!state.spilledFolders.has(folderIndex)) {
                spillImagesForGallery(doc);
            }

            // Show overlay
            document.getElementById('lightbox-overlay').classList.add('visible');

            // Create gallery
            const gallery = document.getElementById('lightbox-gallery');
            gallery.innerHTML = '';

            images.forEach((imgUrl, index) => {
                const galleryImg = document.createElement('img');
                galleryImg.className = 'lightbox-image';
                galleryImg.src = getHighResUrl(imgUrl);
                galleryImg.dataset.index = index;
                galleryImg.loading = 'eager';

                // Click to focus/unfocus (desktop only)
                if (!state.isMobile) {
                    galleryImg.addEventListener('click', (e) => {
                        e.stopPropagation();
                        toggleFocusImage(galleryImg);
                    });
                }

                gallery.appendChild(galleryImg);
            });

            // Show gallery
            setTimeout(() => {
                gallery.classList.add('visible');
                document.getElementById('lightbox-close').classList.add('visible');
                document.getElementById('lightbox-tip').classList.add('visible');
                // Mobile: center if 1-2 images, top-align if more
                if (state.isMobile) {
                    const imageCount = gallery.querySelectorAll('.lightbox-image').length;
                    gallery.style.justifyContent = imageCount <= 2 ? 'center' : 'flex-start';
                    gallery.scrollTop = 0;
                    if (state.showScrollHint) state.showScrollHint();
                }
            }, 50);

            state.galleryActive = true;
            state.gallerySourceDoc = doc;
            state.currentGalleryIndex = 0;
            setupGalleryKeyboardNav();
            setupMobileGalleryCarousel();
        }

        // Spill images for gallery (no toggle, just spill)
        function spillImagesForGallery(doc) {
            const folderIndex = doc.dataset.index;
            const images = JSON.parse(doc.dataset.images);
            const docRect = doc.getBoundingClientRect();
            const containerRect = document.getElementById('desk-container').getBoundingClientRect();
            const container = document.getElementById('documents-area');

            // Track spilled images for this folder
            state.spilledImages[folderIndex] = [];

            images.forEach((imgUrl, i) => {
                const img = document.createElement('img');
                img.className = 'spilled-image';
                img.loading = 'eager';
                img.src = imgUrl;
                img.dataset.parent = folderIndex;

                // image size matches document
                const imgWidth = 220;
                const imgHeight = 160;

                // get document's current GSAP position
                const docX = gsap.getProperty(doc, 'x') || 0;
                const docY = gsap.getProperty(doc, 'y') || 0;

                // document center in GSAP coordinates
                const centerX = docX + docRect.width / 2;
                const centerY = docY + docRect.height / 2;

                // start position (at document center)
                const startX = centerX - imgWidth / 2;
                const startY = centerY - imgHeight / 2;

                // spread evenly in circle around document
                const totalImages = images.length;
                const angleStep = (360 / totalImages);
                const currentAngle = (angleStep * i) * (Math.PI / 180);
                const distance = 150 + Math.random() * 30;

                const endX = centerX + Math.cos(currentAngle) * distance - imgWidth / 2;
                const endY = centerY + Math.sin(currentAngle) * distance - imgHeight / 2;
                const randomRot = (Math.random() - 0.5) * 20;

                gsap.set(img, {
                    x: startX,
                    y: startY,
                    rotation: 0,
                    scale: 0.3,
                    opacity: 0,
                    zIndex: 5
                });

                container.appendChild(img);

                // store relative offset from parent's GSAP position for dragging
                img.dataset.offsetX = endX - docX;
                img.dataset.offsetY = endY - docY;

                state.spilledImages[folderIndex].push(img);

                gsap.to(img, {
                    x: endX,
                    y: endY,
                    rotation: randomRot,
                    scale: 1,
                    opacity: 1,
                    duration: 0.15,
                    delay: i * 0.01,
                    ease: 'power2.out'
                });
            });

            state.spilledFolders.add(folderIndex);

            gsap.to(doc, {
                opacity: 1,
                scale: 0.95,
                zIndex: 5,
                duration: 0.1
            });
        }

        function enterLightbox(img) {
            if (state.galleryActive) return; // already active

            // Get all images from same parent
            const parentIndex = img.dataset.parent;
            const allImages = Array.from(document.querySelectorAll(`.spilled-image[data-parent="${parentIndex}"]`));

            // Get parent document
            const parentDoc = document.querySelector(`.document[data-index="${parentIndex}"]`);
            if (parentDoc) {
                state.gallerySourceDoc = parentDoc;
            }

            // Disable all document dragging to prevent wastebin from showing
            const allDocs = document.querySelectorAll('.document');
            allDocs.forEach(doc => {
                const dragInstance = Draggable.get(doc);
                if (dragInstance) dragInstance.disable();
            });

            // Hide all original images
            allImages.forEach(image => {
                const dragInstance = Draggable.get(image);
                if (dragInstance) dragInstance.disable();
                gsap.set(image, { opacity: 0 });
            });

            // Show overlay
            document.getElementById('lightbox-overlay').classList.add('visible');

            // Create gallery
            const gallery = document.getElementById('lightbox-gallery');
            gallery.innerHTML = ''; // clear existing

            allImages.forEach((image, index) => {
                const galleryImg = document.createElement('img');
                galleryImg.className = 'lightbox-image';
                galleryImg.src = getHighResUrl(image.src);
                galleryImg.dataset.index = index;
                galleryImg.dataset.originalImage = index;
                galleryImg.loading = 'eager';

                // Click to focus/unfocus (desktop only)
                if (!state.isMobile) {
                    galleryImg.addEventListener('click', (e) => {
                        e.stopPropagation();
                        toggleFocusImage(galleryImg);
                    });
                }

                gallery.appendChild(galleryImg);
            });

            // Show gallery
            setTimeout(() => {
                gallery.classList.add('visible');
                document.getElementById('lightbox-close').classList.add('visible');
                document.getElementById('lightbox-tip').classList.add('visible');
                // Mobile: center if 1-2 images, top-align if more
                if (state.isMobile) {
                    const imageCount = gallery.querySelectorAll('.lightbox-image').length;
                    gallery.style.justifyContent = imageCount <= 2 ? 'center' : 'flex-start';
                    gallery.scrollTop = 0;
                    if (state.showScrollHint) state.showScrollHint();
                }
            }, 50);

            state.galleryActive = true;
            state.galleryImages = allImages;
            state.currentGalleryIndex = 0;
            setupGalleryKeyboardNav();
            setupMobileGalleryCarousel();
        }

        function setupGalleryKeyboardNav() {
            if (state.galleryKeyHandler) {
                document.removeEventListener('keydown', state.galleryKeyHandler);
            }

            state.galleryKeyHandler = (e) => {
                if (!state.galleryActive) return;

                if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    navigateGallery(-1);
                } else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    navigateGallery(1);
                }
            };

            document.addEventListener('keydown', state.galleryKeyHandler);
        }

        function setupMobileGalleryCarousel() {
            // mobile uses simple vertical scroll - no setup needed
            return;
        }

        function navigateGallery(direction) {
            if (state.isMobile) return; // mobile uses different interaction

            const gallery = document.getElementById('lightbox-gallery');
            const images = Array.from(gallery.querySelectorAll('.lightbox-image'));

            if (images.length === 0) return;

            // Get currently focused image
            const currentlyFocused = gallery.querySelector('.lightbox-image.focused');
            let currentIndex = currentlyFocused ? parseInt(currentlyFocused.dataset.index) : -1;

            let targetIndex;

            // If something is already focused, navigate linearly to immediate neighbors
            if (currentIndex !== -1) {
                if (direction < 0) {
                    // Left arrow - go to immediate left neighbor if exists
                    targetIndex = currentIndex > 0 ? currentIndex - 1 : null;
                } else {
                    // Right arrow - go to immediate right neighbor if exists
                    targetIndex = currentIndex < images.length - 1 ? currentIndex + 1 : null;
                }

                // If no neighbor in that direction, do nothing
                if (targetIndex === null) return;
            } else {
                // Initial selection - use edge-based logic
                if (images.length === 1) {
                    // 1 item: any arrow focuses it
                    targetIndex = 0;
                } else if (images.length === 2) {
                    // 2 items: left = 0, right = 1
                    targetIndex = direction < 0 ? 0 : 1;
                } else {
                    // 3+ items: left arrow = leftmost, right arrow = rightmost
                    targetIndex = direction < 0 ? 0 : images.length - 1;
                }
            }

            // Focus the target image
            const targetImage = images[targetIndex];
            if (targetImage && !targetImage.classList.contains('focused')) {
                toggleFocusImage(targetImage);
            }
        }

        function toggleFocusImage(img) {
            const allGalleryImages = document.querySelectorAll('.lightbox-image');

            if (img.classList.contains('focused')) {
                // Unfocus - restore all to full opacity
                img.classList.remove('focused');
                allGalleryImages.forEach(i => {
                    gsap.to(i, { opacity: 1, duration: 0.3 });
                });
            } else {
                // Remove focus from all others
                allGalleryImages.forEach(i => i.classList.remove('focused'));
                // Focus this one
                img.classList.add('focused');

                // Center focused image in viewport (accounting for 1.5x scale)
                const gallery = document.getElementById('lightbox-gallery');
                const imgRect = img.getBoundingClientRect();
                const galleryRect = gallery.getBoundingClientRect();

                // image center relative to gallery scroll position
                const imgCenter = imgRect.left + imgRect.width / 2 - galleryRect.left + gallery.scrollLeft;
                // account for 1.5x scale - need extra padding
                const scaledHalfWidth = (imgRect.width * 1.5) / 2;
                const viewportCenter = galleryRect.width / 2;

                // scroll so image center lands at viewport center
                const targetScrollLeft = imgCenter - viewportCenter;

                gallery.scrollTo({
                    left: Math.max(0, targetScrollLeft),
                    behavior: 'smooth'
                });

                // Fade all others to low opacity
                allGalleryImages.forEach(i => {
                    if (i !== img) {
                        gsap.to(i, { opacity: 0.2, duration: 0.3 });
                    } else {
                        gsap.to(i, { opacity: 1, duration: 0.3 });
                    }
                });

                // Update current index
                const index = parseInt(img.dataset.index);
                if (!isNaN(index)) {
                    state.currentGalleryIndex = index;
                }
            }
        }

        function exitLightbox() {
            if (!state.galleryActive) return;

            // CRITICAL: Immediately hide wastebin and reset drag state
            state.isDragging = false;
            if (state.wastebin) {
                state.wastebin.hideWastebin();
            }

            // Remove keyboard handler
            if (state.galleryKeyHandler) {
                document.removeEventListener('keydown', state.galleryKeyHandler);
                state.galleryKeyHandler = null;
            }

            // Remove scroll handler (mobile)
            const gallery = document.getElementById('lightbox-gallery');
            if (state.galleryScrollHandler) {
                gallery.removeEventListener('scroll', state.galleryScrollHandler);
                state.galleryScrollHandler = null;
            }

            // Hide overlay
            document.getElementById('lightbox-overlay').classList.remove('visible');

            // Hide gallery
            gallery.classList.remove('visible');
            document.getElementById('lightbox-close').classList.remove('visible');
            document.getElementById('lightbox-tip').classList.remove('visible');
            // Hide scroll hint on mobile
            if (state.hideScrollHint) {
                state.hideScrollHint();
            }

            setTimeout(() => {
                gallery.innerHTML = '';
            }, 200);

            // Reset source document to default state
            if (state.gallerySourceDoc) {
                // Reset drag state and visual properties
                state.selectedDoc = null;

                gsap.to(state.gallerySourceDoc, {
                    scale: 1,
                    rotation: 0,
                    boxShadow: '0 8px 16px rgba(0,0,0,0.4)',
                    duration: 0.2
                });

                // Re-enable draggable if it was disabled
                const dragInstance = Draggable.get(state.gallerySourceDoc);
                if (dragInstance) dragInstance.enable();

                // Gather spilled images back
                gatherImagesToFolder(state.gallerySourceDoc);
            }

            // Re-enable all document dragging
            const allDocs = document.querySelectorAll('.document');
            allDocs.forEach(doc => {
                const dragInstance = Draggable.get(doc);
                if (dragInstance) dragInstance.enable();
            });

            // Show original images if they exist (for enterLightbox path)
            if (state.galleryImages) {
                state.galleryImages.forEach(image => {
                    gsap.set(image, { opacity: 1 });
                    const dragInstance = Draggable.get(image);
                    if (dragInstance) dragInstance.enable();
                });
            }

            state.galleryActive = false;
            state.galleryImages = null;
            state.gallerySourceDoc = null;
            state.currentGalleryIndex = 0;
        }

        // double-click to open original url
        function openDocument(doc) {
            const url = doc.dataset.url;
            window.open(url, '_blank');
        }

        // gather spilled images back to folder
        function gatherImagesToFolder(doc) {
            const folderIndex = doc.dataset.index;
            const spilledImgs = state.spilledImages[folderIndex];

            if (!spilledImgs || spilledImgs.length === 0) return;

            const docRect = doc.getBoundingClientRect();
            const containerRect = document.getElementById('desk-container').getBoundingClientRect();
            const imgWidth = 220;
            const imgHeight = 160;
            const targetX = docRect.left - containerRect.left + (docRect.width - imgWidth) / 2;
            const targetY = docRect.top - containerRect.top + (docRect.height - imgHeight) / 2;

            spilledImgs.forEach((img, i) => {
                gsap.to(img, {
                    x: targetX,
                    y: targetY,
                    rotation: 0,
                    scale: 0.3,
                    opacity: 0,
                    duration: 0.12,
                    delay: i * 0.005,
                    ease: 'power2.in',
                    onComplete: () => {
                        img.remove();
                    }
                });
            });

            // restore folder appearance and ensure it's interactive
            gsap.to(doc, {
                opacity: 1,
                scale: 1,
                rotation: 0,
                duration: 0.15,
                onComplete: () => {
                    // ensure document is clickable and peek works again
                    doc.style.pointerEvents = 'all';
                    doc.style.cursor = 'pointer';
                }
            });

            // clear tracking - this allows peek to work again
            state.spilledImages[folderIndex] = [];
            state.spilledFolders.delete(folderIndex);
        }

        // cleanup all: return images + files to list and remove from desk
        function cleanupAllImages() {
            const docs = Array.from(document.querySelectorAll('.document'));

            docs.forEach((doc, index) => {
                // gather spilled images back first
                gatherImagesToFolder(doc);

                // return file to list with staggered animation
                setTimeout(() => {
                    returnFileToList(doc);
                }, index * 100); // stagger by 100ms each
            });
        }

        // idle animation (subtle paper movement)
        function startIdleAnimation() {
            const docs = document.querySelectorAll('.document');

            docs.forEach((doc, i) => {
                gsap.to(doc, {
                    y: '+=3',
                    rotation: '+=0.5',
                    duration: 3 + Math.random() * 2,
                    repeat: -1,
                    yoyo: true,
                    ease: 'sine.inOut',
                    delay: i * 0.2
                });
            });
        }

        // keyboard shortcuts
        function addKeyboardShortcuts() {
            window.addEventListener('keydown', (e) => {
                // ESC: Exit gallery OR navigate home
                if (e.key === 'Escape') {
                    if (state.galleryActive) {
                        exitLightbox();
                    } else {
                        window.location.href = 'https://sandbox.zakknowlton.com/PROJECTS/FEATURED/concept_wii/';
                    }
                }

                if (state.galleryActive) return; // disable others while in gallery

                // category filter shortcuts
                if (e.key === '1') filterByCategory('saas');
                if (e.key === '2') filterByCategory('ecommerce');
                if (e.key === '3') filterByCategory('design');
                if (e.key === '0') showAllDocuments();

                // tilde key: show tips
                if (e.key === '`') {
                    document.getElementById('filter-hint').classList.add('visible');
                    document.getElementById('back-link').classList.add('visible');
                    document.getElementById('cleanup-btn').classList.add('visible');
                }
            });

            window.addEventListener('keyup', (e) => {
                // tilde key: hide tips
                if (e.key === '`') {
                    document.getElementById('filter-hint').classList.remove('visible');
                    document.getElementById('back-link').classList.remove('visible');
                    document.getElementById('cleanup-btn').classList.remove('visible');
                }
            });
        }

        // category filtering
        function filterByCategory(category) {
            const docs = document.querySelectorAll('.document');

            docs.forEach(doc => {
                if (doc.dataset.category === category) {
                    gsap.to(doc, { opacity: 1, scale: 1, duration: 0.3 });
                } else {
                    gsap.to(doc, { opacity: 0.2, scale: 0.9, duration: 0.3 });
                }
            });
        }

        function showAllDocuments() {
            const docs = document.querySelectorAll('.document');
            gsap.to(docs, { opacity: 1, scale: 1, duration: 0.3, stagger: 0.05 });
        }

        // init on load
        window.addEventListener('load', init);
    </script>
</body>

</html>