<!DOCTYPE html>
<html lang="en">

<head>
    <script>
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                window.location.href = 'https://sandbox.zakknowlton.com/';
            }
        });
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>CLICK AND DRAG</title>
    <link id="favicon" rel="icon" href="favicon.png">
    <link rel="apple-touch-icon" href="favicon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="favicon.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&display=swap" rel="stylesheet">

    <style>
        /* === RESET === */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body,
        html {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #0a0a0a;
            font-family: 'Courier Prime', monospace;
            cursor: default;
            user-select: none;
            -webkit-user-select: none;
            overscroll-behavior: none;
            touch-action: none;
        }

        /* === BACKGROUND IMAGE === */
        body {
            background-image: url('assets/background.jpg');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 10, 0.7);
            z-index: 0;
            pointer-events: none;
        }

        /* === NOISE OVERLAY === */
        #grain-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('data:image/svg+xml,%3Csvg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg"%3E%3Cfilter id="noiseFilter"%3E%3CfeTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="4" stitchTiles="stitch"/%3E%3C/filter%3E%3Crect width="100%25" height="100%25" filter="url(%23noiseFilter)"/%3E%3C/svg%3E');
            opacity: 0.08;
            pointer-events: none;
            z-index: 100;
            mix-blend-mode: overlay;
        }

        /* === AMBIENT GLOW === */
        #desk-light {
            display: none;
        }

        /* === DESK CONTAINER === */
        #desk-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: transparent;
            overflow: hidden;
            z-index: 1;
        }

        /* === FILING AREA === */
        #filing-area {
            position: fixed;
            left: calc(-1 * var(--menu-width, 260px));
            top: 20px;
            bottom: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 1000;
            padding: 20px;
            width: var(--menu-width, 260px);
            background: rgba(10, 20, 15, 0.98);
            border-right: 1px solid rgba(50, 150, 100, 0.3);
            box-shadow: 4px 0 20px rgba(0, 0, 0, 0.7);
            overflow-y: auto;
            transition: left 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #filing-area.visible {
            left: 0;
        }

        /* desktop menu arrow hint */
        #menu-arrow {
            position: fixed;
            left: 8px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 999;
            display: flex;
            align-items: center;
            gap: 8px;
            pointer-events: none;
            opacity: 0.7;
            transition: opacity 0.3s ease, left 0.3s ease;
        }

        #menu-arrow.hidden {
            opacity: 0;
            left: -50px;
        }

        #menu-arrow svg {
            width: 20px;
            height: 20px;
            fill: none;
            stroke: rgba(100, 200, 150, 0.8);
            stroke-width: 2;
            animation: arrow-pulse 2s ease-in-out infinite;
        }

        #menu-arrow span {
            font-size: 10px;
            color: rgba(100, 200, 150, 0.8);
            letter-spacing: 1px;
            text-transform: uppercase;
            white-space: nowrap;
        }

        @keyframes arrow-pulse {
            0%, 100% { transform: translateX(0); opacity: 0.7; }
            50% { transform: translateX(5px); opacity: 1; }
        }

        /* hide arrow when menu visible */
        #filing-area.visible ~ #menu-arrow,
        body:has(#filing-area.visible) #menu-arrow {
            opacity: 0;
            pointer-events: none;
        }

        .folder-stack {
            position: relative;
            width: 100%;
            background: rgba(20, 40, 30, 0.5);
            border: 1px solid rgba(50, 150, 100, 0.3);
            border-radius: 2px;
            padding: 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            overflow: hidden;
        }

        .folder-header {
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: #7a9;
        }

        .folder-stack:hover {
            background: rgba(50, 150, 100, 0.2);
            border-color: rgba(50, 150, 100, 0.5);
        }

        .file-list {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .folder-stack.expanded .file-list {
            max-height: 600px;
        }

        .file-list-item {
            padding: 10px 15px;
            border-top: 1px solid rgba(50, 150, 100, 0.2);
            cursor: pointer;
            transition: background 0.2s ease;
            font-size: 11px;
            color: #8ab;
        }

        .file-list-item:hover {
            background: rgba(50, 150, 100, 0.15);
        }

        .file-list-item:active {
            cursor: pointer;
        }

        .file-item-title {
            font-weight: 600;
            margin-bottom: 3px;
        }

        .file-item-year {
            font-size: 9px;
            opacity: 0.6;
        }

        .folder-stack[data-category="saas"] {
            background: rgba(58, 124, 165, 0.15);
            border-color: rgba(58, 124, 165, 0.4);
        }

        .folder-stack[data-category="ecommerce"] {
            background: rgba(201, 85, 77, 0.15);
            border-color: rgba(201, 85, 77, 0.4);
        }

        .folder-stack[data-category="design"] {
            background: rgba(138, 43, 226, 0.15);
            border-color: rgba(138, 43, 226, 0.4);
        }

        .folder-stack.drag-over {
            transform: scale(1);
            box-shadow:
                0 8px 20px rgba(255, 255, 255, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .file-count {
            font-size: 9px;
            opacity: 0.6;
            font-weight: 400;
            letter-spacing: 1px;
        }

        .filing-footer {
            margin-top: auto;
            padding: 15px;
            border-top: 1px solid rgba(50, 150, 100, 0.2);
        }

        .filing-footer a {
            color: #8ab;
            text-decoration: none;
            font-size: 10px;
            letter-spacing: 1px;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }

        .filing-footer a:hover {
            opacity: 1;
        }

        /* === MOBILE HAMBURGER MENU === */
        #hamburger-btn {
            display: none;
            position: fixed;
            top: 20px;
            left: 20px;
            width: 44px;
            height: 44px;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 6px;
            background: rgba(10, 20, 15, 0.98);
            border: 1px solid rgba(50, 150, 100, 0.3);
            border-radius: 2px;
            z-index: 2000;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        #hamburger-btn span {
            display: block;
            width: 20px;
            height: 2px;
            background: rgba(50, 150, 100, 0.8);
            transition: all 0.3s ease;
        }

        #hamburger-btn:hover {
            background: rgba(50, 150, 100, 0.2);
            border-color: rgba(50, 150, 100, 0.5);
        }

        #hamburger-btn:hover span {
            background: rgba(50, 150, 100, 1);
        }

        #hamburger-btn.active span:nth-child(1) {
            transform: translateY(8px) rotate(45deg);
        }

        #hamburger-btn.active span:nth-child(2) {
            opacity: 0;
        }

        #hamburger-btn.active span:nth-child(3) {
            transform: translateY(-8px) rotate(-45deg);
        }

        #hamburger-btn.active {
            left: 280px;
        }

        #menu-backdrop {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            z-index: 900;
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            pointer-events: all;
        }

        #menu-backdrop.visible {
            transform: translateX(0);
        }

        /* === WASTEBIN === */
        #wastebin {
            display: flex;
            position: fixed;
            bottom: -100px;
            left: 50%;
            transform: translateX(-50%);
            width: 120px;
            height: 80px;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 8px;
            background: rgba(201, 85, 77, 0.2);
            border: 2px solid rgba(201, 85, 77, 0.5);
            border-radius: 4px;
            color: rgba(201, 85, 77, 0.8);
            z-index: 950;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #wastebin svg {
            width: 32px;
            height: 32px;
        }

        #wastebin span {
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #wastebin.visible {
            bottom: 30px;
        }

        #wastebin.active {
            transform: translateX(-50%) scale(1.2);
            background: rgba(201, 85, 77, 0.5);
            border-color: rgba(201, 85, 77, 1);
            border-width: 3px;
            color: rgba(255, 255, 255, 1);
            box-shadow: 0 0 20px rgba(201, 85, 77, 0.8), 0 0 40px rgba(201, 85, 77, 0.4);
            animation: pulse 0.8s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% {
                transform: translateX(-50%) scale(1.2);
                box-shadow: 0 0 20px rgba(201, 85, 77, 0.8), 0 0 40px rgba(201, 85, 77, 0.4);
            }
            50% {
                transform: translateX(-50%) scale(1.25);
                box-shadow: 0 0 30px rgba(201, 85, 77, 1), 0 0 50px rgba(201, 85, 77, 0.6);
            }
        }

        /* === CLEAR ALL BUTTON === */
        #clear-all-btn {
            display: flex;
            position: fixed;
            bottom: -100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(201, 85, 77, 0.3);
            border: 2px solid rgba(201, 85, 77, 0.6);
            color: rgba(201, 85, 77, 0.9);
            padding: 12px 24px;
            font-family: 'Courier Prime', monospace;
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            border-radius: 4px;
            cursor: pointer;
            z-index: 960;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            letter-spacing: 1px;
            pointer-events: all;
            align-items: center;
            justify-content: center;
        }

        #clear-all-btn.visible {
            bottom: 30px;
        }

        #clear-all-btn:hover {
            background: rgba(201, 85, 77, 0.5);
            border-color: rgba(201, 85, 77, 0.9);
            color: rgba(201, 85, 77, 1);
            transform: translateX(-50%) scale(1.05);
        }

        #clear-all-btn:active {
            transform: translateX(-50%) scale(0.95);
        }

        /* hide wastebin and clear all when lightbox is active */
        body:has(#lightbox-overlay.visible) #wastebin,
        body:has(#lightbox-overlay.visible) #clear-all-btn {
            display: none !important;
        }

        /* === DOCUMENTS AREA === */
        #documents-area {
            position: absolute;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        .document {
            position: absolute;
            width: 220px;
            height: 160px;
            background: rgba(15, 25, 20, 0.9);
            border-radius: 2px;
            border: 1px solid rgba(50, 150, 100, 0.3);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.8);
            cursor: pointer;
            transition: box-shadow 0.15s ease;
            will-change: transform;
            padding: 16px;
        }

        .document:hover {
            /* hover animation disabled - conflicts with gsap transforms */
        }

        .document::before {
            content: '';
            position: absolute;
            top: 3px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            box-shadow:
                inset 0 1px 2px rgba(0, 0, 0, 0.4),
                0 2px 4px rgba(0, 0, 0, 0.3);
            pointer-events: none;
        }

        .document:active {
            cursor: grabbing !important;
        }

        .document.folder-style {
            background: #1a1a1a;
        }

        .document.photo-style {
            background: #222;
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6),
                        inset 0 1px 0 rgba(255, 255, 255, 0.05);
        }

        .document.photo-style .doc-content {
            background: transparent;
            width: 100%;
            height: 100%;
            padding: 15px;
        }

        .doc-title {
            font-size: 14px;
            font-weight: 700;
            color: #8fc;
            margin-bottom: 5px;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .doc-year {
            font-size: 11px;
            font-weight: 400;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 10px;
            letter-spacing: 2px;
        }

        .category-tag {
            position: absolute;
            bottom: 10px;
            right: 10px;
            padding: 4px 10px;
            font-size: 9px;
            font-weight: 700;
            letter-spacing: 1.5px;
            border-radius: 3px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
            color: rgba(255, 255, 255, 0.6);
        }

        .category-tag.saas {
            background: rgba(58, 124, 165, 0.2);
            border: 1px solid rgba(58, 124, 165, 0.5);
            color: #5a9fd4;
        }

        .category-tag.ecommerce {
            background: rgba(201, 85, 77, 0.2);
            border: 1px solid rgba(201, 85, 77, 0.5);
            color: #e88a82;
        }

        .category-tag.design {
            background: rgba(138, 43, 226, 0.2);
            border: 1px solid rgba(138, 43, 226, 0.5);
            color: #a060ea;
        }

        /* === UI OVERLAY === */
        #ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }

        #filter-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 20, 15, 0.95);
            color: #8ab;
            padding: 10px 20px;
            font-size: 11px;
            border-radius: 2px;
            border: 1px solid rgba(50, 150, 100, 0.3);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.6);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        #filter-hint.visible {
            opacity: 1;
        }

        #back-link {
            position: absolute;
            top: 20px;
            right: 20px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        #back-link.visible {
            opacity: 1;
            pointer-events: all;
        }

        #back-link a {
            color: #8ab;
            text-decoration: none;
            font-size: 13px;
            padding: 10px 20px;
            background: rgba(10, 20, 15, 0.95);
            border: 1px solid rgba(50, 150, 100, 0.3);
            border-radius: 2px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: inline-block;
        }

        #back-link a:hover {
            background: rgba(50, 150, 100, 0.15);
            border-color: rgba(50, 150, 100, 0.6);
            color: #8fc;
        }

        #cleanup-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(20, 40, 30, 0.8);
            color: #8ab;
            border: 1px solid rgba(50, 150, 100, 0.4);
            padding: 12px 24px;
            font-family: 'Courier Prime', monospace;
            font-size: 14px;
            font-weight: 700;
            text-transform: uppercase;
            border-radius: 2px;
            cursor: pointer;
            pointer-events: none;
            transition: all 0.3s ease;
            letter-spacing: 1px;
            opacity: 0;
        }

        #cleanup-btn.visible {
            opacity: 1;
            pointer-events: all;
        }

        #cleanup-btn:hover {
            background: rgba(50, 150, 100, 0.3);
            border-color: rgba(50, 150, 100, 0.7);
            color: #8fc;
            transform: scale(1.05);
        }

        #cleanup-btn:active {
            transform: scale(0.95);
        }

        /* === SPILLED IMAGES === */
        .spilled-image {
            position: absolute;
            max-width: 180px;
            max-height: 140px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.6);
            cursor: pointer;
            will-change: transform;
            z-index: 50;
            object-fit: contain;
            border-radius: 2px;
            image-rendering: crisp-edges;
            image-rendering: -webkit-optimize-contrast;
        }

        .spilled-image.pseudo-spill {
            z-index: 5;
            pointer-events: none;
        }

        .spilled-image:active {
            cursor: grabbing !important;
        }

        /* === PEEK IMAGES === */
        .peek-image {
            position: absolute;
            max-width: 100px;
            max-height: 80px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            pointer-events: none;
            z-index: 4;
            object-fit: cover;
            border-radius: 2px;
            opacity: 0.9;
        }


        /* === LIGHTBOX OVERLAY === */
        #lightbox-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 10, 8, 0.25);
            opacity: 0;
            pointer-events: none;
            z-index: 900;
            transition: opacity 0.2s ease;
            backdrop-filter: blur(2px);
        }

        #lightbox-overlay.visible {
            opacity: 1;
            pointer-events: all;
            cursor: pointer;
        }

        /* === LIGHTBOX GALLERY === */
        #lightbox-gallery {
            position: fixed;
            top: 50%;
            left: 0;
            right: 0;
            transform: translateY(-50%);
            display: flex;
            gap: 30px;
            align-items: center;
            justify-content: center;
            z-index: 1002;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            padding: 15vh 5vw;
            overflow-x: auto;
            overflow-y: visible;
            scroll-behavior: smooth;
        }

        #lightbox-gallery::-webkit-scrollbar {
            display: none;
        }

        #lightbox-gallery.visible {
            opacity: 1;
            pointer-events: none;
        }

        .lightbox-image {
            max-width: 350px;
            max-height: 50vh;
            cursor: pointer;
            transition: all 0.15s ease;
            object-fit: contain;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6);
            border: none;
            pointer-events: all;
        }

        .lightbox-image:hover {
            transform: scale(1.05) translateY(-8px);
            box-shadow: 0 12px 32px rgba(0, 0, 0, 0.8);
        }

        .lightbox-image.focused {
            transform: scale(1.5);
            z-index: 1003;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.9);
        }

        /* === LIGHTBOX TIP === */
        #lightbox-tip {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.5);
            font-size: 12px;
            font-family: 'Courier Prime', monospace;
            z-index: 1004;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            text-align: center;
        }

        #lightbox-tip.visible {
            opacity: 1;
        }

        /* Remove shadow from PNGs */
        .spilled-image[src$=".png"],
        .spilled-image[src*=".png?"],
        .spilled-image[src*=".png#"],
        .peek-image[src$=".png"],
        .peek-image[src*=".png?"],
        .peek-image[src*=".png#"],
        .lightbox-image[src$=".png"],
        .lightbox-image[src*=".png?"],
        .lightbox-image[src*=".png#"] {
            box-shadow: none !important;
        }

        /* === LIGHTBOX CLOSE BUTTON === */
        #lightbox-close {
            display: flex;
            position: fixed;
            top: -60px;
            right: 20px;
            width: 44px;
            height: 44px;
            background: rgba(20, 40, 30, 0.8);
            border: 1px solid rgba(50, 150, 100, 0.4);
            border-radius: 2px;
            z-index: 1004;
            cursor: pointer;
            pointer-events: none;
            transition: top 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: 6px;
        }

        #lightbox-close span {
            display: block;
            width: 20px;
            height: 2px;
            background: rgba(50, 150, 100, 0.8);
            transition: all 0.3s ease;
        }

        #lightbox-close span:nth-child(1) {
            transform: translateY(8px) rotate(45deg);
        }

        #lightbox-close span:nth-child(2) {
            opacity: 0;
        }

        #lightbox-close span:nth-child(3) {
            transform: translateY(-8px) rotate(-45deg);
        }

        #lightbox-close.visible {
            top: 20px;
            pointer-events: all;
        }

        #lightbox-close:hover {
            background: rgba(50, 150, 100, 0.2);
            border-color: rgba(50, 150, 100, 0.6);
        }

        #lightbox-close:hover span {
            background: rgba(50, 150, 100, 1);
        }

        /* === RESPONSIVE === */
        @media (max-width: 768px) {
            .document {
                width: 220px;
                height: 160px;
                padding: 15px;
            }

            .document.photo-style {
                border: none;
            }

            .doc-title {
                font-size: 14px;
            }

            /* mobile: show hamburger, convert filing area to offcanvas */
            #hamburger-btn {
                display: flex;
            }

            #menu-backdrop {
                display: block;
            }

            #wastebin {
                display: flex;
            }

            #filing-area {
                left: calc(-1 * var(--menu-width, 260px)) !important;
                transform: none !important;
                top: 0 !important;
                bottom: 0 !important;
                flex-direction: column;
                width: var(--menu-width, 260px);
                gap: 15px;
                transition: left 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                z-index: 1001 !important;
            }

            #filing-area.visible {
                left: 0 !important;
            }

            #menu-arrow {
                display: none;
            }

            .folder-stack {
                width: 100%;
                height: auto;
                font-size: 11px;
                padding: 0;
            }

            #filter-hint {
                display: none;
            }

            #back-link {
                display: none;
            }

            #cleanup-btn {
                display: none;
            }

            /* mobile lightbox - vertical scroll */
            #lightbox-gallery {
                flex-direction: column;
                justify-content: flex-start;
                overflow-y: auto;
                overflow-x: hidden;
                padding: 80px 20px 20px 20px;
                gap: 20px;
                top: 0;
                transform: none;
                height: 100%;
            }

            #lightbox-gallery.visible {
                pointer-events: auto;
            }

            .lightbox-image {
                max-width: 100%;
                width: auto;
                max-height: none;
                height: auto;
                cursor: default;
            }

            /* disable hover/focus transforms on mobile - keep static size */
            .lightbox-image:hover,
            .lightbox-image.focused {
                transform: none;
                box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6);
            }

            /* hide tip on mobile */
            #lightbox-tip {
                display: none;
            }

            /* hide hamburger, wastebin, and clear all when lightbox active */
            #lightbox-overlay.visible ~ #hamburger-btn,
            body:has(#lightbox-overlay.visible) #hamburger-btn,
            body:has(#lightbox-overlay.visible) #wastebin,
            body:has(#lightbox-overlay.visible) #clear-all-btn {
                display: none;
            }
        }
    </style>
</head>

<body>
    <!-- film grain overlay -->
    <div id="grain-overlay"></div>

    <!-- desk lamp light cone -->
    <div id="desk-light"></div>

    <!-- mobile hamburger menu -->
    <button id="hamburger-btn" aria-label="Toggle menu">
        <span></span>
        <span></span>
        <span></span>
    </button>

    <!-- mobile menu backdrop -->
    <div id="menu-backdrop"></div>

    <!-- mobile wastebin -->
    <div id="wastebin">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="3 6 5 6 21 6"></polyline>
            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
        </svg>
        <span>drop to remove</span>
    </div>

    <!-- clear all button -->
    <button id="clear-all-btn">clear all</button>

    <!-- filing system (drop zones) - outside desk-container for proper z-index stacking -->
    <div id="filing-area">
        <div class="folder-stack" data-category="saas">
            <div class="folder-header">
                <span>SAAS</span>
                <span class="file-count">0</span>
            </div>
            <div class="file-list"></div>
        </div>
        <div class="folder-stack" data-category="ecommerce">
            <div class="folder-header">
                <span>ECOMMERCE</span>
                <span class="file-count">0</span>
            </div>
            <div class="file-list"></div>
        </div>
        <div class="folder-stack" data-category="design">
            <div class="folder-header">
                <span>DESIGN</span>
                <span class="file-count">0</span>
            </div>
            <div class="file-list"></div>
        </div>
        <div class="filing-footer">
            <a href="/">← back • esc to leave</a>
        </div>
    </div>

    <!-- desktop menu arrow hint -->
    <div id="menu-arrow">
        <svg viewBox="0 0 24 24"><polyline points="9 18 15 12 9 6"></polyline></svg>
        <span>projects</span>
    </div>

    <!-- desk surface -->
    <div id="desk-container">
        <!-- draggable documents container -->
        <div id="documents-area"></div>
    </div>

    <!-- ui overlay -->
    <div id="ui-overlay">
        <div id="filter-hint">click to spill • double-click to open • drag anywhere</div>
        <div id="back-link"><a href="/">← back • esc to leave</a></div>
        <button id="cleanup-btn">clean up desk</button>
    </div>

    <!-- lightbox overlay -->
    <div id="lightbox-overlay"></div>

    <!-- lightbox gallery -->
    <div id="lightbox-gallery"></div>

    <!-- lightbox close button -->
    <button id="lightbox-close" aria-label="Close gallery">
        <span></span>
        <span></span>
        <span></span>
    </button>

    <!-- lightbox tip -->
    <div id="lightbox-tip">use arrow keys to navigate • click to focus</div>

    <!-- gsap cdn -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/Draggable.min.js"></script>

    <script>
        // register gsap plugin
        gsap.registerPlugin(Draggable);

        // placeholders (used if no real images found in manifest)
        const PLACEHOLDER_BASE = 'https://picsum.photos/seed/';
        const PLACEHOLDER_SIZE = '/400/300';

        function getPlaceholder(seed) {
            return PLACEHOLDER_BASE + seed + PLACEHOLDER_SIZE;
        }

        // work data (14 items from main index.html)
        // images will be loaded from manifest if available, otherwise use placeholders
        let WORK_ITEMS = [
            {
                title: 'Reveo', url: 'https://reveo.com', category: 'saas', type: 'folder', year: '2025',
                images: ['https://picsum.photos/seed/reveo1/400/300', 'https://picsum.photos/seed/reveo2/400/300', 'https://picsum.photos/seed/reveo3/400/300']
            },
            {
                title: 'Snowie', url: 'https://zakknowlton.com/snowie', category: 'ecommerce', type: 'folder', year: '2024',
                images: ['https://picsum.photos/seed/snowie1/400/300', 'https://picsum.photos/seed/snowie2/400/300', 'https://picsum.photos/seed/snowie3/400/300', 'https://picsum.photos/seed/snowie4/400/300']
            },
            {
                title: 'Green Philosophy Co', url: 'https://zakknowlton.com/green-philosophy', category: 'ecommerce', type: 'folder', year: '2023',
                images: ['https://picsum.photos/seed/green1/400/300', 'https://picsum.photos/seed/green2/400/300', 'https://picsum.photos/seed/green3/400/300']
            },
            {
                title: 'Raveyard Sounds', url: 'https://zakknowlton.com/raveyard-sounds', category: 'ecommerce', type: 'folder', year: '2023',
                images: ['https://picsum.photos/seed/raveyard1/400/300', 'https://picsum.photos/seed/raveyard2/400/300', 'https://picsum.photos/seed/raveyard3/400/300', 'https://picsum.photos/seed/raveyard4/400/300']
            },
            {
                title: 'gothparade', url: 'https://zakknowlton.com/gothparade', category: 'design', type: 'photo', year: '2023',
                images: ['https://picsum.photos/seed/goth1/400/300', 'https://picsum.photos/seed/goth2/400/300', 'https://picsum.photos/seed/goth3/400/300', 'https://picsum.photos/seed/goth4/400/300']
            },
            {
                title: 'Shockwav Sound Co', url: 'https://zakknowlton.com/shockwav', category: 'ecommerce', type: 'folder', year: '2022',
                images: ['https://picsum.photos/seed/shockwav1/400/300', 'https://picsum.photos/seed/shockwav2/400/300', 'https://picsum.photos/seed/shockwav3/400/300']
            },
            {
                title: 'us2', url: 'https://zakknowlton.com/us2', category: 'design', type: 'photo', year: '2022',
                images: ['https://picsum.photos/seed/us2a/400/300', 'https://picsum.photos/seed/us2b/400/300', 'https://picsum.photos/seed/us2c/400/300', 'https://picsum.photos/seed/us2d/400/300']
            },
            {
                title: 'Rave Water', url: 'https://zakknowlton.com/rave-water', category: 'design', type: 'photo', year: '2022',
                images: ['https://picsum.photos/seed/ravewater1/400/300', 'https://picsum.photos/seed/ravewater2/400/300', 'https://picsum.photos/seed/ravewater3/400/300']
            },
            {
                title: 'Beat Secrets', url: 'https://zakknowlton.com/beat-secrets', category: 'design', type: 'photo', year: '2021',
                images: ['https://picsum.photos/seed/beat1/400/300', 'https://picsum.photos/seed/beat2/400/300', 'https://picsum.photos/seed/beat3/400/300']
            },
            {
                title: 'Glass Heart', url: 'https://zakknowlton.com/glass-heart', category: 'design', type: 'photo', year: '2021',
                images: ['https://picsum.photos/seed/glass1/400/300', 'https://picsum.photos/seed/glass2/400/300', 'https://picsum.photos/seed/glass3/400/300', 'https://picsum.photos/seed/glass4/400/300']
            },
            {
                title: 'Polar Culture', url: 'https://zakknowlton.com/polar-culture', category: 'design', type: 'photo', year: '2021',
                images: ['https://picsum.photos/seed/polar1/400/300', 'https://picsum.photos/seed/polar2/400/300', 'https://picsum.photos/seed/polar3/400/300']
            },
            {
                title: 'School of Bass', url: 'https://zakknowlton.com/school-of-bass', category: 'design', type: 'photo', year: '2021',
                images: ['https://picsum.photos/seed/bass1/400/300', 'https://picsum.photos/seed/bass2/400/300', 'https://picsum.photos/seed/bass3/400/300']
            },
            {
                title: 'Crywolf', url: 'https://zakknowlton.com/crywolf', category: 'design', type: 'photo', year: '2020',
                images: ['https://picsum.photos/seed/crywolf1/400/300', 'https://picsum.photos/seed/crywolf2/400/300', 'https://picsum.photos/seed/crywolf3/400/300', 'https://picsum.photos/seed/crywolf4/400/300']
            }
        ];

        // load manifest and replace placeholder images with real ones
        async function loadImageManifest() {
            try {
                const response = await fetch('./assets/file-assets-manifest.json');
                if (!response.ok) throw new Error('Manifest not found');

                const manifest = await response.json();

                // update each work item with real images if available
                WORK_ITEMS.forEach(item => {
                    if (manifest[item.title] && manifest[item.title].length > 0) {
                        // replace placeholders with real images
                        item.images = manifest[item.title];
                        console.log(`✓ Loaded ${item.images.length} real image(s) for ${item.title}`);
                    } else {
                        console.log(`  Using placeholders for ${item.title}`);
                    }
                });

            } catch (error) {
                console.log('No manifest found, using placeholder images');
            }
        }

        // state management
        const state = {
            draggables: [],
            currentZIndex: 10,
            selectedDoc: null,
            isMobile: window.innerWidth <= 768,
            spilledFolders: new Set(), // track which folders have spilled
            spilledImages: {}, // map folder index to array of spilled image elements
            heldStack: [], // items collected via shake
            shakeContext: {
                history: [],
                lastX: 0,
                direction: 0, // 1 for right, -1 for left
                reversals: 0,
                lastReversalTime: 0
            },
            isHoveringParent: false, // tracks if currently hovering valid parent folder
            hoveredParentId: null, // tracks which folder is being hovered
            galleryActive: false, // tracks if gallery is open
            galleryImages: null, // stores original images while gallery is open
            isDragging: false, // tracks if currently dragging a document
            heldImageStack: [], // items collected via shake for images
            imageShakeContext: {
                lastX: 0,
                direction: 0,
                reversals: 0,
                lastReversalTime: 0
            },
            isHoveringParentDoc: false, // tracks if image is hovering over its parent document
            hoveredParentDoc: null, // the parent document being hovered
            preloadedImages: {}, // cache of preloaded images
            currentGalleryIndex: 0, // current focused image in gallery
            gallerySourceDoc: null, // document that opened the gallery
            galleryKeyHandler: null, // keyboard handler for gallery
            hoverCollectTarget: null, // doc being hovered over for collection
            hoverCollectStart: null // timestamp when hover started
        };

        // preload images for a document
        function preloadImages(images) {
            images.forEach(src => {
                if (!state.preloadedImages[src]) {
                    const img = new Image();
                    img.src = src;
                    state.preloadedImages[src] = img;
                }
            });
        }

        // add peek effect to document
        function addPeekEffect(doc) {
            let peekImages = [];

            doc.addEventListener('mouseenter', () => {
                // Don't show peek if already spilled, dragging, document not in DOM, or being deleted
                if (!doc.parentNode || state.isDragging || doc.dataset.beingDeleted === 'true') return;

                const folderIndex = doc.dataset.index;
                if (state.spilledFolders.has(folderIndex)) return;

                const images = JSON.parse(doc.dataset.images);
                if (!images || images.length === 0) return;

                // Tilt the document slightly
                const tiltAngle = (Math.random() - 0.5) * 8; // ±4 degrees
                gsap.to(doc, {
                    rotation: tiltAngle,
                    scale: 1.02,
                    duration: 0.3,
                    ease: 'power2.out'
                });

                // Get document position
                const docRect = doc.getBoundingClientRect();
                const containerRect = document.getElementById('desk-container').getBoundingClientRect();

                // Show up to 3 peek images at the edges
                const numPeeks = Math.min(3, images.length);
                const peekPositions = [
                    { x: -30, y: -20, rotation: -8 },  // top-left
                    { x: 20, y: -25, rotation: 5 },    // top-right
                    { x: -20, y: 15, rotation: -3 }    // bottom-left
                ];

                for (let i = 0; i < numPeeks; i++) {
                    const peekImg = document.createElement('img');
                    peekImg.className = 'peek-image';
                    peekImg.src = images[i];
                    peekImg.loading = 'eager';
                    peekImg.dataset.parent = folderIndex; // track parent doc

                    const baseX = docRect.left - containerRect.left;
                    const baseY = docRect.top - containerRect.top;
                    const pos = peekPositions[i];

                    gsap.set(peekImg, {
                        x: baseX + pos.x,
                        y: baseY + pos.y,
                        rotation: pos.rotation,
                        scale: 0.5,
                        opacity: 0,
                        zIndex: parseInt(gsap.getProperty(doc, 'zIndex')) - 1
                    });

                    document.getElementById('documents-area').appendChild(peekImg);
                    peekImages.push(peekImg);

                    // Animate in
                    gsap.to(peekImg, {
                        scale: 1,
                        opacity: 0.9,
                        duration: 0.3,
                        delay: i * 0.05,
                        ease: 'back.out(1.5)'
                    });
                }
            });

            doc.addEventListener('mouseleave', () => {
                // don't animate if we're dragging (onPress already cleaned up)
                if (state.isDragging) {
                    peekImages = [];
                    return;
                }

                // Reset document
                gsap.to(doc, {
                    rotation: 0,
                    scale: 1,
                    duration: 0.3,
                    ease: 'power2.out'
                });

                // Remove peek images - only if they're still in the DOM
                peekImages.forEach((img, i) => {
                    if (img.parentNode) {
                        gsap.killTweensOf(img);
                        gsap.to(img, {
                            scale: 0.5,
                            opacity: 0,
                            duration: 0.2,
                            delay: i * 0.02,
                            ease: 'power2.in',
                            onComplete: () => img.remove()
                        });
                    }
                });
                peekImages = [];
            });
        }

        // mobile menu functions
        function setupMobileMenu() {
            if (!state.isMobile) return;

            const hamburgerBtn = document.getElementById('hamburger-btn');
            const menuBackdrop = document.getElementById('menu-backdrop');
            const filingArea = document.getElementById('filing-area');

            // toggle menu
            function toggleMenu(show) {
                if (show) {
                    hamburgerBtn.classList.add('active');
                    menuBackdrop.classList.add('visible');
                    filingArea.classList.add('visible');
                } else {
                    hamburgerBtn.classList.remove('active');
                    menuBackdrop.classList.remove('visible');
                    filingArea.classList.remove('visible');
                }
            }

            // Store in state for external access
            state.toggleMobileMenu = toggleMenu;

            // hamburger click
            hamburgerBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const isOpen = filingArea.classList.contains('visible');
                toggleMenu(!isOpen);
            });

            // backdrop click to close (only if no docs on desk)
            menuBackdrop.addEventListener('click', () => {
                const docsOnDesk = document.querySelectorAll('.document').length;
                if (docsOnDesk === 0) {
                    toggleMenu(false);
                }
            });

            // also close menu when tapping anywhere outside filing area (only if no docs)
            document.addEventListener('click', (e) => {
                const isClickInsideMenu = filingArea.contains(e.target);
                const isClickOnHamburger = hamburgerBtn.contains(e.target);
                const isMenuOpen = filingArea.classList.contains('visible');
                const docsOnDesk = document.querySelectorAll('.document').length;

                if (isMenuOpen && !isClickInsideMenu && !isClickOnHamburger && docsOnDesk === 0) {
                    toggleMenu(false);
                }
            });

            // update mobile menu visibility based on docs on desk
            function updateMobileMenuVisibility() {
                const docsOnDesk = document.querySelectorAll('.document').length;
                // keep open if docs on desk, close if none
                if (docsOnDesk > 0) {
                    toggleMenu(true);
                } else {
                    toggleMenu(false);
                }
            }
            state.updateMobileMenu = updateMobileMenuVisibility;
        }

        // desktop offcanvas menu - stays open when docs on desk
        function setupDesktopMenu() {
            if (state.isMobile) return;

            const filingArea = document.getElementById('filing-area');
            const menuArrow = document.getElementById('menu-arrow');

            // update menu visibility based on docs on desk
            function updateMenuVisibility() {
                if (state.galleryActive) {
                    filingArea.classList.remove('visible');
                    return;
                }
                const docsOnDesk = document.querySelectorAll('.document').length;
                if (docsOnDesk > 0) {
                    filingArea.classList.add('visible');
                    menuArrow.classList.add('hidden');
                } else {
                    filingArea.classList.remove('visible');
                    menuArrow.classList.remove('hidden');
                }
            }

            // expose globally so other functions can call it
            state.updateDesktopMenu = updateMenuVisibility;

            // edge detection for when no docs on desk
            const triggerWidth = 60;
            const triggerZone = document.createElement('div');
            triggerZone.id = 'menu-trigger-zone';
            triggerZone.style.cssText = `
                position: fixed;
                left: 0;
                top: 0;
                width: ${triggerWidth}px;
                height: 100%;
                z-index: 999;
            `;
            document.body.appendChild(triggerZone);

            // edge triggers menu open (for discovering when desk is empty)
            triggerZone.addEventListener('mouseenter', () => {
                if (state.galleryActive) return;
                const docsOnDesk = document.querySelectorAll('.document').length;
                if (docsOnDesk === 0) {
                    filingArea.classList.add('visible');
                }
            });

            // close only when mouse leaves AND no docs on desk
            filingArea.addEventListener('mouseleave', () => {
                const docsOnDesk = document.querySelectorAll('.document').length;
                if (docsOnDesk === 0) {
                    filingArea.classList.remove('visible');
                }
                // if docs on desk, menu stays open NO MATTER WHAT
            });

            // animate arrow on page load (hidden once docs appear)
            setTimeout(() => {
                menuArrow.classList.remove('hidden');
            }, 500);
        }

        // mobile single-tap to open lightbox
        function setupMobileLightboxTap() {
            if (!state.isMobile) return;

            // track touch start/end for tap detection
            let touchStartTime = 0;
            let touchStartX = 0;
            let touchStartY = 0;

            document.addEventListener('touchstart', (e) => {
                const doc = e.target.closest('.document');
                if (!doc) return;

                touchStartTime = Date.now();
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            }, { passive: true });

            document.addEventListener('touchend', (e) => {
                const doc = e.target.closest('.document');
                if (!doc) return;

                const touchDuration = Date.now() - touchStartTime;
                const touchEndX = e.changedTouches[0].clientX;
                const touchEndY = e.changedTouches[0].clientY;
                const distance = Math.sqrt(
                    Math.pow(touchEndX - touchStartX, 2) +
                    Math.pow(touchEndY - touchStartY, 2)
                );

                // tap detected: quick touch with minimal movement
                if (touchDuration < 300 && distance < 10) {
                    e.preventDefault();
                    openGalleryFromDocument(doc);
                }
            });
        }

        // wastebin drag detection (works for both mobile and desktop)
        function setupWastebin() {
            const wastebin = document.getElementById('wastebin');

            // show wastebin when dragging starts
            function showWastebin() {
                wastebin.classList.add('visible');
            }

            // hide wastebin when dragging ends
            function hideWastebin() {
                wastebin.classList.remove('visible', 'active');
            }

            // check if drag position is over wastebin
            function updateWastebinState(x, y) {
                // always get fresh bounds to account for animation
                const bounds = wastebin.getBoundingClientRect();

                const isOver = x >= bounds.left &&
                    x <= bounds.right &&
                    y >= bounds.top &&
                    y <= bounds.bottom;

                if (isOver) {
                    wastebin.classList.add('active');
                } else {
                    wastebin.classList.remove('active');
                }

                return isOver;
            }

            // return functions for drag lifecycle
            return { showWastebin, hideWastebin, updateWastebinState };
        }

        // clear all button setup (desktop only)
        function setupClearAllButton() {
            const clearAllBtn = document.getElementById('clear-all-btn');
            const wastebin = document.getElementById('wastebin');
            let hoverTimeout = null;

            // show button when hovering over wastebin area (not while dragging)
            document.addEventListener('mousemove', (e) => {
                // don't show if dragging, no documents, or wastebin is visible
                if (state.isDragging || wastebin.classList.contains('visible')) {
                    clearAllBtn.classList.remove('visible');
                    return;
                }

                const docs = document.querySelectorAll('.document');
                if (docs.length === 0) {
                    clearAllBtn.classList.remove('visible');
                    return;
                }

                // check if mouse is in bottom center area where wastebin would appear
                const windowHeight = window.innerHeight;
                const windowWidth = window.innerWidth;
                const isInBottomCenter = e.clientY > windowHeight - 150 &&
                    e.clientX > (windowWidth / 2) - 100 &&
                    e.clientX < (windowWidth / 2) + 100;

                if (isInBottomCenter) {
                    clearTimeout(hoverTimeout);
                    clearAllBtn.classList.add('visible');
                } else {
                    // delay hiding slightly for smoother UX
                    hoverTimeout = setTimeout(() => {
                        clearAllBtn.classList.remove('visible');
                    }, 200);
                }
            });

            // handle click
            clearAllBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                clearAllDocuments();
                clearAllBtn.classList.remove('visible');
            });
        }

        // clear all documents from desk and return to menu
        function clearAllDocuments() {
            const docs = Array.from(document.querySelectorAll('.document'));

            // instantly remove all peek images
            const peekImages = document.querySelectorAll('.peek-image');
            peekImages.forEach(img => {
                gsap.killTweensOf(img);
                img.remove();
            });

            docs.forEach((doc, index) => {
                setTimeout(() => {
                    removeDocumentToMenu(doc);
                }, index * 50); // stagger by 50ms each
            });
        }

        // initialization
        async function init() {
            // load real images from manifest first
            await loadImageManifest();

            setupFilingAreaInteractions();
            addKeyboardShortcuts();

            // wastebin setup (both mobile and desktop)
            state.wastebin = setupWastebin();

            // safety check to ensure wastebin is only visible when actually dragging
            setInterval(() => {
                const wastebin = document.getElementById('wastebin');
                if (!state.isDragging && wastebin.classList.contains('visible')) {
                    wastebin.classList.remove('visible', 'active');
                }
            }, 100);

            // clear all button setup (desktop only)
            if (!state.isMobile) {
                setupClearAllButton();
            }

            // mobile-specific setup
            if (state.isMobile) {
                setupMobileMenu();
                setupMobileLightboxTap();
            } else {
                setupDesktopMenu();
            }

            // cleanup button
            document.getElementById('cleanup-btn').addEventListener('click', cleanupAllImages);

            // lightbox dismissal
            document.getElementById('lightbox-overlay').addEventListener('click', exitLightbox);
            document.getElementById('lightbox-close').addEventListener('click', exitLightbox);

            // click on desk background to cleanup
            document.getElementById('desk-container').addEventListener('click', (e) => {
                // only if clicking directly on the desk or background elements
                if (e.target.id === 'desk-container' ||
                    e.target.id === 'desk-light' ||
                    e.target.id === 'grain-overlay' ||
                    e.target.id === 'documents-area') {
                    gatherAllContents();
                }
            });
        }

        // gather all spilled contents back to their documents (without removing documents)
        function gatherAllContents() {
            const docs = document.querySelectorAll('.document');
            docs.forEach(doc => {
                gatherImagesToFolder(doc);
            });
        }

        // helper to manage filing area visibility based on all states
        function updateFilingAreaVisibility(mouseX = null) {
            if (state.isMobile) return;

            const filingArea = document.getElementById('filing-area');

            // NEVER open during gallery
            if (state.galleryActive) {
                filingArea.classList.remove('visible');
                return;
            }

            const distanceFromLeft = mouseX !== null ? mouseX : -1;

            // check if currently dragging an unopened file (can be filed away)
            const draggingUnopenedFile = state.isDragging && state.selectedDoc &&
                !state.spilledFolders.has(state.selectedDoc.dataset.index);

            // check if holding stack of unopened files
            const holdingUnopenedStack = state.heldStack.length > 0 &&
                state.heldStack.every(item => !state.spilledFolders.has(item.el.dataset.index));

            // conditions to OPEN (only for filing actions):
            // 1. mouse within 200px of left edge AND NOT dragging anything (empty cursor)
            // 2. dragging an unopened file (can be returned to filing)
            // 3. holding stack of unopened files (can be returned to filing)
            const shouldOpen = (
                (distanceFromLeft < 200 && !state.isDragging) ||
                draggingUnopenedFile ||
                holdingUnopenedStack
            );

            // conditions to CLOSE:
            // mouse far from left AND not in any filing action
            const shouldClose = (
                distanceFromLeft > 350 &&
                !draggingUnopenedFile &&
                !holdingUnopenedStack
            );

            if (shouldOpen) {
                filingArea.classList.add('visible');
            } else if (shouldClose) {
                if (filingArea.classList.contains('visible')) {
                    filingArea.classList.remove('visible');
                    resetFolderStates();
                }
            }
        }

        // filing area mouse interactions
        function setupFilingAreaInteractions() {
            const filingArea = document.getElementById('filing-area');
            const folders = document.querySelectorAll('.folder-stack');

            // mouse proximity detection
            document.addEventListener('mousemove', (e) => {
                updateFilingAreaVisibility(e.clientX);
            });

            // click folder header to toggle expand/collapse
            folders.forEach(folder => {
                const header = folder.querySelector('.folder-header');
                header.addEventListener('click', () => {
                    // close other folders
                    folders.forEach(f => {
                        if (f !== folder) {
                            f.classList.remove('expanded');
                        }
                    });

                    folder.classList.toggle('expanded');
                });
            });

            // populate file lists
            populateFileLists();
        }

        // insert list item sorted by year (desc) then alphabetically within year
        function insertSortedAlpha(fileList, listItem) {
            const year = parseInt(listItem.dataset.year) || 0;
            const title = (listItem.dataset.title || '').toLowerCase();
            const existingItems = fileList.querySelectorAll('.file-list-item');

            let insertBefore = null;
            for (const item of existingItems) {
                const itemYear = parseInt(item.dataset.year) || 0;
                const itemTitle = (item.dataset.title || '').toLowerCase();

                // newer year comes first
                if (year > itemYear) {
                    insertBefore = item;
                    break;
                }
                // same year - sort alphabetically
                if (year === itemYear && title < itemTitle) {
                    insertBefore = item;
                    break;
                }
            }

            if (insertBefore) {
                fileList.insertBefore(listItem, insertBefore);
            } else {
                fileList.appendChild(listItem);
            }
        }

        // populate file lists in buckets
        function populateFileLists() {
            // sort by year (desc) then alphabetically within year
            const sortedItems = [...WORK_ITEMS].sort((a, b) => {
                const yearDiff = (b.year || 0) - (a.year || 0);
                if (yearDiff !== 0) return yearDiff;
                return (a.title || '').localeCompare(b.title || '');
            });

            sortedItems.forEach(item => {
                const folder = document.querySelector(`.folder-stack[data-category="${item.category}"]`);
                const fileList = folder.querySelector('.file-list');

                const listItem = document.createElement('div');
                listItem.className = 'file-list-item';
                listItem.dataset.index = WORK_ITEMS.indexOf(item);
                listItem.dataset.category = item.category;
                listItem.dataset.url = item.url;
                listItem.dataset.images = JSON.stringify(item.images);
                listItem.dataset.title = item.title;
                listItem.dataset.year = item.year;

                listItem.innerHTML = `
                    <div class="file-item-title">${item.title}</div>
                    <div class="file-item-year">${item.year}</div>
                `;

                // make list item draggable - creates document on drag (desktop) or click (mobile)
                const eventType = state.isMobile ? 'click' : 'mousedown';
                listItem.addEventListener(eventType, (e) => {
                    handleListItemInteraction(listItem, e);
                });

                fileList.appendChild(listItem);
            });

            updateFileCounts();
        }

        function calculateOptimalMenuWidth() {
            const measureEl = document.createElement('div');
            measureEl.style.cssText = 'position:absolute; visibility:hidden; white-space:nowrap; font-family:"Courier Prime",monospace; font-size:11px; padding:10px 15px;';
            document.body.appendChild(measureEl);

            let maxWidth = 0;
            const folderHeaders = ['SAAS', 'ECOMMERCE', 'DESIGN'];

            folderHeaders.forEach(header => {
                measureEl.textContent = header;
                maxWidth = Math.max(maxWidth, measureEl.scrollWidth);
            });

            WORK_ITEMS.forEach(item => {
                measureEl.innerHTML = `<div>${item.title}</div><div>${item.year}</div>`;
                maxWidth = Math.max(maxWidth, measureEl.scrollWidth);
            });

            measureEl.remove();
            return Math.max(300, Math.min(450, maxWidth + 60));
        }

        // setup draggable for document element
        function setupDocumentDraggable(doc) {
            let isOverWastebin = false;

            // on mobile, show wastebin on touchstart (before drag)
            if (state.isMobile && state.wastebin) {
                doc.addEventListener('touchstart', () => {
                    state.wastebin.showWastebin();
                }, { passive: true });
            }

            const draggable = Draggable.create(doc, {
                type: 'x,y',
                cursor: 'pointer',
                bounds: '#desk-container',
                inertia: state.isMobile ? false : true,
                edgeResistance: 0.8,

                onPress: function () {
                    state.isDragging = true;
                    state.currentZIndex++;

                    // show wastebin when dragging
                    if (state.wastebin) {
                        state.wastebin.showWastebin();
                    }

                    // immediately kill and remove ALL peek images (no animation to avoid race conditions)
                    const peekImages = document.querySelectorAll('.peek-image');
                    peekImages.forEach(img => {
                        gsap.killTweensOf(img);
                        img.remove();
                    });

                    // Reset document rotation from hover
                    gsap.to(this.target, {
                        zIndex: state.currentZIndex,
                        scale: 1.05,
                        rotation: 0,
                        boxShadow: '0 20px 40px rgba(0,0,0,0.7)',
                        duration: 0.1
                    });

                    // Reset shake context
                    state.shakeContext.history = [];
                    state.shakeContext.lastX = this.x;
                    state.shakeContext.reversals = 0;
                    state.shakeContext.direction = 0;
                },

                onDrag: function () {
                    // Check for shake gesture
                    checkShake(this);

                    // Check for hover-to-collect
                    checkHoverCollect(this);

                    // Move collected stack if any
                    updateHeldStackPosition(this.target);

                    // Move spilled images with document
                    updateSpilledImagesPosition(this.target);

                    // Check wastebin overlap
                    if (state.wastebin) {
                        const wasOverBin = isOverWastebin;
                        isOverWastebin = state.wastebin.updateWastebinState(this.pointerX, this.pointerY);

                        // scale document down when over wastebin
                        if (isOverWastebin && !wasOverBin) {
                            gsap.to(this.target, {
                                scale: 0.8,
                                duration: 0.2,
                                ease: 'power2.out'
                            });
                        } else if (!isOverWastebin && wasOverBin) {
                            gsap.to(this.target, {
                                scale: 1.05,
                                duration: 0.2,
                                ease: 'power2.out'
                            });
                        }
                    }

                    // Check drop zone overlap
                    checkDropZoneOverlap(this.target);
                },

                onDragEnd: function () {
                    // hide wastebin
                    if (state.wastebin) {
                        state.wastebin.hideWastebin();
                    }

                    // reset hover collect state
                    if (state.hoverCollectTarget) {
                        gsap.to(state.hoverCollectTarget, { scale: 1, duration: 0.2 });
                    }
                    state.hoverCollectTarget = null;
                    state.hoverCollectStart = null;

                    // check if dropped on wastebin - do this BEFORE setting isDragging = false
                    if (isOverWastebin) {
                        state.isDragging = false;
                        // delete entire stack if holding one, otherwise just the single doc
                        if (state.heldStack.length > 0) {
                            deleteStackToMenu(this.target);
                        } else {
                            removeDocumentToMenu(this.target);
                        }
                        isOverWastebin = false;
                        return;
                    }

                    // not deleting, so now safe to mark as not dragging
                    state.isDragging = false;

                    // Update filing area immediately (no longer dragging)
                    updateFilingAreaVisibility();

                    gsap.to(this.target, {
                        scale: 1,
                        boxShadow: '0 8px 16px rgba(0,0,0,0.4)',
                        duration: 0.15
                    });

                    // Check if mouse is still over file - manually trigger hover state
                    setTimeout(() => {
                        const rect = this.target.getBoundingClientRect();
                        const mouseX = this.pointerX;
                        const mouseY = this.pointerY;

                        if (mouseX >= rect.left && mouseX <= rect.right &&
                            mouseY >= rect.top && mouseY <= rect.bottom) {
                            // Trigger mouseenter event to show peek
                            this.target.dispatchEvent(new MouseEvent('mouseenter', {
                                bubbles: true,
                                cancelable: true
                            }));
                        }
                    }, 50);

                    // Check if dropped on parent
                    const droppedOnParent = handleDropZoneSnap(this.target);

                    // Release stack (scatter or return to list)
                    releaseStack(droppedOnParent);
                },

                onClick: function () {
                    // Open gallery directly on click (desktop only, mobile uses tap detection)
                    if (!state.isMobile) {
                        const images = JSON.parse(this.target.dataset.images);
                        if (images && images.length > 0) {
                            openGalleryFromDocument(this.target);
                        }
                    }
                }
            })[0];

            return draggable;
        }

        // remove document and return it to menu (mobile wastebin)
        function removeDocumentToMenu(doc) {
            const index = doc.dataset.index;
            const item = WORK_ITEMS[index];
            const hasImages = item.images && item.images.length > 0;

            // CRITICAL: mark document as being deleted to prevent peek images from being created
            doc.dataset.beingDeleted = 'true';

            // instantly remove all peek images, especially those belonging to this doc
            const peekImages = document.querySelectorAll('.peek-image');
            peekImages.forEach(img => {
                gsap.killTweensOf(img);
                img.remove();
            });

            // double check - remove any peek images specifically for this doc
            const parentPeeks = document.querySelectorAll(`.peek-image[data-parent="${index}"]`);
            parentPeeks.forEach(img => {
                gsap.killTweensOf(img);
                if (img.parentNode) img.remove();
            });

            // instantly remove any spilled images (no animation)
            const folderIndex = doc.dataset.index;
            if (state.spilledFolders.has(folderIndex)) {
                const spilledImgs = state.spilledImages[folderIndex];
                if (spilledImgs) {
                    spilledImgs.forEach(img => {
                        gsap.killTweensOf(img);
                        img.remove();
                    });
                    delete state.spilledImages[folderIndex];
                    state.spilledFolders.delete(folderIndex);
                }
            }

            // kill all existing animations on document before final animation
            gsap.killTweensOf(doc);

            // animate out - quick fade and shrink
            gsap.to(doc, {
                opacity: 0,
                scale: 0.8,
                duration: 0.08,
                ease: 'power2.in',
                onComplete: () => {
                    // final cleanup - kill any remaining animations and remove document
                    gsap.killTweensOf(doc);

                    // CRITICAL: one more sweep to remove any peek images that snuck in during animation
                    const finalPeekCheck = document.querySelectorAll(`.peek-image[data-parent="${index}"]`);
                    finalPeekCheck.forEach(img => {
                        gsap.killTweensOf(img);
                        img.remove();
                    });

                    doc.remove();

                    // add back to file list
                    const folder = document.querySelector(`.folder-stack[data-category="${item.category}"]`);
                    const fileList = folder.querySelector('.file-list');

                    const listItem = document.createElement('div');
                    listItem.className = 'file-list-item';
                    listItem.dataset.category = item.category;
                    listItem.dataset.title = item.title;
                    listItem.dataset.url = item.url;
                    listItem.dataset.year = item.year;
                    listItem.dataset.index = index;
                    listItem.dataset.images = JSON.stringify(item.images);

                    listItem.innerHTML = `
                        <div class="file-item-title">${item.title}</div>
                        <div class="file-item-year">${item.year}</div>
                    `;

                    // CRITICAL: re-attach event listener so item is interactive again
                    const eventType = state.isMobile ? 'click' : 'mousedown';
                    listItem.addEventListener(eventType, (e) => {
                        handleListItemInteraction(listItem, e);
                    });

                    insertSortedAlpha(fileList, listItem);
                    updateFileCounts();

                    // update menu visibility
                    if (state.updateDesktopMenu) state.updateDesktopMenu();
                    if (state.updateMobileMenu) state.updateMobileMenu();
                }
            });
        }

        // delete entire stack when dropped on wastebin
        function deleteStackToMenu(leaderDoc) {
            // delete all stack members with staggered animation
            const stackCopy = [...state.heldStack]; // copy before clearing
            state.heldStack = []; // clear immediately to prevent interference

            // delete siblings first with stagger
            stackCopy.forEach((item, idx) => {
                setTimeout(() => {
                    removeDocumentToMenu(item.el);
                }, idx * 50); // 50ms stagger
            });

            // delete leader last for visual clarity
            setTimeout(() => {
                removeDocumentToMenu(leaderDoc);
            }, stackCopy.length * 50);
        }

        // create draggable document from list item
        // create document at specific position (used by mobile tap-to-add)
        function createDocumentAtPosition(item, index, x, y) {
            const container = document.getElementById('documents-area');

            const doc = document.createElement('div');
            doc.className = `document ${item.type}-style`;
            doc.dataset.category = item.category;
            doc.dataset.url = item.url;
            doc.dataset.index = index;
            doc.dataset.images = JSON.stringify(item.images);

            // preload images immediately
            preloadImages(item.images);

            gsap.set(doc, {
                x: x,
                y: y,
                rotation: 0,
                scale: 0,
                zIndex: state.currentZIndex++
            });

            doc.innerHTML = `
                <div class="doc-content">
                    <h3 class="doc-title">${item.title}</h3>
                    <div class="doc-year">${item.year}</div>
                    <div class="category-tag ${item.category}">${item.category.toUpperCase()}</div>
                </div>
            `;

            container.appendChild(doc);

            // animate in
            gsap.to(doc, {
                scale: 1,
                duration: 0.3,
                ease: 'back.out(1.7)'
            });

            // setup draggable
            setupDocumentDraggable(doc);

            // update menu visibility
            if (state.updateDesktopMenu) state.updateDesktopMenu();
            if (state.updateMobileMenu) state.updateMobileMenu();

            return doc;
        }

        // handle click vs drag for list items
        function handleListItemInteraction(listItem, e) {
            // On mobile, use direct creation (bypass click/drag detection)
            if (state.isMobile) {
                e.preventDefault(); // prevent any drag behavior
                createDocumentFromListItem(listItem, e, false); // always spawn at center for mobile tap

                // Close the mobile menu after creating document
                if (state.toggleMobileMenu) {
                    state.toggleMobileMenu(false);
                }
                return;
            }

            // Desktop: detect click vs drag
            const startX = e.clientX;
            const startY = e.clientY;
            const dragThreshold = 5; // pixels
            let hasMoved = false;
            let handled = false;

            const onMouseMove = (moveEvent) => {
                const deltaX = Math.abs(moveEvent.clientX - startX);
                const deltaY = Math.abs(moveEvent.clientY - startY);

                if (deltaX > dragThreshold || deltaY > dragThreshold) {
                    hasMoved = true;
                    if (!handled) {
                        handled = true;
                        cleanup();
                        // Create at cursor and start drag
                        createDocumentFromListItem(listItem, e, true);
                    }
                }
            };

            const onMouseUp = (upEvent) => {
                if (!handled) {
                    handled = true;
                    cleanup();
                    if (!hasMoved) {
                        // Click - create at center
                        createDocumentFromListItem(listItem, upEvent, false);
                    }
                }
            };

            const cleanup = () => {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            };

            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        }

        function createDocumentFromListItem(listItem, e, isDrag = true) {
            const container = document.getElementById('documents-area');
            const containerRect = container.getBoundingClientRect();

            const doc = document.createElement('div');
            const item = WORK_ITEMS[listItem.dataset.index];
            doc.className = `document ${item.type}-style`;
            doc.dataset.category = listItem.dataset.category;
            doc.dataset.url = listItem.dataset.url;
            doc.dataset.index = listItem.dataset.index;
            doc.dataset.images = listItem.dataset.images;

            // preload images immediately
            preloadImages(JSON.parse(listItem.dataset.images));

            // determine spawn position based on interaction type
            let spawnX, spawnY;
            if (isDrag) {
                // spawn at cursor position when dragging
                const cursorX = e.clientX - containerRect.left;
                const cursorY = e.clientY - containerRect.top;
                spawnX = cursorX - 110; // cursor position minus half doc width (220/2)
                spawnY = cursorY - 80;  // cursor position minus half doc height (160/2)
            } else {
                // spawn in center when clicking
                const centerX = containerRect.width / 2;
                const centerY = containerRect.height / 2;
                const variationX = (Math.random() - 0.5) * 100; // ±50px variation
                const variationY = (Math.random() - 0.5) * 100;
                spawnX = centerX + variationX - 110; // center minus half doc width (220/2)
                spawnY = centerY + variationY - 80;  // center minus half doc height (160/2)
            }

            gsap.set(doc, {
                x: spawnX,
                y: spawnY,
                rotation: 0,
                scale: isDrag ? 1 : 0, // start small for click, full size for drag
                zIndex: state.currentZIndex++
            });

            doc.innerHTML = `
                <div class="doc-content">
                    <h3 class="doc-title">${listItem.dataset.title}</h3>
                    <div class="doc-year">${listItem.dataset.year}</div>
                    <div class="category-tag ${listItem.dataset.category}">${listItem.dataset.category.toUpperCase()}</div>
                </div>
            `;

            container.appendChild(doc);

            // setup draggable
            const draggable = setupDocumentDraggable(doc);

            if (isDrag) {
                // trigger drag immediately for drag interaction
                draggable.startDrag(e);
            } else {
                // animate in for click interaction
                gsap.to(doc, {
                    scale: 1,
                    duration: 0.3,
                    ease: 'back.out(1.7)'
                });
            }

            // add peek effect
            addPeekEffect(doc);

            // remove from list
            listItem.remove();
            updateFileCounts();
        }

        // generate document divs dynamically
        function generateDocuments() {
            const container = document.getElementById('documents-area');

            // get folder positions
            const folders = {
                saas: document.querySelector('.folder-stack[data-category="saas"]'),
                ecommerce: document.querySelector('.folder-stack[data-category="ecommerce"]'),
                design: document.querySelector('.folder-stack[data-category="design"]')
            };

            // track count per category
            const counts = { saas: 0, ecommerce: 0, design: 0 };

            WORK_ITEMS.forEach((item, index) => {
                const doc = document.createElement('div');
                doc.className = `document ${item.type}-style`;
                doc.dataset.category = item.category;
                doc.dataset.url = item.url;
                doc.dataset.index = index;

                // store images data
                doc.dataset.images = JSON.stringify(item.images);

                // position in category bucket (stacked)
                const folder = folders[item.category];
                const folderRect = folder.getBoundingClientRect();
                const containerRect = document.getElementById('desk-container').getBoundingClientRect();

                const stackOffset = counts[item.category] * 2;
                const baseX = folderRect.left - containerRect.left + 20;
                const baseY = folderRect.top - containerRect.top + 40;

                gsap.set(doc, {
                    x: baseX + stackOffset,
                    y: baseY + stackOffset,
                    rotation: 0,
                    scale: 0.6, // smaller in bucket
                    zIndex: 10 + index
                });

                counts[item.category]++;

                // content structure
                doc.innerHTML = `
                    <div class="doc-content">
                        <h3 class="doc-title">${item.title}</h3>
                        <div class="doc-year">${item.year}</div>
                        <div class="category-tag ${item.category}">${item.category.toUpperCase()}</div>
                    </div>
                `;

                container.appendChild(doc);
            });

            // update file counts
            updateFileCounts();
        }

        // update file count displays
        function updateFileCounts() {
            const counts = { saas: 0, ecommerce: 0, design: 0 };

            document.querySelectorAll('.file-list-item').forEach(item => {
                counts[item.dataset.category]++;
            });

            Object.keys(counts).forEach(category => {
                const folder = document.querySelector(`.folder-stack[data-category="${category}"]`);
                const countSpan = folder.querySelector('.file-count');
                countSpan.textContent = counts[category];
            });
        }

        // gsap draggable setup (legacy - now using setupDocumentDraggable)
        function setupDraggables() {
            const docs = document.querySelectorAll('.document');

            docs.forEach(doc => {
                const draggable = setupDocumentDraggable(doc);
                state.draggables.push(draggable);

                // add peek effect
                addPeekEffect(doc);
            });
        }

        // === SHAKE & STACK LOGIC ===

        function checkShake(draggable) {
            const currentX = draggable.x;
            const now = Date.now();
            const ctx = state.shakeContext;

            // Calculate delta and direction
            const delta = currentX - ctx.lastX;
            const direction = Math.sign(delta);

            // Only count significant moves
            if (Math.abs(delta) > 10) { // Reduced threshold for sensitivity
                if (direction !== ctx.direction && ctx.direction !== 0) {
                    // Direction reversal detected
                    if (now - ctx.lastReversalTime < 400) { // Increased window slightly
                        ctx.reversals++;
                    } else {
                        ctx.reversals = 1;
                    }
                    ctx.lastReversalTime = now;
                }
                ctx.direction = direction;
            }

            ctx.lastX = currentX;

            // Trigger shake if reversals threshold met
            // Reset reversals immediately to prevent multi-trigger
            if (ctx.reversals >= 3 && state.heldStack.length === 0) { // Reduced to 3
                collectSiblings(draggable.target);
                ctx.reversals = 0;
            }
        }

        function checkHoverCollect(draggable) {
            const draggedDoc = draggable.target;
            const category = draggedDoc.dataset.category;

            // get center of dragged doc
            const draggedRect = draggedDoc.getBoundingClientRect();
            const draggedCenterX = draggedRect.left + draggedRect.width / 2;
            const draggedCenterY = draggedRect.top + draggedRect.height / 2;

            // check all other docs on desk
            const allDocs = document.querySelectorAll('.document');
            let closestDoc = null;
            let closestDist = 100; // threshold distance in px

            allDocs.forEach(doc => {
                if (doc === draggedDoc) return;
                if (doc.dataset.category !== category) return;
                if (state.heldStack.some(item => item.el === doc)) return; // skip already collected

                const docRect = doc.getBoundingClientRect();
                const docCenterX = docRect.left + docRect.width / 2;
                const docCenterY = docRect.top + docRect.height / 2;

                const dist = Math.sqrt(
                    Math.pow(draggedCenterX - docCenterX, 2) +
                    Math.pow(draggedCenterY - docCenterY, 2)
                );

                if (dist < closestDist) {
                    closestDist = dist;
                    closestDoc = doc;
                }
            });

            // clear previous hover state
            if (state.hoverCollectTarget && state.hoverCollectTarget !== closestDoc) {
                gsap.to(state.hoverCollectTarget, {
                    scale: 1,
                    duration: 0.2
                });
            }

            // if hovering over valid target
            if (closestDoc) {
                // visual feedback - pulse the target
                if (state.hoverCollectTarget !== closestDoc) {
                    gsap.to(closestDoc, {
                        scale: 1.08,
                        duration: 0.2,
                        ease: 'power2.out'
                    });
                }
                state.hoverCollectTarget = closestDoc;

                // if held long enough, collect
                const now = Date.now();
                if (!state.hoverCollectStart) {
                    state.hoverCollectStart = now;
                } else if (now - state.hoverCollectStart > 150) {
                    // trigger collection of single hovered doc only
                    collectSingleDoc(draggedDoc, state.hoverCollectTarget);
                    state.hoverCollectTarget = null;
                    state.hoverCollectStart = null;
                }
            } else {
                state.hoverCollectTarget = null;
                state.hoverCollectStart = null;
            }
        }

        // collect single doc to stack (hover-to-collect)
        function collectSingleDoc(leaderDoc, targetDoc) {
            if (!targetDoc || targetDoc === leaderDoc) return;
            if (state.heldStack.some(item => item.el === targetDoc)) return;

            // gather spilled contents from target
            const targetIndex = targetDoc.dataset.index;
            if (state.spilledFolders.has(targetIndex)) {
                gatherImagesToFolder(targetDoc);
            }

            // disable dragging
            const dragInstance = Draggable.get(targetDoc);
            if (dragInstance) dragInstance.disable();

            // add to stack
            state.heldStack.push({
                el: targetDoc,
                offsetX: (Math.random() * 10 - 5),
                offsetY: (Math.random() * 10 - 5) + 5
            });

            // animate to leader
            gsap.to(targetDoc, {
                x: gsap.getProperty(leaderDoc, "x") + (Math.random() * 10 - 5),
                y: gsap.getProperty(leaderDoc, "y") + (Math.random() * 20 - 10) + 10,
                rotation: gsap.getProperty(leaderDoc, "rotation") + (Math.random() * 10 - 5),
                scale: 1,
                zIndex: state.currentZIndex - 1,
                duration: 0.4,
                ease: "back.out(1.2)"
            });

            // pulse leader
            gsap.fromTo(leaderDoc,
                { scale: 1.1 },
                { scale: 1.05, duration: 0.2, ease: "elastic.out(1, 0.3)" }
            );

            updateFilingAreaVisibility();
        }

        function collectSiblings(leaderDoc) {
            const category = leaderDoc.dataset.category;
            const allDocs = document.querySelectorAll('.document');

            // gather spilled contents from leader when stacking
            const leaderIndex = leaderDoc.dataset.index;
            if (state.spilledFolders.has(leaderIndex)) {
                gatherImagesToFolder(leaderDoc);
            }

            // Find valid siblings on the desk
            const siblings = Array.from(allDocs).filter(doc =>
                doc !== leaderDoc &&
                doc.dataset.category === category &&
                !state.heldStack.some(item => item.el === doc)
            );

            if (siblings.length === 0) return;

            // gather spilled contents from siblings too
            siblings.forEach(doc => {
                const siblingIndex = doc.dataset.index;
                if (state.spilledFolders.has(siblingIndex)) {
                    gatherImagesToFolder(doc);
                }
            });

            // Animate them to the leader
            siblings.forEach((doc, i) => {
                // Disable individual dragging for siblings
                const dragInstance = Draggable.get(doc);
                if (dragInstance) dragInstance.disable();

                // Add to stack
                state.heldStack.push({
                    el: doc,
                    offsetX: (Math.random() * 10 - 5), // Tighter offset
                    offsetY: (Math.random() * 10 - 5) + 5
                });

                // Animate to position
                gsap.to(doc, {
                    x: gsap.getProperty(leaderDoc, "x") + (Math.random() * 10 - 5),
                    y: gsap.getProperty(leaderDoc, "y") + (Math.random() * 20 - 10) + 10,
                    rotation: gsap.getProperty(leaderDoc, "rotation") + (Math.random() * 10 - 5),
                    scale: 1,
                    zIndex: state.currentZIndex - 1 - i,
                    duration: 0.5,
                    ease: "back.out(1.2)"
                });
            });

            // Pulse the leader
            gsap.fromTo(leaderDoc,
                { scale: 1.15 },
                { scale: 1.05, duration: 0.3, ease: "elastic.out(1, 0.3)" }
            );

            // Update filing area visibility (stack collected = should open)
            updateFilingAreaVisibility();
        }

        function gatherSpilledImagesIntoStack(doc) {
            const folderIndex = doc.dataset.index;
            const spilledImgs = state.spilledImages[folderIndex];

            if (!spilledImgs || spilledImgs.length === 0) return;

            const docX = gsap.getProperty(doc, 'x') || 0;
            const docY = gsap.getProperty(doc, 'y') || 0;

            // gather images into stack formation instantly (no animation during drag)
            spilledImgs.forEach((img, i) => {
                const stackOffsetX = i * 5; // horizontal offset for stack
                const stackOffsetY = i * 5 + 20; // vertical offset - stack below

                // update offsets first
                img.dataset.offsetX = stackOffsetX;
                img.dataset.offsetY = stackOffsetY;

                // set position instantly
                gsap.set(img, {
                    x: docX + stackOffsetX,
                    y: docY + stackOffsetY,
                    rotation: 0,
                    scale: 0.95
                });
            });
        }

        function spreadSpilledImagesFromStack(doc) {
            const folderIndex = doc.dataset.index;
            const spilledImgs = state.spilledImages[folderIndex];

            if (!spilledImgs || spilledImgs.length === 0) return;

            const docRect = doc.getBoundingClientRect();
            const docX = gsap.getProperty(doc, 'x');
            const docY = gsap.getProperty(doc, 'y');

            // spread images back to original pattern
            spilledImgs.forEach((img, i) => {
                const totalImages = spilledImgs.length;
                const angleStep = (360 / totalImages);
                const currentAngle = (angleStep * i) * (Math.PI / 180);
                const distance = 150 + Math.random() * 30;

                const centerX = docX + docRect.width / 2;
                const centerY = docY + docRect.height / 2;
                const imgWidth = 220;
                const imgHeight = 160;

                const endX = centerX + Math.cos(currentAngle) * distance - imgWidth / 2;
                const endY = centerY + Math.sin(currentAngle) * distance - imgHeight / 2;

                gsap.to(img, {
                    x: endX,
                    y: endY,
                    rotation: (Math.random() - 0.5) * 20,
                    scale: 1,
                    duration: 0.3,
                    ease: 'power2.out'
                });

                // update offsets for new positions
                img.dataset.offsetX = endX - docX;
                img.dataset.offsetY = endY - docY;
            });
        }

        function updateSpilledImagesPosition(doc) {
            const folderIndex = doc.dataset.index;
            const spilledImgs = state.spilledImages[folderIndex];

            if (!spilledImgs || spilledImgs.length === 0) return;

            // get current document position
            const x = gsap.getProperty(doc, 'x');
            const y = gsap.getProperty(doc, 'y');

            // move each spilled image relative to document
            spilledImgs.forEach(img => {
                const offsetX = parseFloat(img.dataset.offsetX) || 0;
                const offsetY = parseFloat(img.dataset.offsetY) || 0;

                gsap.set(img, {
                    x: x + offsetX,
                    y: y + offsetY
                });
            });
        }

        function updateHeldStackPosition(leaderDoc) {
            if (state.heldStack.length === 0) return;

            const leaderX = gsap.getProperty(leaderDoc, "x");
            const leaderY = gsap.getProperty(leaderDoc, "y");

            state.heldStack.forEach(item => {
                gsap.to(item.el, {
                    x: leaderX + item.offsetX,
                    y: leaderY + item.offsetY,
                    duration: 0.1, // Slight lag for natural feel
                    overwrite: "auto"
                });
            });
        }

        function releaseStack(droppedOnParent) {
            if (state.heldStack.length === 0) return;

            if (droppedOnParent) {
                // If dropped on parent, return all to list is handled by caller logic usually
                // But we can double check here
                state.heldStack.forEach(item => {
                    returnFileToList(item.el);
                });
            } else {
                // Return to desk state
                state.heldStack.forEach(item => {
                    const dragInstance = Draggable.get(item.el);
                    if (dragInstance) dragInstance.enable();

                    gsap.to(item.el, {
                        x: "+=" + (Math.random() * 60 - 30),
                        y: "+=" + (Math.random() * 60 - 30),
                        rotation: "+=" + (Math.random() * 20 - 10),
                        duration: 0.4,
                        ease: "power2.out"
                    });
                });
            }

            state.heldStack = [];

            // Update filing area visibility (stack released = might close)
            updateFilingAreaVisibility();
        }

        // overlap detection for drop zones (specific parent folder)
        function checkDropZoneOverlap(doc) {
            const category = doc.dataset.category;
            const targetFolder = document.querySelector(`.folder-stack[data-category="${category}"]`);

            if (!targetFolder) return;

            const docRect = doc.getBoundingClientRect();
            const folderRect = targetFolder.getBoundingClientRect();

            // QUANTUM PROXIMITY CHECK (Center-to-Center)
            const docCx = docRect.left + docRect.width / 2;
            const docCy = docRect.top + docRect.height / 2;
            const folderCx = folderRect.left + folderRect.width / 2;
            const folderCy = folderRect.top + folderRect.height / 2;

            const distance = Math.hypot(docCx - folderCx, docCy - folderCy);

            // Only glow if within 250px of center (increased for easier targeting)
            const isOverlapping = distance < 250;

            if (isOverlapping) {
                if (!state.isHoveringParent) {
                    state.isHoveringParent = true;
                    // SWELL ANIMATION
                    gsap.to(targetFolder, {
                        scale: 1,
                        boxShadow: '0 15px 30px rgba(255, 255, 255, 0.2)',
                        backgroundColor: 'rgba(255, 255, 255, 0.1)',
                        duration: 0.3,
                        ease: 'back.out(1.7)'
                    });
                }
            } else {
                if (state.isHoveringParent) {
                    state.isHoveringParent = false;
                    // RETURN TO NORMAL
                    gsap.to(targetFolder, {
                        scale: 1,
                        boxShadow: 'none',
                        backgroundColor: 'transparent', // Reset to css default
                        clearProps: 'backgroundColor,boxShadow', // cleaner reset
                        duration: 0.2
                    });
                }
            }
        }

        // snap to drop zone (return to list)
        function handleDropZoneSnap(doc) {
            if (state.isHoveringParent) {
                // Return main file
                returnFileToList(doc);

                // Reset folder visual immediately
                const category = doc.dataset.category;
                const folder = document.querySelector(`.folder-stack[data-category="${category}"]`);
                if (folder) {
                    gsap.to(folder, {
                        scale: 1,
                        clearProps: 'all',
                        duration: 0.3
                    });
                }

                state.isHoveringParent = false;
                return true; // Dropped on parent
            }
            return false;
        }

        // reset all folder visuals (called when sidebar hides)
        function resetFolderStates() {
            state.isHoveringParent = false;
            // Clear specific swell states
            const folders = document.querySelectorAll('.folder-stack');
            folders.forEach(folder => {
                gsap.to(folder, {
                    scale: 1,
                    boxShadow: 'none',
                    backgroundColor: 'transparent',
                    clearProps: 'backgroundColor,boxShadow',
                    duration: 0.2
                });
            });
        }

        // return file to list and remove from desk
        function returnFileToList(doc) {
            const category = doc.dataset.category;
            const folder = document.querySelector(`.folder-stack[data-category="${category}"]`);
            const fileList = folder.querySelector('.file-list');
            const index = doc.dataset.index;

            // remove peek images for this doc
            const peekImages = document.querySelectorAll(`.peek-image[data-parent="${index}"]`);
            peekImages.forEach(img => {
                gsap.killTweensOf(img);
                img.remove();
            });

            // gather spilled images first
            gatherImagesToFolder(doc);

            // create list item
            const listItem = document.createElement('div');
            listItem.className = 'file-list-item';
            listItem.dataset.index = doc.dataset.index;
            listItem.dataset.category = doc.dataset.category;
            listItem.dataset.url = doc.dataset.url;
            listItem.dataset.images = doc.dataset.images;
            listItem.dataset.title = doc.querySelector('.doc-title').textContent;
            listItem.dataset.year = doc.querySelector('.doc-year').textContent;

            listItem.innerHTML = `
                <div class="file-item-title">${listItem.dataset.title}</div>
                <div class="file-item-year">${listItem.dataset.year}</div>
            `;

            // make draggable (desktop) or clickable (mobile)
            const eventType = state.isMobile ? 'click' : 'mousedown';
            listItem.addEventListener(eventType, (e) => {
                handleListItemInteraction(listItem, e);
            });

            // animate document to list position then remove
            const listRect = fileList.getBoundingClientRect();
            const containerRect = document.getElementById('desk-container').getBoundingClientRect();
            const targetX = listRect.left - containerRect.left;
            const targetY = listRect.bottom - containerRect.top;

            gsap.to(doc, {
                x: targetX,
                y: targetY,
                scale: 0.5,
                opacity: 0,
                duration: 0.4,
                ease: 'power3.in',
                onComplete: () => {
                    doc.remove();
                    insertSortedAlpha(fileList, listItem);
                    updateFileCounts();

                    // expand folder to show file was added
                    folder.classList.add('expanded');

                    // update menu visibility
                    if (state.updateDesktopMenu) state.updateDesktopMenu();
                    if (state.updateMobileMenu) state.updateMobileMenu();
                }
            });
        }

        // spill images out from document (toggle behavior)
        function spillImages(doc) {
            const folderIndex = doc.dataset.index;

            // if already spilled, gather back instead
            if (state.spilledFolders.has(folderIndex)) {
                gatherImagesToFolder(doc);
                return;
            }

            // return all other spilled contents first
            const allDocs = document.querySelectorAll('.document');
            allDocs.forEach(otherDoc => {
                if (otherDoc !== doc && state.spilledFolders.has(otherDoc.dataset.index)) {
                    gatherImagesToFolder(otherDoc);
                }
            });

            const images = JSON.parse(doc.dataset.images);
            const docRect = doc.getBoundingClientRect();
            const containerRect = document.getElementById('desk-container').getBoundingClientRect();
            const container = document.getElementById('documents-area');

            // track spilled images for this folder
            state.spilledImages[folderIndex] = [];

            images.forEach((imgUrl, i) => {
                const img = document.createElement('img');
                img.className = 'spilled-image';
                img.loading = 'eager';
                img.src = imgUrl;
                img.dataset.parent = folderIndex;

                // image size matches document
                const imgWidth = 220;
                const imgHeight = 160;

                // get document's current GSAP position
                const docX = gsap.getProperty(doc, 'x') || 0;
                const docY = gsap.getProperty(doc, 'y') || 0;

                // document center in GSAP coordinates
                const centerX = docX + docRect.width / 2;
                const centerY = docY + docRect.height / 2;

                // start position (at document center)
                const startX = centerX - imgWidth / 2;
                const startY = centerY - imgHeight / 2;

                // spread evenly in circle around document
                const totalImages = images.length;
                const angleStep = (360 / totalImages);
                const currentAngle = (angleStep * i) * (Math.PI / 180);
                const distance = 150 + Math.random() * 30;

                const endX = centerX + Math.cos(currentAngle) * distance - imgWidth / 2;
                const endY = centerY + Math.sin(currentAngle) * distance - imgHeight / 2;
                const randomRot = (Math.random() - 0.5) * 20;

                // set initial position
                gsap.set(img, {
                    x: startX,
                    y: startY,
                    rotation: 0,
                    scale: 0.3,
                    opacity: 0,
                    zIndex: 50 + i
                });

                container.appendChild(img);

                // store relative offset from parent's GSAP position for dragging
                img.dataset.offsetX = endX - docX;
                img.dataset.offsetY = endY - docY;

                // track this image
                state.spilledImages[folderIndex].push(img);

                // animate spill out
                gsap.to(img, {
                    x: endX,
                    y: endY,
                    rotation: randomRot,
                    scale: 1,
                    opacity: 1,
                    duration: 0.15,
                    delay: i * 0.01,
                    ease: 'power2.out',
                    onComplete: () => {
                        makeImageDraggable(img);
                    }
                });
            });

            // mark as spilled
            state.spilledFolders.add(folderIndex);

            // hide parent document temporarily and send to back
            gsap.to(doc, {
                opacity: 1,
                scale: 0.95,
                zIndex: 5, // send opened files to back
                duration: 0.1
            });
        }

        // make spilled image draggable
        function makeImageDraggable(img) {
            Draggable.create(img, {
                type: 'x,y',
                cursor: 'pointer',
                bounds: '#desk-container',
                inertia: state.isMobile ? false : true,
                edgeResistance: 0.8,

                onPress: function () {
                    state.currentZIndex++;
                    gsap.to(this.target, {
                        zIndex: state.currentZIndex,
                        scale: 1.05,
                        duration: 0.1
                    });

                    // Reset shake context for images
                    state.imageShakeContext.lastX = this.x;
                    state.imageShakeContext.reversals = 0;
                    state.imageShakeContext.direction = 0;
                },

                onDrag: function () {
                    // Check for shake gesture
                    checkImageShake(this);

                    // Move collected stack if any
                    updateHeldImageStackPosition(this.target);

                    // Check if hovering over parent document
                    checkParentDocOverlap(this.target);
                },

                onDragEnd: function () {
                    // if dragged enough, don't treat as click
                    this.isDragging = false;

                    gsap.to(this.target, {
                        scale: 1,
                        duration: 0.15
                    });

                    // Check if dropped on parent document
                    const droppedOnParent = handleParentDocSnap(this.target);

                    // Release image stack if not dropped on parent
                    if (!droppedOnParent) {
                        releaseImageStack();
                    }
                },

                onClick: function () {
                    // enter lightbox on click
                    enterLightbox(this.target);
                }
            });
        }

        // === IMAGE SHAKE & STACK LOGIC ===

        function checkImageShake(draggable) {
            const currentX = draggable.x;
            const now = Date.now();
            const ctx = state.imageShakeContext;

            // Calculate delta and direction
            const delta = currentX - ctx.lastX;
            const direction = Math.sign(delta);

            // Only count significant moves
            if (Math.abs(delta) > 10) {
                if (direction !== ctx.direction && ctx.direction !== 0) {
                    // Direction reversal detected
                    if (now - ctx.lastReversalTime < 400) {
                        ctx.reversals++;
                    } else {
                        ctx.reversals = 1;
                    }
                    ctx.lastReversalTime = now;
                }
                ctx.direction = direction;
            }

            ctx.lastX = currentX;

            // Trigger shake if reversals threshold met
            if (ctx.reversals >= 3 && state.heldImageStack.length === 0) {
                collectSiblingImages(draggable.target);
                ctx.reversals = 0;
            }
        }

        function collectSiblingImages(leaderImg) {
            const parentIndex = leaderImg.dataset.parent;
            const allImages = document.querySelectorAll('.spilled-image');

            // Find valid siblings (same parent folder)
            const siblings = Array.from(allImages).filter(img =>
                img !== leaderImg &&
                img.dataset.parent === parentIndex &&
                !state.heldImageStack.some(item => item.el === img)
            );

            if (siblings.length === 0) return;

            // Animate them to the leader
            siblings.forEach((img, i) => {
                // Disable individual dragging for siblings
                const dragInstance = Draggable.get(img);
                if (dragInstance) dragInstance.disable();

                // Add to stack
                state.heldImageStack.push({
                    el: img,
                    offsetX: (Math.random() * 10 - 5),
                    offsetY: (Math.random() * 10 - 5) + 5
                });

                // Animate to position
                gsap.to(img, {
                    x: gsap.getProperty(leaderImg, "x") + (Math.random() * 10 - 5),
                    y: gsap.getProperty(leaderImg, "y") + (Math.random() * 20 - 10) + 10,
                    rotation: gsap.getProperty(leaderImg, "rotation") + (Math.random() * 10 - 5),
                    scale: 1,
                    zIndex: state.currentZIndex - 1 - i,
                    duration: 0.5,
                    ease: "back.out(1.2)"
                });
            });

            // Pulse the leader
            gsap.fromTo(leaderImg,
                { scale: 1.15 },
                { scale: 1.05, duration: 0.3, ease: "elastic.out(1, 0.3)" }
            );
        }

        function updateHeldImageStackPosition(leaderImg) {
            if (state.heldImageStack.length === 0) return;

            const leaderX = gsap.getProperty(leaderImg, "x");
            const leaderY = gsap.getProperty(leaderImg, "y");

            state.heldImageStack.forEach(item => {
                gsap.to(item.el, {
                    x: leaderX + item.offsetX,
                    y: leaderY + item.offsetY,
                    duration: 0.1,
                    overwrite: "auto"
                });
            });
        }

        function releaseImageStack() {
            if (state.heldImageStack.length === 0) return;

            // Scatter the stack
            state.heldImageStack.forEach(item => {
                const dragInstance = Draggable.get(item.el);
                if (dragInstance) dragInstance.enable();

                gsap.to(item.el, {
                    x: "+=" + (Math.random() * 60 - 30),
                    y: "+=" + (Math.random() * 60 - 30),
                    rotation: "+=" + (Math.random() * 20 - 10),
                    duration: 0.4,
                    ease: "power2.out"
                });
            });

            state.heldImageStack = [];
        }

        // Check if image is over its parent document
        function checkParentDocOverlap(img) {
            // only show visual indication if holding a stack (single images can't be dropped)
            if (state.heldImageStack.length === 0) {
                if (state.isHoveringParentDoc) {
                    resetParentDocState();
                }
                return;
            }

            const parentIndex = img.dataset.parent;
            const parentDoc = document.querySelector(`.document[data-index="${parentIndex}"]`);

            if (!parentDoc) {
                if (state.isHoveringParentDoc) {
                    resetParentDocState();
                }
                return;
            }

            const imgRect = img.getBoundingClientRect();
            const docRect = parentDoc.getBoundingClientRect();

            // Center-to-center distance check
            const imgCx = imgRect.left + imgRect.width / 2;
            const imgCy = imgRect.top + imgRect.height / 2;
            const docCx = docRect.left + docRect.width / 2;
            const docCy = docRect.top + docRect.height / 2;

            const distance = Math.hypot(imgCx - docCx, imgCy - docCy);

            // Hovering if within 150px of document center
            const isOverlapping = distance < 150;

            if (isOverlapping) {
                if (!state.isHoveringParentDoc) {
                    state.isHoveringParentDoc = true;
                    state.hoveredParentDoc = parentDoc;
                    // Swell animation
                    gsap.to(parentDoc, {
                        scale: 1.15,
                        opacity: 1,
                        boxShadow: '0 20px 40px rgba(255, 255, 255, 0.3)',
                        duration: 0.3,
                        ease: 'back.out(1.7)'
                    });
                }
            } else {
                if (state.isHoveringParentDoc) {
                    resetParentDocState();
                }
            }
        }

        // Reset parent document visual state
        function resetParentDocState() {
            if (state.hoveredParentDoc) {
                gsap.to(state.hoveredParentDoc, {
                    scale: 1,
                    opacity: 0.3,
                    boxShadow: '0 8px 16px rgba(0,0,0,0.4)',
                    duration: 0.2
                });
            }
            state.isHoveringParentDoc = false;
            state.hoveredParentDoc = null;
        }

        // Handle drop on parent document
        function handleParentDocSnap(img) {
            // Only accept stacks, not single images
            if (state.heldImageStack.length === 0) {
                return false;
            }

            if (state.isHoveringParentDoc && state.hoveredParentDoc) {
                const parentDoc = state.hoveredParentDoc;
                const parentIndex = img.dataset.parent;

                // Gather the leader image
                const imagesToGather = [img];

                // Add all stacked images
                state.heldImageStack.forEach(item => {
                    imagesToGather.push(item.el);
                });

                // Animate all images back to parent
                const docRect = parentDoc.getBoundingClientRect();
                const containerRect = document.getElementById('desk-container').getBoundingClientRect();
                const targetX = docRect.left - containerRect.left + (docRect.width - 162) / 2;
                const targetY = docRect.top - containerRect.top + (docRect.height - 126) / 2;

                imagesToGather.forEach((image, i) => {
                    gsap.to(image, {
                        x: targetX,
                        y: targetY,
                        rotation: 0,
                        scale: 0.3,
                        opacity: 0,
                        duration: 0.3,
                        delay: i * 0.02,
                        ease: 'power3.in',
                        onComplete: () => {
                            image.remove();
                        }
                    });
                });

                // Clear the stack
                state.heldImageStack = [];

                // Check if all images are gathered, if so restore document to unopened state
                setTimeout(() => {
                    const stillRemaining = document.querySelectorAll(`.spilled-image[data-parent="${parentIndex}"]`);
                    if (stillRemaining.length === 0) {
                        // Mark as not spilled
                        state.spilledFolders.delete(parentIndex);
                        state.spilledImages[parentIndex] = [];

                        // Restore document to unopened state
                        gsap.to(parentDoc, {
                            opacity: 1,
                            scale: 1,
                            zIndex: state.currentZIndex++,
                            duration: 0.3
                        });
                    }
                }, imagesToGather.length * 20 + 300);

                // Reset parent doc state
                resetParentDocState();

                return true;
            }
            return false;
        }

        // === LIGHTBOX LOGIC ===

        function getHighResUrl(url) {
            // simpler approach: just replace the dimensions if it's picsum
            // picsum format: .../seed/stuff/400/300
            if (url.includes('picsum.photos')) {
                return url.replace('/400/300', '/1600/1200');
            }
            return url;
        }

        function openGalleryFromDocument(doc) {
            if (state.galleryActive) return;

            const images = JSON.parse(doc.dataset.images);
            if (!images || images.length === 0) return;

            const folderIndex = doc.dataset.index;

            // Spill images behind overlay if not already spilled
            if (!state.spilledFolders.has(folderIndex)) {
                spillImagesForGallery(doc);
            }

            // Hide filing area
            const filingArea = document.getElementById('filing-area');
            filingArea.classList.remove('visible');

            // Show overlay
            document.getElementById('lightbox-overlay').classList.add('visible');

            // Create gallery
            const gallery = document.getElementById('lightbox-gallery');
            gallery.innerHTML = '';

            images.forEach((imgUrl, index) => {
                const galleryImg = document.createElement('img');
                galleryImg.className = 'lightbox-image';
                galleryImg.src = getHighResUrl(imgUrl);
                galleryImg.dataset.index = index;
                galleryImg.loading = 'eager';

                // Click to focus/unfocus (desktop only)
                if (!state.isMobile) {
                    galleryImg.addEventListener('click', (e) => {
                        e.stopPropagation();
                        toggleFocusImage(galleryImg);
                    });
                }

                gallery.appendChild(galleryImg);
            });

            // Show gallery
            setTimeout(() => {
                gallery.classList.add('visible');
                document.getElementById('lightbox-close').classList.add('visible');
                // Show tip on desktop only
                if (!state.isMobile) {
                    document.getElementById('lightbox-tip').classList.add('visible');
                }
            }, 50);

            state.galleryActive = true;
            state.gallerySourceDoc = doc;
            state.currentGalleryIndex = 0;
            setupGalleryKeyboardNav();
            setupMobileGalleryCarousel();
        }

        // Spill images for gallery (no toggle, just spill)
        function spillImagesForGallery(doc) {
            const folderIndex = doc.dataset.index;
            const images = JSON.parse(doc.dataset.images);
            const docRect = doc.getBoundingClientRect();
            const containerRect = document.getElementById('desk-container').getBoundingClientRect();
            const container = document.getElementById('documents-area');

            // Track spilled images for this folder
            state.spilledImages[folderIndex] = [];

            images.forEach((imgUrl, i) => {
                const img = document.createElement('img');
                img.className = 'spilled-image';
                img.loading = 'eager';
                img.src = imgUrl;
                img.dataset.parent = folderIndex;

                // image size matches document
                const imgWidth = 220;
                const imgHeight = 160;

                // get document's current GSAP position
                const docX = gsap.getProperty(doc, 'x') || 0;
                const docY = gsap.getProperty(doc, 'y') || 0;

                // document center in GSAP coordinates
                const centerX = docX + docRect.width / 2;
                const centerY = docY + docRect.height / 2;

                // start position (at document center)
                const startX = centerX - imgWidth / 2;
                const startY = centerY - imgHeight / 2;

                // spread evenly in circle around document
                const totalImages = images.length;
                const angleStep = (360 / totalImages);
                const currentAngle = (angleStep * i) * (Math.PI / 180);
                const distance = 150 + Math.random() * 30;

                const endX = centerX + Math.cos(currentAngle) * distance - imgWidth / 2;
                const endY = centerY + Math.sin(currentAngle) * distance - imgHeight / 2;
                const randomRot = (Math.random() - 0.5) * 20;

                gsap.set(img, {
                    x: startX,
                    y: startY,
                    rotation: 0,
                    scale: 0.3,
                    opacity: 0,
                    zIndex: 5
                });

                container.appendChild(img);

                // store relative offset from parent's GSAP position for dragging
                img.dataset.offsetX = endX - docX;
                img.dataset.offsetY = endY - docY;

                state.spilledImages[folderIndex].push(img);

                gsap.to(img, {
                    x: endX,
                    y: endY,
                    rotation: randomRot,
                    scale: 1,
                    opacity: 1,
                    duration: 0.15,
                    delay: i * 0.01,
                    ease: 'power2.out'
                });
            });

            state.spilledFolders.add(folderIndex);

            gsap.to(doc, {
                opacity: 1,
                scale: 0.95,
                zIndex: 5,
                duration: 0.1
            });
        }

        function enterLightbox(img) {
            if (state.galleryActive) return; // already active

            // Hide filing area
            const filingArea = document.getElementById('filing-area');
            filingArea.classList.remove('visible');

            // Get all images from same parent
            const parentIndex = img.dataset.parent;
            const allImages = Array.from(document.querySelectorAll(`.spilled-image[data-parent="${parentIndex}"]`));

            // Get parent document
            const parentDoc = document.querySelector(`.document[data-index="${parentIndex}"]`);
            if (parentDoc) {
                state.gallerySourceDoc = parentDoc;
            }

            // Disable all document dragging to prevent wastebin from showing
            const allDocs = document.querySelectorAll('.document');
            allDocs.forEach(doc => {
                const dragInstance = Draggable.get(doc);
                if (dragInstance) dragInstance.disable();
            });

            // Hide all original images
            allImages.forEach(image => {
                const dragInstance = Draggable.get(image);
                if (dragInstance) dragInstance.disable();
                gsap.set(image, { opacity: 0 });
            });

            // Show overlay
            document.getElementById('lightbox-overlay').classList.add('visible');

            // Create gallery
            const gallery = document.getElementById('lightbox-gallery');
            gallery.innerHTML = ''; // clear existing

            allImages.forEach((image, index) => {
                const galleryImg = document.createElement('img');
                galleryImg.className = 'lightbox-image';
                galleryImg.src = getHighResUrl(image.src);
                galleryImg.dataset.index = index;
                galleryImg.dataset.originalImage = index;
                galleryImg.loading = 'eager';

                // Click to focus/unfocus (desktop only)
                if (!state.isMobile) {
                    galleryImg.addEventListener('click', (e) => {
                        e.stopPropagation();
                        toggleFocusImage(galleryImg);
                    });
                }

                gallery.appendChild(galleryImg);
            });

            // Show gallery
            setTimeout(() => {
                gallery.classList.add('visible');
                document.getElementById('lightbox-close').classList.add('visible');
                // Show tip on desktop only
                if (!state.isMobile) {
                    document.getElementById('lightbox-tip').classList.add('visible');
                }
            }, 50);

            state.galleryActive = true;
            state.galleryImages = allImages;
            state.currentGalleryIndex = 0;
            setupGalleryKeyboardNav();
            setupMobileGalleryCarousel();
        }

        function setupGalleryKeyboardNav() {
            if (state.galleryKeyHandler) {
                document.removeEventListener('keydown', state.galleryKeyHandler);
            }

            state.galleryKeyHandler = (e) => {
                if (!state.galleryActive) return;

                if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    navigateGallery(-1);
                } else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    navigateGallery(1);
                }
            };

            document.addEventListener('keydown', state.galleryKeyHandler);
        }

        function setupMobileGalleryCarousel() {
            // mobile uses simple vertical scroll - no setup needed
            return;
        }

        function navigateGallery(direction) {
            if (state.isMobile) return; // mobile uses different interaction

            const gallery = document.getElementById('lightbox-gallery');
            const images = Array.from(gallery.querySelectorAll('.lightbox-image'));

            if (images.length === 0) return;

            // Get currently focused image
            const currentlyFocused = gallery.querySelector('.lightbox-image.focused');
            let currentIndex = currentlyFocused ? parseInt(currentlyFocused.dataset.index) : -1;

            let targetIndex;

            // If something is already focused, navigate linearly to immediate neighbors
            if (currentIndex !== -1) {
                if (direction < 0) {
                    // Left arrow - go to immediate left neighbor if exists
                    targetIndex = currentIndex > 0 ? currentIndex - 1 : null;
                } else {
                    // Right arrow - go to immediate right neighbor if exists
                    targetIndex = currentIndex < images.length - 1 ? currentIndex + 1 : null;
                }

                // If no neighbor in that direction, do nothing
                if (targetIndex === null) return;
            } else {
                // Initial selection - use edge-based logic
                if (images.length === 1) {
                    // 1 item: any arrow focuses it
                    targetIndex = 0;
                } else if (images.length === 2) {
                    // 2 items: left = 0, right = 1
                    targetIndex = direction < 0 ? 0 : 1;
                } else {
                    // 3+ items: left arrow = leftmost, right arrow = rightmost
                    targetIndex = direction < 0 ? 0 : images.length - 1;
                }
            }

            // Focus the target image
            const targetImage = images[targetIndex];
            if (targetImage && !targetImage.classList.contains('focused')) {
                toggleFocusImage(targetImage);
            }
        }

        function toggleFocusImage(img) {
            const allGalleryImages = document.querySelectorAll('.lightbox-image');

            if (img.classList.contains('focused')) {
                // Unfocus - restore all to full opacity
                img.classList.remove('focused');
                allGalleryImages.forEach(i => {
                    gsap.to(i, { opacity: 1, duration: 0.3 });
                });
            } else {
                // Remove focus from all others
                allGalleryImages.forEach(i => i.classList.remove('focused'));
                // Focus this one
                img.classList.add('focused');

                // Center focused image in viewport (accounting for 1.5x scale)
                const gallery = document.getElementById('lightbox-gallery');
                const imgRect = img.getBoundingClientRect();
                const galleryRect = gallery.getBoundingClientRect();

                // image center relative to gallery scroll position
                const imgCenter = imgRect.left + imgRect.width / 2 - galleryRect.left + gallery.scrollLeft;
                // account for 1.5x scale - need extra padding
                const scaledHalfWidth = (imgRect.width * 1.5) / 2;
                const viewportCenter = galleryRect.width / 2;

                // scroll so image center lands at viewport center
                const targetScrollLeft = imgCenter - viewportCenter;

                gallery.scrollTo({
                    left: Math.max(0, targetScrollLeft),
                    behavior: 'smooth'
                });

                // Fade all others to low opacity
                allGalleryImages.forEach(i => {
                    if (i !== img) {
                        gsap.to(i, { opacity: 0.2, duration: 0.3 });
                    } else {
                        gsap.to(i, { opacity: 1, duration: 0.3 });
                    }
                });

                // Update current index
                const index = parseInt(img.dataset.index);
                if (!isNaN(index)) {
                    state.currentGalleryIndex = index;
                }
            }
        }

        function exitLightbox() {
            if (!state.galleryActive) return;

            // CRITICAL: Immediately hide wastebin and reset drag state
            state.isDragging = false;
            if (state.wastebin) {
                state.wastebin.hideWastebin();
            }

            // Remove keyboard handler
            if (state.galleryKeyHandler) {
                document.removeEventListener('keydown', state.galleryKeyHandler);
                state.galleryKeyHandler = null;
            }

            // Remove scroll handler (mobile)
            const gallery = document.getElementById('lightbox-gallery');
            if (state.galleryScrollHandler) {
                gallery.removeEventListener('scroll', state.galleryScrollHandler);
                state.galleryScrollHandler = null;
            }

            // Hide overlay
            document.getElementById('lightbox-overlay').classList.remove('visible');

            // Hide gallery
            gallery.classList.remove('visible');
            document.getElementById('lightbox-close').classList.remove('visible');
            document.getElementById('lightbox-tip').classList.remove('visible');

            setTimeout(() => {
                gallery.innerHTML = '';
            }, 200);

            // Reset source document to default state
            if (state.gallerySourceDoc) {
                // Reset drag state and visual properties
                state.selectedDoc = null;

                gsap.to(state.gallerySourceDoc, {
                    scale: 1,
                    rotation: 0,
                    boxShadow: '0 8px 16px rgba(0,0,0,0.4)',
                    duration: 0.2
                });

                // Re-enable draggable if it was disabled
                const dragInstance = Draggable.get(state.gallerySourceDoc);
                if (dragInstance) dragInstance.enable();

                // Gather spilled images back
                gatherImagesToFolder(state.gallerySourceDoc);
            }

            // Re-enable all document dragging
            const allDocs = document.querySelectorAll('.document');
            allDocs.forEach(doc => {
                const dragInstance = Draggable.get(doc);
                if (dragInstance) dragInstance.enable();
            });

            // Show original images if they exist (for enterLightbox path)
            if (state.galleryImages) {
                state.galleryImages.forEach(image => {
                    gsap.set(image, { opacity: 1 });
                    const dragInstance = Draggable.get(image);
                    if (dragInstance) dragInstance.enable();
                });
            }

            state.galleryActive = false;
            state.galleryImages = null;
            state.gallerySourceDoc = null;
            state.currentGalleryIndex = 0;
        }

        // double-click to open original url
        function openDocument(doc) {
            const url = doc.dataset.url;
            window.open(url, '_blank');
        }

        // gather spilled images back to folder
        function gatherImagesToFolder(doc) {
            const folderIndex = doc.dataset.index;
            const spilledImgs = state.spilledImages[folderIndex];

            if (!spilledImgs || spilledImgs.length === 0) return;

            const docRect = doc.getBoundingClientRect();
            const containerRect = document.getElementById('desk-container').getBoundingClientRect();
            const imgWidth = 220;
            const imgHeight = 160;
            const targetX = docRect.left - containerRect.left + (docRect.width - imgWidth) / 2;
            const targetY = docRect.top - containerRect.top + (docRect.height - imgHeight) / 2;

            spilledImgs.forEach((img, i) => {
                gsap.to(img, {
                    x: targetX,
                    y: targetY,
                    rotation: 0,
                    scale: 0.3,
                    opacity: 0,
                    duration: 0.12,
                    delay: i * 0.005,
                    ease: 'power2.in',
                    onComplete: () => {
                        img.remove();
                    }
                });
            });

            // restore folder appearance and ensure it's interactive
            gsap.to(doc, {
                opacity: 1,
                scale: 1,
                rotation: 0,
                duration: 0.15,
                onComplete: () => {
                    // ensure document is clickable and peek works again
                    doc.style.pointerEvents = 'all';
                    doc.style.cursor = 'pointer';
                }
            });

            // clear tracking - this allows peek to work again
            state.spilledImages[folderIndex] = [];
            state.spilledFolders.delete(folderIndex);
        }

        // cleanup all: return images + files to list and remove from desk
        function cleanupAllImages() {
            const docs = Array.from(document.querySelectorAll('.document'));

            docs.forEach((doc, index) => {
                // gather spilled images back first
                gatherImagesToFolder(doc);

                // return file to list with staggered animation
                setTimeout(() => {
                    returnFileToList(doc);
                }, index * 100); // stagger by 100ms each
            });
        }

        // idle animation (subtle paper movement)
        function startIdleAnimation() {
            const docs = document.querySelectorAll('.document');

            docs.forEach((doc, i) => {
                gsap.to(doc, {
                    y: '+=3',
                    rotation: '+=0.5',
                    duration: 3 + Math.random() * 2,
                    repeat: -1,
                    yoyo: true,
                    ease: 'sine.inOut',
                    delay: i * 0.2
                });
            });
        }

        // keyboard shortcuts
        function addKeyboardShortcuts() {
            window.addEventListener('keydown', (e) => {
                // ESC: Exit gallery OR navigate home
                if (e.key === 'Escape') {
                    if (state.galleryActive) {
                        exitLightbox();
                    } else {
                        window.location.href = '/';
                    }
                }

                if (state.galleryActive) return; // disable others while in gallery

                // category filter shortcuts
                if (e.key === '1') filterByCategory('saas');
                if (e.key === '2') filterByCategory('ecommerce');
                if (e.key === '3') filterByCategory('design');
                if (e.key === '0') showAllDocuments();

                // tilde key: show tips
                if (e.key === '`') {
                    document.getElementById('filter-hint').classList.add('visible');
                    document.getElementById('back-link').classList.add('visible');
                    document.getElementById('cleanup-btn').classList.add('visible');
                }
            });

            window.addEventListener('keyup', (e) => {
                // tilde key: hide tips
                if (e.key === '`') {
                    document.getElementById('filter-hint').classList.remove('visible');
                    document.getElementById('back-link').classList.remove('visible');
                    document.getElementById('cleanup-btn').classList.remove('visible');
                }
            });
        }

        // category filtering
        function filterByCategory(category) {
            const docs = document.querySelectorAll('.document');

            docs.forEach(doc => {
                if (doc.dataset.category === category) {
                    gsap.to(doc, { opacity: 1, scale: 1, duration: 0.3 });
                } else {
                    gsap.to(doc, { opacity: 0.2, scale: 0.9, duration: 0.3 });
                }
            });
        }

        function showAllDocuments() {
            const docs = document.querySelectorAll('.document');
            gsap.to(docs, { opacity: 1, scale: 1, duration: 0.3, stagger: 0.05 });
        }

        // init on load
        window.addEventListener('load', init);
    </script>
</body>

</html>