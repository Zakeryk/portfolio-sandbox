<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wii Concept OS</title>
  <link rel="icon" type="image/png" href="assets/wiicursor_sprite.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&family=Orbitron:wght@400;700&display=swap" rel="stylesheet">

  <style>
    /* --- RESET --- */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body, html {
      width: 100%; height: 100%; overflow: hidden;
      background-color: #e0e0e0;
      font-family: 'Inter', sans-serif;
      cursor: none; 
      user-select: none;
    }

    /* --- CRT / GRAIN OVERLAY (THE ANALOG FIX) --- */
    #analog-overlay {
        position: fixed;
        top: 0; left: 0;
        width: 100%; height: 100%;
        pointer-events: none; /* Lets clicks pass through */
        z-index: 9000;
        opacity: 0.6; /* Adjust intensity of grain here */
    }

    #scanlines {
        width: 100%; height: 100%;
        background: linear-gradient(
            to bottom,
            rgba(255,255,255,0),
            rgba(255,255,255,0) 50%,
            rgba(0,0,0,0.05) 50%,
            rgba(0,0,0,0.05)
        );
        background-size: 100% 4px;
        position: absolute;
        top: 0; left: 0;
    }

    #noise {
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        /* Data URI for noise texture to avoid external asset dependency */
        background-image: url('data:image/svg+xml,%3Csvg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg"%3E%3Cfilter id="noiseFilter"%3E%3CfeTurbulence type="fractalNoise" baseFrequency="0.85" numOctaves="3" stitchTiles="stitch"/%3E%3C/filter%3E%3Crect width="100%25" height="100%25" filter="url(%23noiseFilter)" opacity="0.15"/%3E%3C/svg%3E');
        opacity: 0.4;
        mix-blend-mode: overlay;
        animation: noiseAnimation 0.2s infinite;
    }

    @keyframes noiseAnimation {
        0% { transform: translate(0,0); }
        10% { transform: translate(-1%,-1%); }
        20% { transform: translate(-2%,1%); }
        30% { transform: translate(1%,-2%); }
        40% { transform: translate(2%,1%); }
        50% { transform: translate(-1%,2%); }
        60% { transform: translate(1%,1%); }
        70% { transform: translate(2%,-2%); }
        80% { transform: translate(-2%,-1%); }
        90% { transform: translate(1%,2%); }
        100% { transform: translate(0,0); }
    }

    /* --- PRELOADER --- */
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    #preloader {
        position: fixed;
        top: 0; left: 0;
        width: 100%; height: 100%;
        background-color: #f0f0f0; 
        color: #000000;
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        font-family: 'Orbitron', sans-serif;
        font-size: 1.5rem;
        z-index: 100000;
        opacity: 1;
        transition: opacity 0.5s ease; 
    }

    #preloader.fade-out {
        opacity: 0;
        visibility: hidden;
    }

    #preloader-spinner {
        border: 4px solid #f0f0f0; 
        border-top: 4px solid #7ec1d9; 
        border-radius: 50%;
        width: 30px;
        height: 30px;
        animation: spin 1s linear infinite;
        margin-bottom: 20px;
    }

    #preloader-text {
        color: #888;
        font-size: 0.8rem;
        margin-top: 10px;
        letter-spacing: 1px;
    }

    /* --- LAYOUT --- */
    #scene-container {
      position: relative;
      width: 100%; height: 100%;
      z-index: 10;
    }

    #primary-panel {
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      background: linear-gradient(to bottom, #ffffff 0%, #f0f0f0 100%);
      clip-path: url(#panel-mask);
      -webkit-clip-path: url(#panel-mask);
      filter: drop-shadow(0px 10px 20px rgba(0,0,0,0.15));
      z-index: 1; 
    }

    #canvas-wrapper { width: 100%; height: 100%; display: block; }
    
    /* --- TILE LABEL CONTAINER STYLE --- */
    #tile-label-container {
        position: absolute;
        top: 0; 
        left: 0; 
        width: 100%; 
        height: 100%;
        pointer-events: none; 
        z-index: 40; 
    }

    /* --- CLOCK --- */
    #clock {
      position: absolute; 
      bottom: 30px; 
      left: 50%;
      transform: translateX(-50%);
      font-family: 'Orbitron', sans-serif; 
      font-size: 4.8rem;
      color: #000000; 
      pointer-events: none;
      z-index: 30; 
      white-space: nowrap;
      opacity: 0.8;
    }

    #instructions {
      position: fixed; bottom: 20px; left: 20px;
      color: #888; font-size: 12px; z-index: 100;
      pointer-events: none; font-family: sans-serif;
    }

    /* --- CUSTOM CURSOR --- */
    #custom-cursor {
      position: fixed; top: 0; left: 0;
      pointer-events: none; z-index: 9999;
      will-change: transform;
      transform-origin: 0% 0%; 
      transition: opacity 0.2s ease;
    }
    
    #custom-cursor img { 
        display: block;
        width: 60px; 
        height: auto;
    }

    #debug-hotspot {
      display: none;
      position: absolute; top: -2px; left: -2px;
      width: 4px; height: 4px;
      background: red; border-radius: 50%;
    }

    /* --- GUI CONTAINER --- */
    #gui-container {
        position: absolute;
        top: 0;
        right: 0;
        z-index: 10001;
        display: none; 
    }
    
    /* --- TILE INDEX LABEL --- */
    .tile-index-label {
        position: absolute;
        color: rgba(0, 0, 0, 0.4);
        font-size: 18px;
        font-weight: 700;
        z-index: 50; 
        pointer-events: none;
        display: none; 
        font-family: 'Orbitron', sans-serif;
        text-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);
    }
    
    .tile-hidden {
        display: none !important;
    }

    /* --- DEBUG MODE --- */
    body.debug-mode { cursor: auto !important; }
    body.debug-mode #gui-container { display: block; }
    body.debug-mode #debug-hotspot { display: block; }
    body.debug-mode #custom-cursor { opacity: 0.5; }
    body.debug-mode .tile-index-label { display: block; } 

  </style>
</head>

<body>
    
  <div id="preloader">
      <div id="preloader-spinner"></div>
      LOADING OS
      <div id="preloader-text">ZAK KNOWLTON &copy; 2026</div>
  </div>

  <div id="analog-overlay">
      <div id="scanlines"></div>
      <div id="noise"></div>
  </div>

  <svg style="position: absolute; width: 100%; height: 100%; pointer-events: none; z-index: 15; top: 0; left: 0;">
    <defs>
      <clipPath id="panel-mask" clipPathUnits="userSpaceOnUse">
        <path id="mask-path-el" d="" /> 
      </clipPath>
    </defs>
    <path id="border-path-el" fill="none" stroke="#7ec1d9" stroke-width="2" stroke-linecap="square" />
  </svg>

  <div id="scene-container">
    <div id="primary-panel">
      <div id="canvas-wrapper"></div>
    </div>
    <div id="tile-label-container"></div> 
    
    <div id="clock">12:00</div>
    <div id="instructions">[~] Toggle Debug Config</div>
  </div>
  
  <div id="gui-container"></div>

  <div id="custom-cursor">
    <img src="assets/wiicursor_sprite.png" alt="cursor">
    <div id="debug-hotspot"></div>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
        "dat.gui": "https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.module.js"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry.js';
    import { GUI } from 'dat.gui';
    
    // --- ASSETS ---
    const ASSETS = {
        0: 'assets/channel_devil.jpg',
        1: 'assets/channel_wii.jpg',
        2: 'assets/channel_grassball.jpg',
        3: 'assets/channel_knot.jpg',
        4: null, 5: null, 6: null, 7: null, 8: null, 9: null, 10: null, 11: null,
    };
    
    // --- LINKS ---
    const BASE_TARGET = '/projects/concept_wii'; 
    const LINKS = {
        0: BASE_TARGET, 
        1: BASE_TARGET, 
        2: BASE_TARGET,
        3: BASE_TARGET,
    };

    // --- CONFIG ---
    const PARAMS = {
        transitionDuration: 1000,
        camX: 0, camY: -1.5, camZ: 10,
        aimX: 0, aimY: -1.5, aimZ: 0,
        camZoom: 2.7,
        gridSpacing: 1.2, 
        gridOffsetX: 0.0, 
        gridOffsetY: -1.2,
        borderRadius: 0.018,
        activeSlot: 1,
        splitHeight: 0.85,
    };

    // --- STATE ---
    const cursorState = { 
        x: 0, y: 0, prevX: 0, targetX: 0, targetY: 0, 
        angle: 0, scale: 1, targetScale: 1 
    };
    
    let INTERSECTED = null;
    let cameraTween = null;
    let lastMoveTime = performance.now(); 
    let isMouseDown = false; 
    
    let COLS = 4; 
    let ROWS = 3; 
    
    // --- SETUP ---
    const container = document.getElementById('canvas-wrapper');
    const labelContainer = document.getElementById('tile-label-container');
    const scene = new THREE.Scene();
    const aspect = container.clientWidth / container.clientHeight;
    const baseSize = 5;
    const camera = new THREE.OrthographicCamera(-aspect * baseSize, aspect * baseSize, baseSize, -baseSize, 0.1, 1000);
    camera.position.set(PARAMS.camX, PARAMS.camY, PARAMS.camZ);
    camera.zoom = PARAMS.camZoom;
    camera.updateProjectionMatrix();

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);
    
    scene.add(new THREE.AmbientLight(0xffffff, 1.6));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.8);
    dirLight.position.set(5, 10, 10);
    scene.add(dirLight);

    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();
    const worldPosition = new THREE.Vector3(); 

    // --- BORDERS ---
    function updateBorders() {
        const w = window.innerWidth;
        const h = window.innerHeight;
        const splitY = h * PARAMS.splitHeight;
        document.getElementById('mask-path-el').setAttribute('d', `M 0,0 L ${w},0 L ${w},${splitY} L 0,${splitY} Z`);
        document.getElementById('border-path-el').setAttribute('d', `M 0,${splitY} L ${w},${splitY}`);
    }

    // --- TEXTURE LOADER SETUP ---
    const textureLoader = new THREE.TextureLoader();
    const materials = [];
    const channelBlocks = []; 

    // --- GRID MANAGEMENT ---
    const BASE_BLOCK_WIDTH = 1.12; 
    const BASE_BLOCK_HEIGHT = 0.72;
    const MOBILE_SCALE_FACTOR = 0.55; 
    const TILE_ASPECT = BASE_BLOCK_WIDTH / BASE_BLOCK_HEIGHT;
    const MAX_TILES = 12;
    
    // Initial creation of all 12 tiles (done once)
    for(let i=0; i<MAX_TILES; i++) {
        const geo = new RoundedBoxGeometry(BASE_BLOCK_WIDTH, BASE_BLOCK_HEIGHT, 0.2, 4, PARAMS.borderRadius);
        
        let mat = new THREE.MeshPhongMaterial({ 
            color: 0xe0e0e0, 
            specular: 0x222222, 
            shininess: 10 
        });
        const assetPath = ASSETS[i]; 

        if (assetPath) {
            textureLoader.load(assetPath, 
                (tex) => {
                    tex.colorSpace = THREE.SRGBColorSpace; 
                    tex.wrapS = THREE.RepeatWrapping; 
                    tex.wrapT = THREE.RepeatWrapping;

                    const imageAspect = tex.image.width / tex.image.height;
                    const tileAspect = TILE_ASPECT;
                    
                    if (imageAspect / tileAspect > 1) {
                        tex.repeat.set(tileAspect / imageAspect, 1);
                        tex.offset.set((1 - (tileAspect / imageAspect)) / 2, 0);
                    } else {
                        tex.repeat.set(1, imageAspect / tileAspect);
                        tex.offset.set(0, (1 - (imageAspect / tileAspect)) / 2);
                    }
                    
                    mat.map = tex;
                    mat.needsUpdate = true;
                },
                undefined, 
                (err) => {
                    console.error('Error loading texture for tile', i, err);
                    mat.color.setHex(0xe0e0e0); 
                    mat.needsUpdate = true;
                }
            );
        }

        const mesh = new THREE.Mesh(geo, mat);
        mesh.userData.index = i;
        mesh.userData.velocity = new THREE.Vector3();
        mesh.userData.targetScale = new THREE.Vector3(1, 1, 1);
        mesh.userData.wasClicked = false; 
        mesh.userData.isSpringing = false; 
        
        scene.add(mesh);
        channelBlocks.push(mesh);
        materials.push(mat); 

        const labelDiv = document.createElement('div');
        labelDiv.className = 'tile-index-label';
        labelDiv.textContent = i;
        labelContainer.appendChild(labelDiv);
        mesh.userData.label = labelDiv; 
    }

    function updateGrid() {
        const isMobile = window.innerWidth <= 768;
        COLS = isMobile ? 2 : 4;
        ROWS = 3;
        
        const scaleFactor = isMobile ? MOBILE_SCALE_FACTOR : 1.0;
        
        const limit = COLS * ROWS; 

        channelBlocks.forEach((b, i) => {
            const isVisible = i < limit;
            
            b.visible = isVisible;
            if (b.userData.label) {
                b.userData.label.classList.toggle('tile-hidden', !isVisible);
            }
            
            // Set the dynamic scale for the mesh
            b.scale.set(scaleFactor, scaleFactor, 1); 
            
            // Positioning must use the new scaled dimensions
            const gap = PARAMS.gridSpacing - BASE_BLOCK_WIDTH;
            const autoSpacingY = gap + BASE_BLOCK_HEIGHT;
            const totalW = (COLS - 1) * PARAMS.gridSpacing * scaleFactor;
            const xOffset = -totalW / 2 + PARAMS.gridOffsetX;
            const yOffset = ((ROWS - 1) * autoSpacingY) / 2 + PARAMS.gridOffsetY;
            
            const col = i % COLS;
            const row = Math.floor(i / COLS);

            b.position.set(xOffset + col * PARAMS.gridSpacing * scaleFactor, yOffset - row * autoSpacingY * scaleFactor, 0);
        });
    }
    
    updateGrid(); // Initial grid setup

    // --- PRELOADER FADE OUT ---
    window.addEventListener('load', () => {
        document.getElementById('preloader').classList.add('fade-out');
    });


    // --- EVENTS ---
    window.addEventListener('resize', () => {
        const asp = container.clientWidth / container.clientHeight;
        camera.left = -asp * baseSize; camera.right = asp * baseSize;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
        updateBorders();
        updateGrid(); 
    });

    window.addEventListener('keydown', (e) => {
        if (e.key === '`' || e.key === '~') {
            document.body.classList.toggle('debug-mode');
        }
    });

    window.addEventListener('mousedown', (e) => {
        if (document.body.classList.contains('debug-mode') && e.target.closest('.dg')) return;
        isMouseDown = true; 
        lastMoveTime = performance.now(); 
        cursorState.targetScale = 0.8; 
    });

    window.addEventListener('mouseup', () => {
        isMouseDown = false; 
        lastMoveTime = performance.now(); 
        cursorState.targetScale = 1.0; 
        
        if (INTERSECTED) { 
            const index = INTERSECTED.userData.index;
            const targetLink = LINKS[index];

            if (targetLink) {
                // 0.3s DELAY FOR NAVIGATION
                setTimeout(() => {
                    window.location.href = targetLink;
                }, 300); 
            }
            
            INTERSECTED.userData.wasClicked = true; 
        } 
    });

    window.addEventListener('mousemove', (e) => {
        cursorState.targetX = e.clientX;
        cursorState.targetY = e.clientY;
        lastMoveTime = performance.now(); 
        
        const rect = container.getBoundingClientRect();
        pointer.x = ((e.clientX - rect.left) / container.clientWidth) * 2 - 1;
        pointer.y = -((e.clientY - rect.top) / container.clientHeight) * 2 + 1;
    });

    // --- ANIMATION ---
    function animate() {
        requestAnimationFrame(animate);
        
        if (cameraTween) { /* ... camera tween logic ... */ }

        camera.position.set(PARAMS.camX, PARAMS.camY, PARAMS.camZ);
        camera.lookAt(PARAMS.aimX, PARAMS.aimY, PARAMS.aimZ);

        raycaster.setFromCamera(pointer, camera);
        
        const visibleChannels = channelBlocks.filter(b => b.visible);
        const intersects = raycaster.intersectObjects(visibleChannels, false);
        
        const DEFAULT_SHININESS = 10;
        const HOVER_SHININESS = 90;
        const DEFAULT_EMISSIVE = 0x000000;
        const HOVER_EMISSIVE = 0x555555; // Bright glare
        const LERP_FACTOR = 0.15;

        if (intersects.length > 0) {
            const target = intersects[0].object;
            if (INTERSECTED !== target) {
                INTERSECTED = target;
            }
        } else {
            INTERSECTED = null;
        }

        // --- RENDER LOOP: MATERIAL & PHYSICS ---
        channelBlocks.forEach(b => {
            if (!b.visible) return;

            const currentlyHovered = b === INTERSECTED;
            
            // --- MATERIAL LERP (Anime Glare) ---
            const targetShin = currentlyHovered ? HOVER_SHININESS : DEFAULT_SHININESS;
            b.material.shininess += (targetShin - b.material.shininess) * LERP_FACTOR;
            
            const currentEmissive = b.material.emissive;
            const targetHex = currentlyHovered ? HOVER_EMISSIVE : DEFAULT_EMISSIVE;
            const targetColor = new THREE.Color(targetHex);
            currentEmissive.lerp(targetColor, LERP_FACTOR);
            
            b.material.needsUpdate = true;


            // --- HYBRID TILE PHYSICS ---
            let targetS = 1.0;
            const SPRING_TENSION = 0.14; 
            const SPRING_DAMPING = 0.85; 
            const OVERSHOOT_SCALE = 1.03; 
            const LERP_CLICK = 0.2; 
            const LERP_NORMAL = 0.08; 
            
            if (currentlyHovered) {
                if (isMouseDown) {
                    targetS = 0.95; 
                    b.userData.isSpringing = false; 
                    b.userData.velocity.set(0,0,0);
                } else {
                    targetS = 1.05; 
                    
                    if (b.userData.wasClicked) {
                        b.userData.isSpringing = true;
                        const launchForce = OVERSHOOT_SCALE - b.scale.x;
                        b.userData.velocity.x += launchForce * 0.5; 
                        b.userData.wasClicked = false; 
                    }
                }
            } else {
                targetS = 1.0; 
                b.userData.wasClicked = false; 
            }
            
            // 2. Apply Animation Logic
            if (b.userData.isSpringing) {
                const tension = SPRING_TENSION; 
                const damping = SPRING_DAMPING; 
                const dist = targetS - b.scale.x;
                
                b.userData.velocity.x += dist * tension;
                b.userData.velocity.x *= damping;
                
                if (Math.abs(b.userData.velocity.x) < 0.001 && Math.abs(dist) < 0.005) {
                    b.userData.isSpringing = false;
                    b.scale.set(targetS, targetS, targetS);
                } else {
                    const next = b.scale.x + b.userData.velocity.x;
                    b.scale.set(next, next, next);
                }
            } else {
                let lerpFactor = currentlyHovered && isMouseDown ? LERP_CLICK : LERP_NORMAL;
                b.scale.lerp(new THREE.Vector3(targetS, targetS, targetS), lerpFactor);
            }
            
            // 3. Update HTML Label Position
            b.updateWorldMatrix(true, false);
            b.getWorldPosition(worldPosition);
            
            const screenPosition = worldPosition.clone();
            screenPosition.project(camera);
            
            const x = (screenPosition.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
            const y = (-screenPosition.y * 0.5 + 0.5) * renderer.domElement.clientHeight;
            
            if(b.userData.label) {
                b.userData.label.style.transform = `translate3d(${x}px, ${y}px, 0) translate(-50%, -50%) scale(${b.scale.x})`;
            }

        });

        renderer.render(scene, camera);
    }
    animate();

    // --- CURSOR PHYSICS LOOP ---
    const cursorEl = document.getElementById('custom-cursor');
    const IDLE_TIMEOUT = 300; 

    function animateCursor() {
        cursorState.x = cursorState.targetX;
        cursorState.y = cursorState.targetY;
        
        cursorState.scale += (cursorState.targetScale - cursorState.scale) * 0.2;
        
        if (cursorState.prevX === undefined) cursorState.prevX = cursorState.x;
        const dx = cursorState.x - cursorState.prevX;
        cursorState.prevX = cursorState.x;

        const isTrulyIdle = performance.now() - lastMoveTime > IDLE_TIMEOUT;
        const isIdle = isTrulyIdle && !isMouseDown; 
        
        let targetBaseRotation = -10; 

        if (isIdle) {
            targetBaseRotation = 0; 
        }
        
        const decayFactor = isIdle ? 0.1 : 1; 
        
        const baseRotation = THREE.MathUtils.lerp(cursorState.angle, targetBaseRotation, decayFactor);

        const velocityTilt = dx * 1.5; 
        const targetAngle = baseRotation + velocityTilt;
        
        cursorState.angle += (targetAngle - cursorState.angle) * 0.2; 


        if (cursorEl) {
            cursorEl.style.transform = `translate3d(${cursorState.x}px, ${cursorState.y}px, 0) translateX(-35%) rotate(${cursorState.angle}deg) scale(${cursorState.scale})`;
        }
        requestAnimationFrame(animateCursor);
    }
    animateCursor();

    function updateClock() {
        const d = new Date();
        let h = d.getHours(); const m = d.getMinutes();
        const ampm = h >= 12 ? 'PM' : 'AM';
        h = h % 12 || 12;
        const mStr = m < 10 ? '0'+m : m;
        document.getElementById('clock').innerHTML = `${h}:${mStr} <span style="font-size:0.4em; vertical-align: top;">${ampm}</span>`;
    }
    setInterval(updateClock, 1000);
    updateClock();
    updateBorders();

    const gui = new GUI({ autoPlace: false });
    document.getElementById('gui-container').appendChild(gui.domElement);
    const folder = gui.addFolder('Layout');
    folder.add(PARAMS, 'gridSpacing', 1, 3).onChange(updateGrid);
    folder.add(PARAMS, 'gridOffsetY', -5, 5).onChange(updateGrid);
    folder.add(PARAMS, 'splitHeight', 0.5, 1.0).onChange(updateBorders);
    
    folder.open();
  </script>
</body>
</html>