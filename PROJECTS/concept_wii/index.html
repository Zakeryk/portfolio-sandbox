<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wii Concept OS</title>
  <link rel="icon" type="image/png" href="assets/wiicursor_sprite.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&family=Orbitron:wght@400;700&display=swap" rel="stylesheet">

  <style>
    /* --- RESET --- */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body, html {
      width: 100%; height: 100%; overflow: hidden;
      background-color: #e0e0e0;
      font-family: 'Inter', sans-serif;
      cursor: none; 
      user-select: none;
    }

    /* --- LAYOUT --- */
    #scene-container {
      position: relative;
      width: 100%; height: 100%;
      z-index: 10;
    }

    #primary-panel {
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      background: linear-gradient(to bottom, #ffffff 0%, #f0f0f0 100%);
      clip-path: url(#panel-mask);
      -webkit-clip-path: url(#panel-mask);
      filter: drop-shadow(0px 10px 20px rgba(0,0,0,0.15));
      z-index: 1; 
    }

    #canvas-wrapper { width: 100%; height: 100%; display: block; }

    /* --- CLOCK --- */
    #clock {
      position: absolute; 
      bottom: 30px; 
      left: 50%;
      transform: translateX(-50%);
      font-family: 'Orbitron', sans-serif; 
      font-size: 4.8rem;
      color: #000000; 
      pointer-events: none;
      z-index: 30; 
      white-space: nowrap;
      opacity: 0.8;
    }

    #instructions {
      position: fixed; bottom: 20px; left: 20px;
      color: #888; font-size: 12px; z-index: 100;
      pointer-events: none; font-family: sans-serif;
    }

    /* --- CUSTOM CURSOR --- */
    #custom-cursor {
      position: fixed; top: 0; left: 0;
      pointer-events: none; z-index: 9999;
      will-change: transform;
      transform-origin: 0% 0%; 
      transition: opacity 0.2s ease;
    }
    
    #custom-cursor img { 
        display: block;
        width: 35px; /* ~20% smaller than standard 48px icons */
        height: auto;
    }

    #debug-hotspot {
      display: none;
      position: absolute; top: -2px; left: -2px;
      width: 4px; height: 4px;
      background: red; border-radius: 50%;
    }

    /* --- GUI CONTAINER --- */
    #gui-container {
        position: absolute;
        top: 0;
        right: 0;
        z-index: 10001;
        display: none; 
    }

    /* --- DEBUG MODE --- */
    body.debug-mode { cursor: auto !important; }
    body.debug-mode #gui-container { display: block; }
    body.debug-mode #debug-hotspot { display: block; }
    body.debug-mode #custom-cursor { opacity: 0.5; }

  </style>
</head>

<body>

  <svg style="position: absolute; width: 100%; height: 100%; pointer-events: none; z-index: 15; top: 0; left: 0;">
    <defs>
      <clipPath id="panel-mask" clipPathUnits="userSpaceOnUse">
        <path id="mask-path-el" d="" /> 
      </clipPath>
    </defs>
    <path id="border-path-el" fill="none" stroke="#7ec1d9" stroke-width="2" stroke-linecap="square" />
  </svg>

  <div id="scene-container">
    <div id="primary-panel">
      <div id="canvas-wrapper"></div>
    </div>
    <div id="clock">12:00</div>
    <div id="instructions">[~] Toggle Debug Config</div>
  </div>

  <div id="gui-container"></div>

  <div id="custom-cursor">
    <img src="assets/wiicursor_sprite.png" alt="cursor">
    <div id="debug-hotspot"></div>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
        "dat.gui": "https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.module.js"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry.js';
    import { GUI } from 'dat.gui';

    // --- CONFIG ---
    const PARAMS = {
        transitionDuration: 1000,
        camX: 0, camY: -1.5, camZ: 10,
        aimX: 0, aimY: -1.5, aimZ: 0,
        camZoom: 2.7,
        gridSpacing: 1.2, 
        gridOffsetX: 0.0, 
        gridOffsetY: -1.2,
        borderRadius: 0.018,
        activeSlot: 1,
        splitHeight: 0.85
    };

    // --- STATE ---
    const cursorState = { x: 0, y: 0, prevX: 0, targetX: 0, targetY: 0, angle: 0, scale: 1, targetScale: 1 };
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    let INTERSECTED = null;
    let cameraTween = null;

    // --- SETUP ---
    const container = document.getElementById('canvas-wrapper');
    const scene = new THREE.Scene();
    const aspect = container.clientWidth / container.clientHeight;
    const baseSize = 5;
    const camera = new THREE.OrthographicCamera(-aspect * baseSize, aspect * baseSize, baseSize, -baseSize, 0.1, 1000);
    camera.position.set(PARAMS.camX, PARAMS.camY, PARAMS.camZ);
    camera.zoom = PARAMS.camZoom;
    camera.updateProjectionMatrix();

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 1.6));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.8);
    dirLight.position.set(5, 10, 10);
    scene.add(dirLight);

    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();

    // --- BORDERS ---
    function updateBorders() {
        const w = window.innerWidth;
        const h = window.innerHeight;
        const splitY = h * PARAMS.splitHeight;
        document.getElementById('mask-path-el').setAttribute('d', `M 0,0 L ${w},0 L ${w},${splitY} L 0,${splitY} Z`);
        document.getElementById('border-path-el').setAttribute('d', `M 0,${splitY} L ${w},${splitY}`);
    }

    // --- GRID ---
    const COLS = 4; const ROWS = 3; const channelBlocks = [];
    const BLOCK_WIDTH = 1.12; 
    const BLOCK_HEIGHT = 0.72;

    for(let i=0; i<COLS*ROWS; i++) {
        const geo = new RoundedBoxGeometry(BLOCK_WIDTH, BLOCK_HEIGHT, 0.2, 4, PARAMS.borderRadius);
        const mat = new THREE.MeshPhongMaterial({ color: 0xffffff, specular: 0x555555, shininess: 40 });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.userData.index = i;
        
        // Physics props
        mesh.userData.velocity = new THREE.Vector3();
        mesh.userData.targetScale = new THREE.Vector3(1, 1, 1);
        
        scene.add(mesh);
        channelBlocks.push(mesh);
    }

    function updateLayout() {
        const gap = PARAMS.gridSpacing - BLOCK_WIDTH;
        const autoSpacingY = gap + BLOCK_HEIGHT;
        const totalW = (COLS - 1) * PARAMS.gridSpacing;
        const xOffset = -totalW / 2 + PARAMS.gridOffsetX;
        const yOffset = ((ROWS - 1) * autoSpacingY) / 2 + PARAMS.gridOffsetY;

        channelBlocks.forEach((b, i) => {
            const col = i % COLS;
            const row = Math.floor(i / COLS);
            b.position.set(xOffset + col * PARAMS.gridSpacing, yOffset - row * autoSpacingY, 0);
        });
    }
    updateLayout();

    // --- EVENTS ---
    window.addEventListener('resize', () => {
        const asp = container.clientWidth / container.clientHeight;
        camera.left = -asp * baseSize; camera.right = asp * baseSize;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
        updateBorders();
    });

    window.addEventListener('keydown', (e) => {
        if (e.key === '`' || e.key === '~') {
            document.body.classList.toggle('debug-mode');
        }
    });

    window.addEventListener('mousedown', (e) => {
        if (document.body.classList.contains('debug-mode') && e.target.closest('.dg')) return;
        
        if (INTERSECTED) { 
            cursorState.targetScale = 1.0; 
            return; 
        }
        
        isDragging = true;
        previousMousePosition = { x: e.clientX, y: e.clientY };
        cursorState.targetScale = 0.8; 
    });

    window.addEventListener('mouseup', () => {
        isDragging = false;
        cursorState.targetScale = INTERSECTED ? 1.3 : 1.0;
    });

    window.addEventListener('mousemove', (e) => {
        cursorState.targetX = e.clientX;
        cursorState.targetY = e.clientY;

        if (isDragging) {
            const dx = e.clientX - previousMousePosition.x;
            const dy = e.clientY - previousMousePosition.y;
            previousMousePosition = { x: e.clientX, y: e.clientY };
            const sens = 0.002 * PARAMS.camZoom;
            PARAMS.camX -= dx * sens;
            PARAMS.camY += dy * sens;
        }
        
        const rect = container.getBoundingClientRect();
        pointer.x = ((e.clientX - rect.left) / container.clientWidth) * 2 - 1;
        pointer.y = -((e.clientY - rect.top) / container.clientHeight) * 2 + 1;
    });

    // --- ANIMATION ---
    function animate() {
        requestAnimationFrame(animate);
        
        if (cameraTween) {
            let t = (performance.now() - cameraTween.startTime) / cameraTween.duration;
            if (t >= 1) { t = 1; cameraTween = null; }
            t = t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
            PARAMS.camX = THREE.MathUtils.lerp(cameraTween.start.camX, cameraTween.end.camX, t);
            PARAMS.camY = THREE.MathUtils.lerp(cameraTween.start.camY, cameraTween.end.camY, t);
            PARAMS.camZ = THREE.MathUtils.lerp(cameraTween.start.camZ, cameraTween.end.camZ, t);
        }

        camera.position.set(PARAMS.camX, PARAMS.camY, PARAMS.camZ);
        camera.lookAt(PARAMS.aimX, PARAMS.aimY, PARAMS.aimZ);

        raycaster.setFromCamera(pointer, camera);
        const intersects = raycaster.intersectObjects(channelBlocks, false);

        if (intersects.length > 0) {
            const target = intersects[0].object;
            if (INTERSECTED !== target) {
                if(INTERSECTED) INTERSECTED.material.emissive.setHex(0x000000);
                INTERSECTED = target;
                INTERSECTED.material.emissive.setHex(0x444444);
            }
        } else {
            if (INTERSECTED) {
                INTERSECTED.material.emissive.setHex(0x000000);
                INTERSECTED = null;
            }
        }

        // --- BLOCK PHYSICS ---
        // Lower tension = Slower start. Higher damping = Slower/Smoother settle.
        const SPRING_TENSION = 0.08; 
        const SPRING_DAMPING = 0.85; 
        const LERP_CLICK = 0.2; 

        channelBlocks.forEach(b => {
            let targetS = 1.0;
            let isClickingThis = false;

            if (b === INTERSECTED) {
                if (cursorState.targetScale <= 1.0) {
                    // Clicking on Tile
                    targetS = 0.95; 
                    isClickingThis = true;
                } else {
                    // Just Hovering
                    targetS = 1.05; 
                }
            }

            if (isClickingThis) {
                // Click: Sync with cursor (Linear)
                b.scale.lerp(new THREE.Vector3(targetS, targetS, targetS), LERP_CLICK);
                b.userData.velocity.set(0,0,0);
            } else {
                // Release/Hover: Soft Spring Physics
                const current = b.scale.x;
                const dist = targetS - current;
                
                b.userData.velocity.x += dist * SPRING_TENSION;
                b.userData.velocity.x *= SPRING_DAMPING;
                
                const nextS = current + b.userData.velocity.x;
                b.scale.set(nextS, nextS, nextS);
            }
        });

        renderer.render(scene, camera);
    }
    animate();

    // --- CURSOR PHYSICS LOOP ---
    const cursorEl = document.getElementById('custom-cursor');
    function animateCursor() {
        cursorState.x = cursorState.targetX;
        cursorState.y = cursorState.targetY;
        
        cursorState.scale += (cursorState.targetScale - cursorState.scale) * 0.2;
        
        if (cursorState.prevX === undefined) cursorState.prevX = cursorState.x;
        const dx = cursorState.x - cursorState.prevX;
        cursorState.prevX = cursorState.x;

        const baseRotation = isDragging ? 0 : -10;
        const velocityTilt = dx * 2.5; 
        const targetAngle = baseRotation + velocityTilt;
        
        cursorState.angle += (targetAngle - cursorState.angle) * 0.1;

        if (cursorEl) {
            cursorEl.style.transform = `translate3d(${cursorState.x}px, ${cursorState.y}px, 0) translateX(-35%) rotate(${cursorState.angle}deg) scale(${cursorState.scale})`;
        }
        requestAnimationFrame(animateCursor);
    }
    animateCursor();

    function updateClock() {
        const d = new Date();
        let h = d.getHours(); const m = d.getMinutes();
        const ampm = h >= 12 ? 'PM' : 'AM';
        h = h % 12 || 12;
        const mStr = m < 10 ? '0'+m : m;
        document.getElementById('clock').innerHTML = `${h}:${mStr} <span style="font-size:0.4em; vertical-align: top;">${ampm}</span>`;
    }
    setInterval(updateClock, 1000);
    updateClock();
    updateBorders();

    const gui = new GUI({ autoPlace: false });
    document.getElementById('gui-container').appendChild(gui.domElement);
    const folder = gui.addFolder('Layout');
    folder.add(PARAMS, 'gridSpacing', 1, 3).onChange(updateLayout);
    folder.add(PARAMS, 'gridOffsetY', -5, 5).onChange(updateLayout);
    folder.add(PARAMS, 'splitHeight', 0.5, 1.0).onChange(updateBorders);
    folder.open();
  </script>
</body>
</html>