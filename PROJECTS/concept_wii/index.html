<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>SELECT A DESTINATION</title>
    <link id="favicon" rel="icon" href="data:,">
    <script>
        (function () {
            const link = document.getElementById('favicon');
            function loadFavicon(src, isFallback = false) {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = 64; canvas.height = 64;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, 64, 64);
                    link.href = canvas.toDataURL();
                };
                img.onerror = () => {
                    dFavicon('./thumb.png', true);
                };
                img.src = src;
            }
            loadFavicon('./favicon.png');
        })();
    </script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&family=Orbitron:wght@400;700&display=swap"
        rel="stylesheet">

    <style>
        /* --- RESET & MOBILE FIXES --- */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            outline: none;
        }

        body,
        html {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #e0e0e0;
            font-family: 'Inter', sans-serif;
            cursor: none;
            user-select: none;
            -webkit-user-select: none;
            overscroll-behavior: none;
            touch-action: none;
        }

        /* --- CRT / GRAIN OVERLAY --- */
        #analog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9000;
            opacity: 0.2;
        }

        #scanlines {
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom,
                    rgba(255, 255, 255, 0),
                    rgba(255, 255, 255, 0) 50%,
                    rgba(0, 0, 0, 0.02) 50%,
                    /* FIXED: 0.02 Opacity */
                    rgba(0, 0, 0, 0.02));
            background-size: 100% 4px;
            position: absolute;
            top: 0;
            left: 0;
        }

        #noise {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('data:image/svg+xml,%3Csvg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg"%3E%3Cfilter id="noiseFilter"%3E%3CfeTurbulence type="fractalNoise" baseFrequency="0.85" numOctaves="3" stitchTiles="stitch"/%3E%3C/filter%3E%3Crect width="100%25" height="100%25" filter="url(%23noiseFilter)" opacity="0.15"/%3E%3C/svg%3E');
            opacity: 0.02;
            /* FIXED: 0.02 Opacity */
            mix-blend-mode: overlay;
            animation: noiseAnimation 2.5s linear infinite;
        }

        @keyframes noiseAnimation {
            0% {
                transform: translate(0, 0);
            }

            100% {
                transform: translate(0, 0);
            }
        }

        /* --- VERTICAL SCROLL HINT --- */
        @keyframes bobVertical {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(10px);
            }
        }

        #scroll-hint {
            position: fixed;
            top: 50%;
            right: -60px;
            transform: translateY(-50%);
            color: #7ec1d9;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.8rem;
            letter-spacing: 2px;
            z-index: 8000;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            opacity: 0;
            transition: right 0.6s cubic-bezier(0.2, 0.8, 0.2, 1), opacity 0.5s ease;
        }

        #scroll-hint.visible {
            right: 15px;
            opacity: 1;
        }

        #scroll-hint-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            animation: bobVertical 2s ease-in-out infinite;
        }

        #scroll-hint span {
            writing-mode: vertical-rl;
            text-orientation: mixed;
            transform: rotate(180deg);
        }

        #scroll-hint svg {
            width: 18px;
            height: 18px;
            fill: currentColor;
            margin-top: 5px;
        }

        /* --- RADIO PLAYER --- */
        #radio-player {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background-color: #f0f0f0;
            border: 2px solid #ffffff;
            padding: 8px 12px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 12px;
            z-index: 8500;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;

            transform: translateY(100px);
            opacity: 0;
            transition: transform 0.8s cubic-bezier(0.2, 0.8, 0.2, 1), opacity 0.8s ease;
        }

        #radio-player.slide-in {
            transform: translateY(0);
            opacity: 1;
        }

        /* MOBILE RADIO: BOTTOM CENTER */
        @media (max-width: 768px) {
            #radio-player {
                right: auto;
                left: 20px;
                bottom: auto;
                top: 20px;
                transform: translateY(-100px);
            }

            #radio-player.slide-in {
                transform: translateY(0);
            }
        }

        .radio-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .radio-btn {
            width: 20px;
            height: 20px;
            fill: #000;
            opacity: 0.6;
            transition: opacity 0.2s, transform 0.1s;
        }

        .radio-btn:hover {
            opacity: 1;
        }

        .radio-btn:active {
            transform: scale(0.86);
        }

        .eq-container {
            display: flex;
            gap: 2px;
            align-items: flex-end;
            height: 14px;
        }

        .eq-bar {
            width: 3px;
            background-color: #7ec1d9;
            animation: eq 0.8s ease-in-out infinite;
        }

        .eq-bar:nth-child(1) {
            height: 8px;
            animation-duration: 0.6s;
        }

        .eq-bar:nth-child(2) {
            height: 14px;
            animation-duration: 0.9s;
        }

        .eq-bar:nth-child(3) {
            height: 6px;
            animation-duration: 0.7s;
        }

        @keyframes eq {

            0%,
            100% {
                transform: scaleY(1);
            }

            50% {
                transform: scaleY(0.5);
            }
        }

        .player-stopped .eq-bar {
            animation: none;
            height: 3px;
        }

        .icon-play {
            display: none;
        }

        .icon-pause {
            display: block;
        }

        .player-stopped .icon-play {
            display: block;
        }

        .player-stopped .icon-pause {
            display: none;
        }

        #radio-info {
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        #radio-label {
            font-size: 0.55rem;
            color: #888;
            letter-spacing: 1px;
            line-height: 1;
            margin-bottom: 3px;
        }

        #radio-track {
            font-size: 0.7rem;
            font-weight: 700;
            line-height: 1;
        }

        /* --- PRELOADER --- */
        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        #preloader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #f0f0f0;
            color: #000000;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            z-index: 100000;
            opacity: 1;
            transition: opacity 0.5s ease;
        }

        #preloader.fade-out {
            opacity: 0;
            visibility: hidden;
        }

        #preloader-spinner {
            border: 4px solid #f0f0f0;
            border-top: 4px solid #7ec1d9;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        #preloader-text {
            color: #888;
            font-size: 0.8rem;
            margin-top: 10px;
            letter-spacing: 1px;
        }

        /* --- LAYOUT --- */
        #scene-container {
            position: relative;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        #primary-panel {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, #ffffff 0%, #f0f0f0 100%);
            clip-path: url(#panel-mask);
            -webkit-clip-path: url(#panel-mask);
            filter: drop-shadow(0px 10px 20px rgba(0, 0, 0, 0.15));
            z-index: 1;
        }

        #canvas-wrapper {
            width: 100%;
            height: 100%;
            display: block;
        }

        #tile-label-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 40;
        }

        /* --- CLOCK --- */
        #clock {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Orbitron', sans-serif;
            font-size: 3rem;
            color: #000000;
            pointer-events: none;
            z-index: 30;
            white-space: nowrap;
            opacity: 0.8;
        }

        #instructions {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: #888;
            font-size: 12px;
            z-index: 100;
            pointer-events: none;
            font-family: sans-serif;
        }

        /* --- CUSTOM CURSOR --- */
        #custom-cursor {
            position: fixed;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 9999;
            will-change: transform;
            transform-origin: 0% 0%;
            transition: opacity 0.2s ease;
        }

        #custom-cursor img {
            display: block;
            width: 60px;
            height: auto;
        }

        #debug-hotspot {
            display: none;
            position: absolute;
            top: -2px;
            left: -2px;
            width: 4px;
            height: 4px;
            background: red;
            border-radius: 50%;
        }

        /* --- GUI CONTAINER --- */
        #gui-container {
            position: absolute;
            top: 0;
            right: 0;
            z-index: 20000;
            display: none;
        }

        .tile-index-label {
            position: absolute;
            color: rgba(0, 0, 0, 0.4);
            font-size: 18px;
            font-weight: 700;
            z-index: 50;
            pointer-events: none;
            display: none;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);
        }

        .tile-hidden {
            display: none !important;
        }

        #footer-text {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            color: #888;
            letter-spacing: 1px;
            pointer-events: none;
            z-index: 30;
            opacity: 0.6;
            white-space: nowrap;
        }

        /* MOBILE ADJUSTMENTS */
        @media (max-width: 768px) {
            #custom-cursor {
                display: none !important;
            }

            body,
            html {
                cursor: auto;
            }

            #clock {
                font-size: 1.5rem;
                bottom: 35px;
            }

            #footer-text {
                bottom: 18px;
                font-size: 8px;
            }

            #instructions {
                display: none;
            }
        }

        /* DEBUG MODE TOGGLE */
        body.debug-mode {
            cursor: auto !important;
        }

        body.debug-mode #gui-container {
            display: block !important;
        }

        body.debug-mode #debug-hotspot {
            display: block;
        }

        body.debug-mode #custom-cursor {
            opacity: 0.5;
        }

        body.debug-mode .tile-index-label {
            display: block;
        }

        /* TILE VIDEO OVERLAY */
        #tile-video-overlay {
            position: absolute;
            pointer-events: none;
            z-index: 35;
            opacity: 0;
            transition: opacity 0.3s ease;
            overflow: hidden;
        }

        #tile-video-overlay video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #tile-video-overlay.playing {
            opacity: 1;
        }
    </style>
</head>

<body>
    <script>
        // ESC to return to portfolio if coming from sandbox
        if (document.referrer && document.referrer.includes('sandbox.zakknowlton.com')) {
            window.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') window.location.href = document.referrer;
            });
        }
    </script>

    <div id="preloader">
        <div id="preloader-spinner"></div>
        LOADING OS
        <div id="preloader-text">ZAK KNOWLTON &copy; 2026</div>
    </div>

    <div id="analog-overlay">
        <div id="scanlines"></div>
        <div id="noise"></div>
    </div>

    <div id="scroll-hint">
        <div id="scroll-hint-content">
            <span>SCROLL</span>
            <svg viewBox="0 0 24 24">
                <path d="M12 16l-6-6h12z" />
            </svg>
        </div>
    </div>

    <div id="radio-player">
        <div class="radio-controls">
            <div id="btn-toggle" class="radio-btn">
                <svg class="icon-play" viewBox="0 0 24 24">
                    <path d="M8 5v14l11-7z" />
                </svg>
                <svg class="icon-pause" viewBox="0 0 24 24">
                    <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z" />
                </svg>
            </div>
        </div>

        <div class="eq-container">
            <div class="eq-bar"></div>
            <div class="eq-bar"></div>
            <div class="eq-bar"></div>
        </div>

        <div id="radio-info">
            <span id="radio-label">PTASINSKI, RJ PASIN</span>
            <span id="radio-track">TOOTHPASTE</span>
        </div>
    </div>

    <svg style="position: absolute; width: 100%; height: 100%; pointer-events: none; z-index: 15; top: 0; left: 0;">
        <defs>
            <clipPath id="panel-mask" clipPathUnits="userSpaceOnUse">
                <path id="mask-path-el" d="" />
            </clipPath>
        </defs>
        <path id="border-path-el" fill="none" stroke="#7ec1d9" stroke-width="2" stroke-linecap="square" />
    </svg>

    <div id="scene-container">
        <div id="primary-panel">
            <div id="canvas-wrapper"></div>
        </div>
        <div id="tile-label-container"></div>
        <div id="tile-video-overlay">
            <video muted playsinline preload="auto">
                <source src="assets/anim_01.mp4" type="video/mp4">
            </video>
        </div>

        <div id="clock">12:00</div>
        <div id="footer-text">ZAK KNOWLTON &copy; 2026</div>
        <div id="instructions">[~] Toggle Debug Config</div>
    </div>

    <div id="gui-container"></div>

    <div id="custom-cursor">
        <img src="assets/wiicursor_sprite.png" alt="cursor">
        <div id="debug-hotspot"></div>
    </div>

    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
        "dat.gui": "https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.module.js"
      }
    }
  </script>

    <script type="module">
        import * as THREE from 'three';
        import { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry.js';
        import { GUI } from 'dat.gui';

        // --- DS-STYLE TAB ANIMATION WITH WAVES ---
        const baseTitle = 'SELECT A DESTINATION';
        const waveFrames = [
            '・ SELECT A DESTINATION',
            '∴ SELECT A DESTINATION',
            '∵ SELECT A DESTINATION',
            '≋ SELECT A DESTINATION',
            '∿ SELECT A DESTINATION',
            '〰 SELECT A DESTINATION',
            '～ SELECT A DESTINATION',
            '≈ SELECT A DESTINATION',
            '∼ SELECT A DESTINATION',
            '⋯ SELECT A DESTINATION',
            '⋰ SELECT A DESTINATION',
            '⋱ SELECT A DESTINATION',
            baseTitle,
            '◐ SELECT A DESTINATION',
            '◓ SELECT A DESTINATION',
            '◑ SELECT A DESTINATION',
            '◒ SELECT A DESTINATION',
            baseTitle,
            '⊹ SELECT A DESTINATION',
            '✦ SELECT A DESTINATION',
            '✧ SELECT A DESTINATION',
            '◆ SELECT A DESTINATION',
            baseTitle,
        ];

        let titleIndex = 0;
        let animPhase = 0;

        function animateTitle() {
            if (animPhase < waveFrames.length) {
                document.title = waveFrames[animPhase];
                animPhase++;
                setTimeout(animateTitle, 120);
            } else {
                // After intro, subtle wave pulse
                const pulseStates = [
                    baseTitle,
                    '～ ' + baseTitle,
                    '≋ ' + baseTitle,
                    '∿ ' + baseTitle,
                    baseTitle,
                    baseTitle,
                ];
                setInterval(() => {
                    document.title = pulseStates[titleIndex % pulseStates.length];
                    titleIndex++;
                }, 1800);
            }
        }

        setTimeout(animateTitle, 800);

        const ASSETS = {
            0: 'assets/anim_01_still.jpg',
            1: 'assets/channel_wii.jpg',
            2: null,
            3: null,
            4: null, 5: null, 6: null, 7: null, 8: null, 9: null, 10: null, 11: null,
        };

        const LINKS = {
            0: 'https://sandbox.zakknowlton.com',
            1: 'https://sandbox.zakknowlton.com/PROJECTS/concept_wii',
            2: null,
            3: null,
            4: null, 5: null, 6: null, 7: null, 8: null, 9: null, 10: null, 11: null
        };

        const PARAMS = {
            camX: 0, camY: -1.5, camZ: 10,
            aimX: 0, aimY: -1.5, aimZ: 0,
            camZoom: 2.7,
            gridSpacing: 1.2,
            gridOffsetX: 0.0,
            gridOffsetY: -1.2,
            borderRadius: 0.018,
            activeSlot: 1,
            splitHeight: 0.86,
            // tile 0 animation params
            animTriggerMode: 'hover', // 'hover' or 'interval'
            animFrequency: 4000,
            animEnabled: true,
            animBrightness: 0.73,
            animSaturation: 1.3,
            animSizeAdjust: 1.45,
            animBorderRadius: 150,
            animEdgeInset: 75,
            animTriggerNow: null // set after function is defined
        };

        const cursorState = {
            x: 0, y: 0, prevX: 0, targetX: 0, targetY: 0,
            angle: 0, scale: 1, targetScale: 1
        };

        let INTERSECTED = null;
        let cameraTween = null;
        let lastMoveTime = performance.now();
        let isMouseDown = false;
        let isMobile = false;

        let COLS = 4;
        let ROWS = 3;

        const scrollState = {
            current: 0,
            target: 0,
            max: 0,
            lastTouchY: 0,
            isScrolling: false
        };

        // --- RADIO LOGIC ---
        const audio = new Audio('assets/toothpaste.mp3');
        audio.loop = true;
        audio.volume = 0.15;

        const radioEl = document.getElementById('radio-player');
        const btnToggle = document.getElementById('btn-toggle');
        let isPlaying = true;

        radioEl.addEventListener('click', () => { togglePlay(); });

        function togglePlay() {
            if (isPlaying) {
                audio.pause();
                radioEl.classList.add('player-stopped');
            } else {
                audio.play().catch(e => console.log("Audio autoplay blocked:", e));
                radioEl.classList.remove('player-stopped');
            }
            isPlaying = !isPlaying;
        }

        window.addEventListener('load', () => {
            document.getElementById('preloader').classList.add('fade-out');

            if (isMobile) {
                setTimeout(() => {
                    if (scrollState.target < 0.2) {
                        document.getElementById('scroll-hint').classList.add('visible');
                    }
                }, 500);
            }

            setTimeout(() => {
                document.getElementById('radio-player').classList.add('slide-in');
                audio.play().catch(e => console.log("Audio autoplay blocked:", e));
            }, 1200);
        });


        // --- SETUP ---
        const container = document.getElementById('canvas-wrapper');
        const labelContainer = document.getElementById('tile-label-container');
        const scene = new THREE.Scene();
        const aspect = container.clientWidth / container.clientHeight;
        const baseSize = 5;
        const camera = new THREE.OrthographicCamera(-aspect * baseSize, aspect * baseSize, baseSize, -baseSize, 0.1, 1000);
        camera.position.set(PARAMS.camX, PARAMS.camY, PARAMS.camZ);
        camera.zoom = PARAMS.camZoom;
        camera.updateProjectionMatrix();

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 1.6));
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.8);
        dirLight.position.set(-5, 10, 10);
        scene.add(dirLight);

        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        const worldPosition = new THREE.Vector3();

        // --- BORDERS ---
        function updateBorders() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            // FIXED: Mobile split UP to 0.78
            const splitFactor = isMobile ? 0.88 : PARAMS.splitHeight;
            const splitY = h * splitFactor;
            document.getElementById('mask-path-el').setAttribute('d', `M 0,0 L ${w},0 L ${w},${splitY} L 0,${splitY} Z`);
            document.getElementById('border-path-el').setAttribute('d', `M 0,${splitY} L ${w},${splitY}`);
        }

        // --- GRID MANAGEMENT ---
        const textureLoader = new THREE.TextureLoader();
        const channelBlocks = [];
        const BASE_BLOCK_WIDTH = 1.12;
        const BASE_BLOCK_HEIGHT = 0.72;
        const MOBILE_SCALE_FACTOR = 1.35;
        const TILE_ASPECT = BASE_BLOCK_WIDTH / BASE_BLOCK_HEIGHT;
        const MAX_TILES = 12;

        for (let i = 0; i < MAX_TILES; i++) {
            const geo = new RoundedBoxGeometry(BASE_BLOCK_WIDTH, BASE_BLOCK_HEIGHT, 0.2, 4, PARAMS.borderRadius);
            let mat = new THREE.MeshPhongMaterial({
                color: 0xe0e0e0, specular: 0x222222, shininess: 10
            });

            if (ASSETS[i]) {
                textureLoader.load(ASSETS[i], (tex) => {
                    tex.colorSpace = THREE.SRGBColorSpace;
                    tex.wrapS = THREE.RepeatWrapping;
                    tex.wrapT = THREE.RepeatWrapping;

                    const ZOOM_FACTOR = i === 1 ? 0.97 : 0.9;
                    const imageAspect = tex.image.width / tex.image.height;
                    const tileAspect = TILE_ASPECT;

                    let rX = 1, rY = 1;
                    if (imageAspect / tileAspect > 1) {
                        rX = tileAspect / imageAspect;
                    } else {
                        rY = imageAspect / tileAspect;
                    }

                    tex.repeat.set(rX * ZOOM_FACTOR, rY * ZOOM_FACTOR);
                    tex.offset.set(
                        0.5 - (rX * ZOOM_FACTOR) / 2,
                        0.5 - (rY * ZOOM_FACTOR) / 2
                    );

                    mat.map = tex;
                    mat.needsUpdate = true;
                }, undefined, (err) => { mat.color.setHex(0xe0e0e0); mat.needsUpdate = true; });
            }

            const mesh = new THREE.Mesh(geo, mat);
            mesh.userData.index = i;
            mesh.userData.velocity = new THREE.Vector3();
            mesh.userData.targetScale = new THREE.Vector3(1, 1, 1);
            mesh.userData.wasClicked = false;
            mesh.userData.isSpringing = false;
            // Store base positions for magnetic effect
            mesh.userData.baseX = 0;
            mesh.userData.baseY = 0;

            scene.add(mesh);
            channelBlocks.push(mesh);

            const labelDiv = document.createElement('div');
            labelDiv.className = 'tile-index-label';
            labelDiv.textContent = i;
            labelContainer.appendChild(labelDiv);
            mesh.userData.label = labelDiv;
        }

        function updateGrid() {
            isMobile = window.innerWidth <= 768;

            if (isMobile) {
                COLS = 1;
                ROWS = MAX_TILES;
            } else {
                COLS = 4;
                ROWS = 3;
            }

            const scaleFactor = isMobile ? MOBILE_SCALE_FACTOR : 1.0;
            const limit = MAX_TILES;

            const gap = PARAMS.gridSpacing - BASE_BLOCK_WIDTH;
            const autoSpacingY = gap + BASE_BLOCK_HEIGHT;
            const totalContentHeight = (ROWS * autoSpacingY * scaleFactor);
            scrollState.max = isMobile ? Math.max(0, totalContentHeight - 3.5) : 0;

            channelBlocks.forEach((b, i) => {
                b.visible = true;
                if (b.userData.label) b.userData.label.classList.remove('tile-hidden');

                b.scale.set(scaleFactor, scaleFactor, 1);

                const totalW = (COLS - 1) * PARAMS.gridSpacing * scaleFactor;
                const xOffset = -totalW / 2 + PARAMS.gridOffsetX;
                // FIXED: Mobile Start Y adjusted to -0.4 (refined from -0.6)
                const startY = isMobile ? -0.4 : ((ROWS - 1) * autoSpacingY) / 2 + PARAMS.gridOffsetY;

                const col = i % COLS;
                const row = Math.floor(i / COLS);

                b.userData.baseX = xOffset + col * PARAMS.gridSpacing * scaleFactor;
                b.userData.baseY = startY - row * autoSpacingY * scaleFactor;

                b.position.set(b.userData.baseX, b.userData.baseY, 0);
            });
        }

        updateGrid();

        // --- TILE 0 VIDEO ANIMATION SYSTEM ---
        const videoOverlay = document.getElementById('tile-video-overlay');
        const videoEl = videoOverlay.querySelector('video');
        let animInterval = null;
        let isAnimPlaying = false;
        let isTile0Hovered = false;

        function updateVideoPosition() {
            if (!channelBlocks[0]) return;

            const tile = channelBlocks[0];
            tile.updateWorldMatrix(true, false);
            tile.getWorldPosition(worldPosition);

            const screenPos = worldPosition.clone();
            screenPos.project(camera);

            const x = (screenPos.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
            const y = (-screenPos.y * 0.5 + 0.5) * renderer.domElement.clientHeight;

            const scaleFactor = isMobile ? MOBILE_SCALE_FACTOR : 1.0;
            const visibleWidth = (camera.right - camera.left) / camera.zoom;
            const visibleHeight = (camera.top - camera.bottom) / camera.zoom;

            // calculate dimensions - size adjust is applied to match tile visually
            const baseWidthPx = (BASE_BLOCK_WIDTH * scaleFactor * tile.scale.x) * (renderer.domElement.clientWidth / visibleWidth);
            const baseHeightPx = (BASE_BLOCK_HEIGHT * scaleFactor * tile.scale.y) * (renderer.domElement.clientHeight / visibleHeight);

            const widthPx = baseWidthPx * PARAMS.animSizeAdjust;
            const heightPx = baseHeightPx * PARAMS.animSizeAdjust;

            // calculate border radius to match tile's rounded corners
            const radiusInWorldUnits = PARAMS.borderRadius * PARAMS.animBorderRadius;
            const borderRadiusPx = radiusInWorldUnits * scaleFactor * tile.scale.x * (renderer.domElement.clientWidth / visibleWidth) * PARAMS.animSizeAdjust;

            videoOverlay.style.left = `${x - widthPx / 2}px`;
            videoOverlay.style.top = `${y - heightPx / 2}px`;
            videoOverlay.style.width = `${widthPx}px`;
            videoOverlay.style.height = `${heightPx}px`;
            videoOverlay.style.borderRadius = `${borderRadiusPx}px`;

            // apply edge inset to pull video content away from edges uniformly
            if (PARAMS.animEdgeInset > 0) {
                videoEl.style.clipPath = `inset(${PARAMS.animEdgeInset}px round ${borderRadiusPx}px)`;
            } else {
                videoEl.style.clipPath = 'none';
            }
        }

        function triggerTileAnimation() {
            if (!PARAMS.animEnabled) return;

            if (!isAnimPlaying) {
                isAnimPlaying = true;
                videoOverlay.classList.add('playing');
                videoEl.currentTime = 0;
                videoEl.loop = PARAMS.animTriggerMode === 'hover';
                videoEl.play();
            }

            if (PARAMS.animTriggerMode !== 'hover') {
                videoEl.onended = () => {
                    videoOverlay.classList.remove('playing');
                    isAnimPlaying = false;
                };
            }
        }

        function stopTileAnimation() {
            if (isAnimPlaying) {
                videoEl.pause();
                videoEl.currentTime = 0;
                videoOverlay.classList.remove('playing');
                isAnimPlaying = false;
            }
        }

        function startAnimationLoop() {
            if (animInterval) clearInterval(animInterval);

            if (PARAMS.animEnabled && PARAMS.animTriggerMode === 'interval' && PARAMS.animFrequency > 0) {
                animInterval = setInterval(() => {
                    if (PARAMS.animEnabled) triggerTileAnimation();
                }, PARAMS.animFrequency);
            }
        }

        function updateAnimFilters() {
            videoEl.style.filter = `brightness(${PARAMS.animBrightness}) saturate(${PARAMS.animSaturation})`;
        }

        // now set the callback
        PARAMS.animTriggerNow = () => { triggerTileAnimation(); };

        // apply initial filters
        updateAnimFilters();

        startAnimationLoop();

        // --- INPUT & SCROLL LOGIC ---
        window.addEventListener('resize', () => {
            const asp = container.clientWidth / container.clientHeight;
            camera.left = -asp * baseSize; camera.right = asp * baseSize;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
            updateBorders();
            updateGrid();
        });

        window.addEventListener('keydown', (e) => {
            if (e.key === '`' || e.key === '~') {
                document.body.classList.toggle('debug-mode');
            }
        });

        window.addEventListener('mousedown', (e) => {
            if (isMobile || (document.body.classList.contains('debug-mode') && e.target.closest('.dg'))) return;
            isMouseDown = true;
            lastMoveTime = performance.now();
            cursorState.targetScale = 0.8;
        });

        window.addEventListener('mouseup', () => {
            if (isMobile) return;
            isMouseDown = false;
            lastMoveTime = performance.now();
            cursorState.targetScale = 1.0;

            if (INTERSECTED) {
                const targetLink = LINKS[INTERSECTED.userData.index];
                if (targetLink) setTimeout(() => { window.location.href = targetLink; }, 300);
                INTERSECTED.userData.wasClicked = true;
            }
        });

        window.addEventListener('mousemove', (e) => {
            if (isMobile) return;
            cursorState.targetX = e.clientX;
            cursorState.targetY = e.clientY;
            lastMoveTime = performance.now();

            const rect = container.getBoundingClientRect();
            pointer.x = ((e.clientX - rect.left) / container.clientWidth) * 2 - 1;
            pointer.y = -((e.clientY - rect.top) / container.clientHeight) * 2 + 1;
        });

        window.addEventListener('wheel', (e) => {
            if (isMobile) {
                scrollState.target += e.deltaY * 0.005;
                scrollState.target = Math.max(0, Math.min(scrollState.target, scrollState.max));

                if (scrollState.target < 0.2) {
                    document.getElementById('scroll-hint').classList.add('visible');
                } else {
                    document.getElementById('scroll-hint').classList.remove('visible');
                }
            }
        });

        window.addEventListener('touchstart', (e) => {
            if (!isMobile) return;
            // Removed unconditional hide


            scrollState.isScrolling = false;
            scrollState.lastTouchY = e.touches[0].clientY;

            const rect = container.getBoundingClientRect();
            pointer.x = ((e.touches[0].clientX - rect.left) / container.clientWidth) * 2 - 1;
            pointer.y = -((e.touches[0].clientY - rect.top) / container.clientHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(channelBlocks, false);

            if (intersects.length > 0) {
                INTERSECTED = intersects[0].object;
                isMouseDown = true;
            }
        }, { passive: false });

        window.addEventListener('touchmove', (e) => {
            if (!isMobile) return;
            const touchY = e.touches[0].clientY;
            const delta = scrollState.lastTouchY - touchY;

            if (Math.abs(delta) > 5) {
                scrollState.isScrolling = true;
                isMouseDown = false;
                INTERSECTED = null;
            }

            scrollState.target += delta * 0.018;
            scrollState.target = Math.max(0, Math.min(scrollState.target, scrollState.max));
            scrollState.lastTouchY = touchY;

            if (scrollState.target < 0.2) {
                document.getElementById('scroll-hint').classList.add('visible');
            } else {
                document.getElementById('scroll-hint').classList.remove('visible');
            }
        }, { passive: false });

        window.addEventListener('touchend', () => {
            if (!isMobile) return;

            if (!scrollState.isScrolling && INTERSECTED) {
                isMouseDown = false;

                INTERSECTED.userData.isSpringing = true;
                const popForce = 0.05;
                INTERSECTED.userData.velocity.x += popForce;

                const targetLink = LINKS[INTERSECTED.userData.index];
                if (targetLink) setTimeout(() => { window.location.href = targetLink; }, 300);
            }

            isMouseDown = false;
            setTimeout(() => { INTERSECTED = null; }, 300);
        });


        // --- ANIMATION ---
        function animate() {
            requestAnimationFrame(animate);

            if (isMobile) {
                scrollState.current += (scrollState.target - scrollState.current) * 0.1;
                camera.position.y = PARAMS.camY - scrollState.current;
            } else {
                camera.position.y = PARAMS.camY;
                scrollState.target = 0;
                scrollState.current = 0;
            }

            updateVideoPosition();

            if (!isMobile) {
                camera.lookAt(PARAMS.aimX, PARAMS.aimY, PARAMS.aimZ);
                raycaster.setFromCamera(pointer, camera);
                const intersects = raycaster.intersectObjects(channelBlocks, false);

                const DEFAULT_SHININESS = 10;
                const HOVER_SHININESS = 90;
                const DEFAULT_EMISSIVE = 0x000000;
                const HOVER_EMISSIVE = 0x555555;
                const LERP_FACTOR = 0.15;

                // MAGNETIC LOGIC
                let hoveredTile = null;
                const wasHoveringTile0 = isTile0Hovered;

                if (intersects.length > 0) {
                    hoveredTile = intersects[0].object;
                    const hitPoint = intersects[0].point;
                    const magX = hoveredTile.userData.baseX + (hitPoint.x - hoveredTile.userData.baseX) * 0.05;
                    const magY = hoveredTile.userData.baseY + (hitPoint.y - hoveredTile.userData.baseY) * 0.05;

                    hoveredTile.position.lerp(new THREE.Vector3(magX, magY, 0), 0.1);

                    // track tile 0 hover state
                    isTile0Hovered = hoveredTile.userData.index === 0;

                    if (INTERSECTED !== hoveredTile) {
                        INTERSECTED = hoveredTile;
                    }

                    // start animation when hovering tile 0
                    if (PARAMS.animTriggerMode === 'hover' && isTile0Hovered && !wasHoveringTile0) {
                        triggerTileAnimation();
                    }
                } else {
                    isTile0Hovered = false;
                    INTERSECTED = null;
                }

                // stop animation when leaving tile 0 (moved outside else block to ensure it always runs)
                if (PARAMS.animTriggerMode === 'hover' && wasHoveringTile0 && !isTile0Hovered) {
                    stopTileAnimation();
                }

                channelBlocks.forEach(b => {
                    if (b !== hoveredTile) {
                        b.position.lerp(new THREE.Vector3(b.userData.baseX, b.userData.baseY, 0), 0.1);
                    }

                    const currentlyHovered = b === INTERSECTED;
                    const hasImage = !!b.material.map;
                    // FIXED: Only glow if hovered AND no image
                    const shouldGlow = currentlyHovered && !hasImage;

                    const targetShin = shouldGlow ? HOVER_SHININESS : DEFAULT_SHININESS;
                    b.material.shininess += (targetShin - b.material.shininess) * LERP_FACTOR;
                    const currentEmissive = b.material.emissive;
                    const targetHex = shouldGlow ? HOVER_EMISSIVE : DEFAULT_EMISSIVE;
                    const targetColor = new THREE.Color(targetHex);
                    currentEmissive.lerp(targetColor, LERP_FACTOR);
                    b.material.needsUpdate = true;
                });
            }

            const SPRING_TENSION = isMobile ? 0.6 : 0.25;
            const SPRING_DAMPING = isMobile ? 0.5 : 0.80;
            const OVERSHOOT_SCALE = 1.03;
            const LERP_CLICK = isMobile ? 0.4 : 0.2;
            const LERP_NORMAL = 0.08;

            channelBlocks.forEach(b => {
                let targetS = 1.0;
                const activeTarget = INTERSECTED === b;

                if (activeTarget) {
                    if (isMouseDown) {
                        targetS = isMobile ? 0.99 : 0.95;
                        b.userData.isSpringing = false;
                        b.userData.velocity.set(0, 0, 0);
                    } else {
                        targetS = 1.05;
                        if (b.userData.wasClicked) {
                            b.userData.isSpringing = true;
                            const launchForce = OVERSHOOT_SCALE - b.scale.x;
                            b.userData.velocity.x += launchForce * 0.5;
                            b.userData.wasClicked = false;
                        }
                    }
                } else {
                    targetS = 1.0;
                    b.userData.wasClicked = false;
                }

                if (b.userData.isSpringing) {
                    const tension = SPRING_TENSION;
                    const damping = SPRING_DAMPING;
                    const dist = targetS - b.scale.x;
                    b.userData.velocity.x += dist * tension;
                    b.userData.velocity.x *= damping;

                    if (Math.abs(b.userData.velocity.x) < 0.001 && Math.abs(dist) < 0.005) {
                        b.userData.isSpringing = false;
                        b.scale.set(targetS, targetS, targetS);
                    } else {
                        const next = b.scale.x + b.userData.velocity.x;
                        b.scale.set(next, next, next);
                    }
                } else {
                    let lerpFactor = activeTarget && isMouseDown ? LERP_CLICK : LERP_NORMAL;
                    const scaleBase = isMobile ? MOBILE_SCALE_FACTOR : 1.0;
                    const finalTarget = targetS * scaleBase;
                    const currentX = b.scale.x;
                    const nextX = currentX + (finalTarget - currentX) * lerpFactor;
                    b.scale.set(nextX, nextX, 1);
                }

                b.updateWorldMatrix(true, false);
                b.getWorldPosition(worldPosition);
                const screenPosition = worldPosition.clone();
                screenPosition.project(camera);
                const x = (screenPosition.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
                const y = (-screenPosition.y * 0.5 + 0.5) * renderer.domElement.clientHeight;
                if (b.userData.label) {
                    b.userData.label.style.transform = `translate3d(${x}px, ${y}px, 0) translate(-50%, -50%) scale(${b.scale.x})`;
                }
            });

            renderer.render(scene, camera);
        }
        animate();

        const cursorEl = document.getElementById('custom-cursor');
        const IDLE_TIMEOUT = 300;

        function animateCursor() {
            if (isMobile) return;
            cursorState.x = cursorState.targetX;
            cursorState.y = cursorState.targetY;
            cursorState.scale += (cursorState.targetScale - cursorState.scale) * 0.2;

            if (cursorState.prevX === undefined) cursorState.prevX = cursorState.x;
            const dx = cursorState.x - cursorState.prevX;
            cursorState.prevX = cursorState.x;

            const isTrulyIdle = performance.now() - lastMoveTime > IDLE_TIMEOUT;
            const isIdle = isTrulyIdle && !isMouseDown;

            let targetBaseRotation = -10;
            if (isIdle) targetBaseRotation = 0;

            const decayFactor = isIdle ? 0.1 : 1;
            const baseRotation = THREE.MathUtils.lerp(cursorState.angle, targetBaseRotation, decayFactor);
            const velocityTilt = dx * 1.5;
            const targetAngle = baseRotation + velocityTilt;

            cursorState.angle += (targetAngle - cursorState.angle) * 0.2;

            if (cursorEl) {
                cursorEl.style.transform = `translate3d(${cursorState.x}px, ${cursorState.y}px, 0) translateX(-35%) rotate(${cursorState.angle}deg) scale(${cursorState.scale})`;
            }
            requestAnimationFrame(animateCursor);
        }
        animateCursor();

        function updateClock() {
            const d = new Date();
            let h = d.getHours(); const m = d.getMinutes();
            const ampm = h >= 12 ? 'PM' : 'AM';
            h = h % 12 || 12;
            const mStr = m < 10 ? '0' + m : m;
            document.getElementById('clock').innerHTML = `${h}:${mStr} <span style="font-size:0.4em; vertical-align: top;">${ampm}</span>`;
        }
        setInterval(updateClock, 1000);
        updateClock();
        updateBorders();

        // --- GUI SETUP ---
        const gui = new GUI({ autoPlace: false });
        document.getElementById('gui-container').appendChild(gui.domElement);

        const folder = gui.addFolder('Layout');
        folder.add(PARAMS, 'gridSpacing', 1, 3).onChange(updateGrid);
        folder.add(PARAMS, 'gridOffsetY', -5, 5).onChange(updateGrid);
        folder.add(PARAMS, 'splitHeight', 0.5, 1.0).onChange(updateBorders);
        folder.open();

        const animFolder = gui.addFolder('Tile 0 Animation');
        animFolder.add(PARAMS, 'animEnabled').name('Enable Animation');
        animFolder.add(PARAMS, 'animTriggerMode', ['hover', 'interval']).name('Trigger Mode').onChange(startAnimationLoop);
        animFolder.add(PARAMS, 'animFrequency', 1000, 30000).name('Interval (ms)').onChange(startAnimationLoop);
        animFolder.add(PARAMS, 'animBrightness', 0.5, 1.5).name('Brightness').onChange(updateAnimFilters);
        animFolder.add(PARAMS, 'animSaturation', 0.5, 2.0).name('Saturation').onChange(updateAnimFilters);
        animFolder.add(PARAMS, 'animSizeAdjust', 0.95, 3.0).name('Size Adjust');
        animFolder.add(PARAMS, 'animBorderRadius', 1, 150).name('Border Radius');
        animFolder.add(PARAMS, 'animEdgeInset', 0, 100).name('Edge Inset (px)');
        animFolder.add(PARAMS, 'animTriggerNow').name('▶ Trigger Now');
        animFolder.open();
    </script>
</body>

</html>