<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Wii Concept OS</title>
  <link rel="icon" type="image/png" href="assets/wiicursor_sprite.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&family=Orbitron:wght@400;700&display=swap" rel="stylesheet">

  <style>
    /* --- RESET & MOBILE FIXES --- */
    * { 
        margin: 0; padding: 0; box-sizing: border-box; 
        /* KILL THE BLUE HIGHLIGHT ON MOBILE TAP */
        -webkit-tap-highlight-color: transparent; 
        outline: none;
    }
    body, html {
      width: 100%; height: 100%; overflow: hidden;
      background-color: #e0e0e0;
      font-family: 'Inter', sans-serif;
      cursor: none; 
      user-select: none;
      -webkit-user-select: none; /* Safari/Chrome specific */
      overscroll-behavior: none;
      touch-action: none; 
    }

    /* --- CRT / GRAIN OVERLAY --- */
    #analog-overlay {
        position: fixed;
        top: 0; left: 0;
        width: 100%; height: 100%;
        pointer-events: none; 
        z-index: 9000;
        opacity: 1.0; 
    }

    #scanlines {
        width: 100%; height: 100%;
        background: linear-gradient(
            to bottom,
            rgba(255,255,255,0),
            rgba(255,255,255,0) 50%,
            rgba(0,0,0,0.02) 50%, 
            rgba(0,0,0,0.02)
        );
        background-size: 100% 4px;
        position: absolute;
        top: 0; left: 0;
    }

    #noise {
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        background-image: url('data:image/svg+xml,%3Csvg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg"%3E%3Cfilter id="noiseFilter"%3E%3CfeTurbulence type="fractalNoise" baseFrequency="0.85" numOctaves="3" stitchTiles="stitch"/%3E%3C/filter%3E%3Crect width="100%25" height="100%25" filter="url(%23noiseFilter)" opacity="0.15"/%3E%3C/svg%3E');
        opacity: 0.1; 
        mix-blend-mode: overlay;
        animation: noiseAnimation 2.5s linear infinite; 
    }

    @keyframes noiseAnimation {
        0% { transform: translate(0,0); }
        100% { transform: translate(0,0); }
    }

    /* --- SCROLL HINT --- */
    @keyframes bounceRight {
        0%, 100% { transform: translateX(0); }
        50% { transform: translateX(-10px); }
    }
    
    #scroll-hint {
        position: fixed;
        bottom: 30px;
        right: -100px; /* Start off screen */
        color: #7ec1d9; 
        font-family: 'Orbitron', sans-serif;
        font-size: 1rem;
        z-index: 8000;
        pointer-events: none;
        display: flex;
        align-items: center;
        gap: 10px;
        opacity: 0;
        transition: right 0.5s ease, opacity 0.5s ease;
    }
    
    #scroll-hint.visible {
        right: 20px;
        opacity: 1;
        animation: bounceRight 2s infinite;
    }
    
    #scroll-hint svg {
        width: 24px;
        height: 24px;
        fill: currentColor;
        transform: rotate(90deg); 
    }

    /* --- PRELOADER --- */
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    #preloader {
        position: fixed;
        top: 0; left: 0;
        width: 100%; height: 100%;
        background-color: #f0f0f0; 
        color: #000000;
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        font-family: 'Orbitron', sans-serif;
        font-size: 1.5rem;
        z-index: 100000;
        opacity: 1;
        transition: opacity 0.5s ease; 
    }

    #preloader.fade-out {
        opacity: 0;
        visibility: hidden;
    }

    #preloader-spinner {
        border: 4px solid #f0f0f0; 
        border-top: 4px solid #7ec1d9; 
        border-radius: 50%;
        width: 30px;
        height: 30px;
        animation: spin 1s linear infinite;
        margin-bottom: 20px;
    }

    #preloader-text {
        color: #888;
        font-size: 0.8rem;
        margin-top: 10px;
        letter-spacing: 1px;
    }

    /* --- LAYOUT --- */
    #scene-container {
      position: relative;
      width: 100%; height: 100%;
      z-index: 10;
    }

    #primary-panel {
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      background: linear-gradient(to bottom, #ffffff 0%, #f0f0f0 100%);
      clip-path: url(#panel-mask);
      -webkit-clip-path: url(#panel-mask);
      filter: drop-shadow(0px 10px 20px rgba(0,0,0,0.15));
      z-index: 1; 
    }

    #canvas-wrapper { width: 100%; height: 100%; display: block; }
    
    #tile-label-container {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        pointer-events: none; z-index: 40; 
    }

    /* --- CLOCK --- */
    #clock {
      position: absolute; 
      bottom: 30px; 
      left: 50%;
      transform: translateX(-50%);
      font-family: 'Orbitron', sans-serif; 
      font-size: 3rem;
      color: #000000; 
      pointer-events: none;
      z-index: 30; 
      white-space: nowrap;
      opacity: 0.8;
    }

    #instructions {
      position: fixed; bottom: 20px; left: 20px;
      color: #888; font-size: 12px; z-index: 100;
      pointer-events: none; font-family: sans-serif;
    }

    /* --- CUSTOM CURSOR --- */
    #custom-cursor {
      position: fixed; top: 0; left: 0;
      pointer-events: none; z-index: 9999;
      will-change: transform;
      transform-origin: 0% 0%; 
      transition: opacity 0.2s ease;
    }
    
    #custom-cursor img { 
        display: block;
        width: 60px; 
        height: auto;
    }

    #debug-hotspot {
      display: none;
      position: absolute; top: -2px; left: -2px;
      width: 4px; height: 4px;
      background: red; border-radius: 50%;
    }

    #gui-container {
        position: absolute;
        top: 0; right: 0; z-index: 10001; display: none; 
    }
    
    .tile-index-label {
        position: absolute;
        color: rgba(0, 0, 0, 0.4);
        font-size: 18px;
        font-weight: 700;
        z-index: 50; 
        pointer-events: none;
        display: none; 
        font-family: 'Orbitron', sans-serif;
        text-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);
    }
    
    .tile-hidden { display: none !important; }

    /* MOBILE ADJUSTMENTS */
    @media (max-width: 768px) {
        #custom-cursor { display: none !important; }
        body, html { cursor: auto; }
        
        #clock {
            font-size: 1.5rem; 
            bottom: 20px;
        }
        
        #instructions {
            display: none; 
        }
    }

    body.debug-mode { cursor: auto !important; }
    body.debug-mode #gui-container { display: block; }
    body.debug-mode #debug-hotspot { display: block; }
    body.debug-mode #custom-cursor { opacity: 0.5; }
    body.debug-mode .tile-index-label { display: block; } 

  </style>
</head>

<body>
    
  <div id="preloader">
      <div id="preloader-spinner"></div>
      LOADING OS
      <div id="preloader-text">ZAK KNOWLTON &copy; 2026</div>
  </div>

  <div id="analog-overlay">
      <div id="scanlines"></div>
      <div id="noise"></div>
  </div>
  
  <div id="scroll-hint">
      SCROLL
      <svg viewBox="0 0 24 24"><path d="M5 3l3.057-3 11.943 12-11.943 12-3.057-3 9-9z"/></svg>
  </div>

  <svg style="position: absolute; width: 100%; height: 100%; pointer-events: none; z-index: 15; top: 0; left: 0;">
    <defs>
      <clipPath id="panel-mask" clipPathUnits="userSpaceOnUse">
        <path id="mask-path-el" d="" /> 
      </clipPath>
    </defs>
    <path id="border-path-el" fill="none" stroke="#7ec1d9" stroke-width="2" stroke-linecap="square" />
  </svg>

  <div id="scene-container">
    <div id="primary-panel">
      <div id="canvas-wrapper"></div>
    </div>
    <div id="tile-label-container"></div> 
    
    <div id="clock">12:00</div>
    <div id="instructions">[~] Toggle Debug Config</div>
  </div>
  
  <div id="gui-container"></div>

  <div id="custom-cursor">
    <img src="assets/wiicursor_sprite.png" alt="cursor">
    <div id="debug-hotspot"></div>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
        "dat.gui": "https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.module.js"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry.js';
    import { GUI } from 'dat.gui';
    
    const ASSETS = {
        0: 'assets/channel_devil.jpg',
        1: 'assets/channel_wii.jpg',
        2: 'assets/channel_grassball.jpg',
        3: 'assets/channel_knot.jpg',
        4: null, 5: null, 6: null, 7: null, 8: null, 9: null, 10: null, 11: null,
    };
    
    const LINKS = {
        0: 'https://sandbox.zakknowlton.com/projects/concept_devil', 
        1: 'https://sandbox.zakknowlton.com/projects/concept_wii', 
        2: 'https://sandbox.zakknowlton.com/projects/concept_grassball',
        3: 'https://sandbox.zakknowlton.com/projects/concept_knot',
        4: null, 5: null, 6: null, 7: null, 8: null, 9: null, 10: null, 11: null
    };

    const PARAMS = {
        camX: 0, camY: -1.5, camZ: 10,
        aimX: 0, aimY: -1.5, aimZ: 0,
        camZoom: 2.7,
        gridSpacing: 1.2, 
        gridOffsetX: 0.0, 
        gridOffsetY: -1.2,
        borderRadius: 0.018,
        activeSlot: 1,
        splitHeight: 0.85,
    };

    const cursorState = { 
        x: 0, y: 0, prevX: 0, targetX: 0, targetY: 0, 
        angle: 0, scale: 1, targetScale: 1 
    };
    
    let INTERSECTED = null;
    let cameraTween = null;
    let lastMoveTime = performance.now(); 
    let isMouseDown = false; 
    let isMobile = false; 
    
    let COLS = 4; 
    let ROWS = 3; 
    
    const scrollState = {
        current: 0,
        target: 0,
        max: 0,
        lastTouchY: 0,
        isScrolling: false
    };

    // --- SETUP ---
    const container = document.getElementById('canvas-wrapper');
    const labelContainer = document.getElementById('tile-label-container');
    const scene = new THREE.Scene();
    const aspect = container.clientWidth / container.clientHeight;
    const baseSize = 5;
    const camera = new THREE.OrthographicCamera(-aspect * baseSize, aspect * baseSize, baseSize, -baseSize, 0.1, 1000);
    camera.position.set(PARAMS.camX, PARAMS.camY, PARAMS.camZ);
    camera.zoom = PARAMS.camZoom;
    camera.updateProjectionMatrix();

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);
    
    scene.add(new THREE.AmbientLight(0xffffff, 1.6));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.8);
    dirLight.position.set(5, 10, 10);
    scene.add(dirLight);

    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();
    const worldPosition = new THREE.Vector3(); 

    // --- BORDERS ---
    function updateBorders() {
        const w = window.innerWidth;
        const h = window.innerHeight;
        const splitY = h * PARAMS.splitHeight;
        document.getElementById('mask-path-el').setAttribute('d', `M 0,0 L ${w},0 L ${w},${splitY} L 0,${splitY} Z`);
        document.getElementById('border-path-el').setAttribute('d', `M 0,${splitY} L ${w},${splitY}`);
    }

    // --- GRID MANAGEMENT ---
    const textureLoader = new THREE.TextureLoader();
    const channelBlocks = []; 
    const BASE_BLOCK_WIDTH = 1.12; 
    const BASE_BLOCK_HEIGHT = 0.72;
    const MOBILE_SCALE_FACTOR = 1.35; 
    const TILE_ASPECT = BASE_BLOCK_WIDTH / BASE_BLOCK_HEIGHT;
    const MAX_TILES = 12;
    
    for(let i=0; i<MAX_TILES; i++) {
        const geo = new RoundedBoxGeometry(BASE_BLOCK_WIDTH, BASE_BLOCK_HEIGHT, 0.2, 4, PARAMS.borderRadius);
        let mat = new THREE.MeshPhongMaterial({ 
            color: 0xe0e0e0, specular: 0x222222, shininess: 10 
        });
        
        if (ASSETS[i]) {
            textureLoader.load(ASSETS[i], (tex) => {
                tex.colorSpace = THREE.SRGBColorSpace; 
                tex.wrapS = THREE.RepeatWrapping; 
                tex.wrapT = THREE.RepeatWrapping;
                const imageAspect = tex.image.width / tex.image.height;
                const tileAspect = TILE_ASPECT;
                if (imageAspect / tileAspect > 1) {
                    tex.repeat.set(tileAspect / imageAspect, 1);
                    tex.offset.set((1 - (tileAspect / imageAspect)) / 2, 0);
                } else {
                    tex.repeat.set(1, imageAspect / tileAspect);
                    tex.offset.set(0, (1 - (imageAspect / tileAspect)) / 2);
                }
                mat.map = tex;
                mat.needsUpdate = true;
            }, undefined, (err) => { mat.color.setHex(0xe0e0e0); mat.needsUpdate = true; });
        }

        const mesh = new THREE.Mesh(geo, mat);
        mesh.userData.index = i;
        mesh.userData.velocity = new THREE.Vector3();
        mesh.userData.targetScale = new THREE.Vector3(1, 1, 1);
        mesh.userData.wasClicked = false; 
        mesh.userData.isSpringing = false; 
        
        scene.add(mesh);
        channelBlocks.push(mesh);

        const labelDiv = document.createElement('div');
        labelDiv.className = 'tile-index-label';
        labelDiv.textContent = i;
        labelContainer.appendChild(labelDiv);
        mesh.userData.label = labelDiv; 
    }

    function updateGrid() {
        isMobile = window.innerWidth <= 768;
        
        if (isMobile) {
            COLS = 1;
            ROWS = MAX_TILES; 
        } else {
            COLS = 4;
            ROWS = 3;
        }
        
        const scaleFactor = isMobile ? MOBILE_SCALE_FACTOR : 1.0;
        const limit = MAX_TILES; 

        const gap = PARAMS.gridSpacing - BASE_BLOCK_WIDTH;
        const autoSpacingY = gap + BASE_BLOCK_HEIGHT;
        const totalContentHeight = (ROWS * autoSpacingY * scaleFactor);
        scrollState.max = isMobile ? Math.max(0, totalContentHeight - 3.5) : 0; 

        channelBlocks.forEach((b, i) => {
            b.visible = true;
            if (b.userData.label) b.userData.label.classList.remove('tile-hidden');
            
            b.scale.set(scaleFactor, scaleFactor, 1); 
            
            const totalW = (COLS - 1) * PARAMS.gridSpacing * scaleFactor;
            const xOffset = -totalW / 2 + PARAMS.gridOffsetX;
            const startY = isMobile ? 1.0 : ((ROWS - 1) * autoSpacingY) / 2 + PARAMS.gridOffsetY;
            
            const col = i % COLS;
            const row = Math.floor(i / COLS);

            b.userData.baseY = startY - row * autoSpacingY * scaleFactor;
            b.position.set(xOffset + col * PARAMS.gridSpacing * scaleFactor, b.userData.baseY, 0);
        });
    }
    
    updateGrid(); 

    window.addEventListener('load', () => {
        document.getElementById('preloader').classList.add('fade-out');
        if(isMobile) {
            setTimeout(() => {
                document.getElementById('scroll-hint').classList.add('visible');
            }, 500);
        }
    });

    // --- INPUT & SCROLL LOGIC ---
    window.addEventListener('resize', () => {
        const asp = container.clientWidth / container.clientHeight;
        camera.left = -asp * baseSize; camera.right = asp * baseSize;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
        updateBorders();
        updateGrid(); 
    });

    window.addEventListener('mousedown', (e) => {
        if (isMobile || (document.body.classList.contains('debug-mode') && e.target.closest('.dg'))) return;
        isMouseDown = true; 
        lastMoveTime = performance.now(); 
        cursorState.targetScale = 0.8; 
    });

    window.addEventListener('mouseup', () => {
        if (isMobile) return;
        isMouseDown = false; 
        lastMoveTime = performance.now(); 
        cursorState.targetScale = 1.0; 
        
        if (INTERSECTED) { 
            const targetLink = LINKS[INTERSECTED.userData.index];
            if (targetLink) setTimeout(() => { window.location.href = targetLink; }, 300); 
            INTERSECTED.userData.wasClicked = true; 
        } 
    });

    window.addEventListener('mousemove', (e) => {
        if (isMobile) return;
        cursorState.targetX = e.clientX;
        cursorState.targetY = e.clientY;
        lastMoveTime = performance.now(); 
        
        const rect = container.getBoundingClientRect();
        pointer.x = ((e.clientX - rect.left) / container.clientWidth) * 2 - 1;
        pointer.y = -((e.clientY - rect.top) / container.clientHeight) * 2 + 1;
    });

    window.addEventListener('wheel', (e) => {
        if (isMobile) {
            document.getElementById('scroll-hint').classList.remove('visible');
            scrollState.target += e.deltaY * 0.005;
            scrollState.target = Math.max(0, Math.min(scrollState.target, scrollState.max));
        }
    });

    // --- MOBILE TAP & SCROLL LOGIC (FIXED) ---
    window.addEventListener('touchstart', (e) => {
        if (!isMobile) return;
        
        document.getElementById('scroll-hint').classList.remove('visible');
        
        scrollState.isScrolling = false;
        scrollState.lastTouchY = e.touches[0].clientY;
        
        const rect = container.getBoundingClientRect();
        pointer.x = ((e.touches[0].clientX - rect.left) / container.clientWidth) * 2 - 1;
        pointer.y = -((e.touches[0].clientY - rect.top) / container.clientHeight) * 2 + 1;
        
        raycaster.setFromCamera(pointer, camera);
        const intersects = raycaster.intersectObjects(channelBlocks, false);
        
        if (intersects.length > 0) {
            INTERSECTED = intersects[0].object;
            isMouseDown = true; // Trigger shrink
        }
    }, { passive: false });

    window.addEventListener('touchmove', (e) => {
        if (!isMobile) return;
        const touchY = e.touches[0].clientY;
        const delta = scrollState.lastTouchY - touchY;
        
        if (Math.abs(delta) > 5) {
            scrollState.isScrolling = true;
            isMouseDown = false; // Cancel shrink
            INTERSECTED = null;
        }
        
        scrollState.target += delta * 0.01; 
        scrollState.target = Math.max(0, Math.min(scrollState.target, scrollState.max));
        scrollState.lastTouchY = touchY;
    }, { passive: false });

    window.addEventListener('touchend', () => {
        if (!isMobile) return;
        
        if (!scrollState.isScrolling && INTERSECTED) {
            // It was a tap!
            
            // 1. Trigger Physics POP immediately
            INTERSECTED.userData.isSpringing = true;
            
            // 2. Force velocity for the pop (since we are releasing)
            // Overshoot Scale (1.03) - Current Scale (~0.95 scaled)
            // We give it a kick to simulate the release
            const popForce = 0.1; 
            INTERSECTED.userData.velocity.x += popForce;
            
            // 3. Navigate
            const targetLink = LINKS[INTERSECTED.userData.index];
            if (targetLink) setTimeout(() => { window.location.href = targetLink; }, 300);
        }
        
        // Reset Global State
        isMouseDown = false;
        
        // Note: We do NOT null INTERSECTED immediately here to allow the spring to run
        // The physics loop will handle it, or the next touchstart will reset INTERSECTED
        setTimeout(() => { INTERSECTED = null; }, 300); // Cleanup after animation
    });


    // --- ANIMATION ---
    function animate() {
        requestAnimationFrame(animate);
        
        if (isMobile) {
            scrollState.current += (scrollState.target - scrollState.current) * 0.1;
            camera.position.y = PARAMS.camY - scrollState.current;
        } else {
            camera.position.y = PARAMS.camY;
            scrollState.target = 0;
            scrollState.current = 0;
        }

        if(!isMobile) {
            camera.lookAt(PARAMS.aimX, PARAMS.aimY, PARAMS.aimZ);
            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(channelBlocks, false);
            
            const DEFAULT_SHININESS = 10;
            const HOVER_SHININESS = 90;
            const DEFAULT_EMISSIVE = 0x000000;
            const HOVER_EMISSIVE = 0x555555; 
            const LERP_FACTOR = 0.15;

            if (intersects.length > 0) {
                const target = intersects[0].object;
                if (INTERSECTED !== target) INTERSECTED = target;
            } else {
                INTERSECTED = null;
            }
            
            channelBlocks.forEach(b => {
                const currentlyHovered = b === INTERSECTED;
                const targetShin = currentlyHovered ? HOVER_SHININESS : DEFAULT_SHININESS;
                b.material.shininess += (targetShin - b.material.shininess) * LERP_FACTOR;
                const currentEmissive = b.material.emissive;
                const targetHex = currentlyHovered ? HOVER_EMISSIVE : DEFAULT_EMISSIVE;
                const targetColor = new THREE.Color(targetHex);
                currentEmissive.lerp(targetColor, LERP_FACTOR);
                b.material.needsUpdate = true;
            });
        }

        const SPRING_TENSION = 0.14; 
        const SPRING_DAMPING = 0.85; 
        const OVERSHOOT_SCALE = 1.03; 
        const LERP_CLICK = 0.2; 
        const LERP_NORMAL = 0.08; 

        channelBlocks.forEach(b => {
            let targetS = 1.0;
            const activeTarget = INTERSECTED === b; 

            if (activeTarget) {
                if (isMouseDown) {
                    targetS = 0.95; 
                    b.userData.isSpringing = false; 
                    b.userData.velocity.set(0,0,0);
                } else {
                    targetS = 1.05; 
                    if (b.userData.wasClicked) {
                        b.userData.isSpringing = true;
                        const launchForce = OVERSHOOT_SCALE - b.scale.x;
                        b.userData.velocity.x += launchForce * 0.5; 
                        b.userData.wasClicked = false; 
                    }
                }
            } else {
                targetS = 1.0; 
                b.userData.wasClicked = false; 
            }
            
            if (b.userData.isSpringing) {
                const tension = SPRING_TENSION; 
                const damping = SPRING_DAMPING; 
                const dist = targetS - b.scale.x;
                b.userData.velocity.x += dist * tension;
                b.userData.velocity.x *= damping;
                
                if (Math.abs(b.userData.velocity.x) < 0.001 && Math.abs(dist) < 0.005) {
                    b.userData.isSpringing = false;
                    b.scale.set(targetS, targetS, targetS);
                } else {
                    const next = b.scale.x + b.userData.velocity.x;
                    b.scale.set(next, next, next);
                }
            } else {
                let lerpFactor = activeTarget && isMouseDown ? LERP_CLICK : LERP_NORMAL;
                const scaleBase = isMobile ? MOBILE_SCALE_FACTOR : 1.0;
                // Important: Scale physics relative to base size
                const finalTarget = targetS * scaleBase;
                
                // Manual Lerp for smoothness
                const currentX = b.scale.x;
                const nextX = currentX + (finalTarget - currentX) * lerpFactor;
                b.scale.set(nextX, nextX, 1);
            }
            
            b.updateWorldMatrix(true, false);
            b.getWorldPosition(worldPosition);
            const screenPosition = worldPosition.clone();
            screenPosition.project(camera);
            const x = (screenPosition.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
            const y = (-screenPosition.y * 0.5 + 0.5) * renderer.domElement.clientHeight;
            if(b.userData.label) {
                b.userData.label.style.transform = `translate3d(${x}px, ${y}px, 0) translate(-50%, -50%) scale(${b.scale.x})`;
            }
        });

        renderer.render(scene, camera);
    }
    animate();

    const cursorEl = document.getElementById('custom-cursor');
    const IDLE_TIMEOUT = 300; 

    function animateCursor() {
        if (isMobile) return; 
        cursorState.x = cursorState.targetX;
        cursorState.y = cursorState.targetY;
        cursorState.scale += (cursorState.targetScale - cursorState.scale) * 0.2;
        
        if (cursorState.prevX === undefined) cursorState.prevX = cursorState.x;
        const dx = cursorState.x - cursorState.prevX;
        cursorState.prevX = cursorState.x;

        const isTrulyIdle = performance.now() - lastMoveTime > IDLE_TIMEOUT;
        const isIdle = isTrulyIdle && !isMouseDown; 
        
        let targetBaseRotation = -10; 
        if (isIdle) targetBaseRotation = 0; 
        
        const decayFactor = isIdle ? 0.1 : 1; 
        const baseRotation = THREE.MathUtils.lerp(cursorState.angle, targetBaseRotation, decayFactor);
        const velocityTilt = dx * 1.5; 
        const targetAngle = baseRotation + velocityTilt;
        
        cursorState.angle += (targetAngle - cursorState.angle) * 0.2; 

        if (cursorEl) {
            cursorEl.style.transform = `translate3d(${cursorState.x}px, ${cursorState.y}px, 0) translateX(-35%) rotate(${cursorState.angle}deg) scale(${cursorState.scale})`;
        }
        requestAnimationFrame(animateCursor);
    }
    animateCursor();

    function updateClock() {
        const d = new Date();
        let h = d.getHours(); const m = d.getMinutes();
        const ampm = h >= 12 ? 'PM' : 'AM';
        h = h % 12 || 12;
        const mStr = m < 10 ? '0'+m : m;
        document.getElementById('clock').innerHTML = `${h}:${mStr} <span style="font-size:0.4em; vertical-align: top;">${ampm}</span>`;
    }
    setInterval(updateClock, 1000);
    updateClock();
    updateBorders();

    const gui = new GUI({ autoPlace: false });
    document.getElementById('gui-container').appendChild(gui.domElement);
    const folder = gui.addFolder('Layout');
    folder.add(PARAMS, 'gridSpacing', 1, 3).onChange(updateGrid);
    folder.add(PARAMS, 'gridOffsetY', -5, 5).onChange(updateGrid);
    folder.add(PARAMS, 'splitHeight', 0.5, 1.0).onChange(updateBorders);
    
    folder.open();
  </script>
</body>
</html>