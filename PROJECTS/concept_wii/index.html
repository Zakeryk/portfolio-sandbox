<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wii Concept OS</title>
  <link rel="icon" type="image/png" href="assets/wiicursor_sprite.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&family=Orbitron:wght@400;700&display=swap" rel="stylesheet">

  <style>
    /* --- RESET --- */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body, html {
      width: 100%; height: 100%; overflow: hidden;
      background-color: #e0e0e0;
      font-family: 'Inter', sans-serif;
      cursor: none; 
      user-select: none;
    }

    /* --- BARBA SETUP (REQUIRED) --- */
    [data-barba="wrapper"], [data-barba="container"] {
        width: 100%;
        height: 100%;
        position: relative;
    }

    /* --- BARBA LOADING SCREEN --- */
    #loading-screen {
        position: fixed;
        top: 0; left: 0;
        width: 100%; height: 100%;
        background-color: #7ec1d9; /* Wii blue/cyan */
        color: #ffffff;
        display: flex;
        justify-content: center;
        align-items: center;
        font-family: 'Orbitron', sans-serif;
        font-size: 2rem;
        opacity: 0; /* Hidden by default */
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0.3s ease;
        z-index: 10000;
    }
    #loading-screen.is-visible {
        opacity: 1;
        visibility: visible;
    }

    /* --- LAYOUT --- */
    #scene-container {
      position: relative;
      width: 100%; height: 100%;
      z-index: 10;
    }

    #primary-panel {
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      background: linear-gradient(to bottom, #ffffff 0%, #f0f0f0 100%);
      clip-path: url(#panel-mask);
      -webkit-clip-path: url(#panel-mask);
      filter: drop-shadow(0px 10px 20px rgba(0,0,0,0.15));
      z-index: 1; 
    }

    #canvas-wrapper { width: 100%; height: 100%; display: block; }
    
    /* --- TILE LABEL CONTAINER STYLE --- */
    #tile-label-container {
        position: absolute;
        top: 0; 
        left: 0; 
        width: 100%; 
        height: 100%;
        pointer-events: none; /* Crucial to let mouse events pass to the canvas */
        z-index: 40; 
    }

    /* --- CLOCK --- */
    #clock {
      position: absolute; 
      bottom: 30px; 
      left: 50%;
      transform: translateX(-50%);
      font-family: 'Orbitron', sans-serif; 
      font-size: 4.8rem;
      color: #000000; 
      pointer-events: none;
      z-index: 30; 
      white-space: nowrap;
      opacity: 0.8;
    }

    #instructions {
      position: fixed; bottom: 20px; left: 20px;
      color: #888; font-size: 12px; z-index: 100;
      pointer-events: none; font-family: sans-serif;
    }

    /* --- CUSTOM CURSOR --- */
    #custom-cursor {
      position: fixed; top: 0; left: 0;
      pointer-events: none; z-index: 9999;
      will-change: transform;
      transform-origin: 0% 0%; 
      transition: opacity 0.2s ease;
    }
    
    #custom-cursor img { 
        display: block;
        width: 60px; 
        height: auto;
    }

    #debug-hotspot {
      display: none;
      position: absolute; top: -2px; left: -2px;
      width: 4px; height: 4px;
      background: red; border-radius: 50%;
    }

    /* --- GUI CONTAINER --- */
    #gui-container {
        position: absolute;
        top: 0;
        right: 0;
        z-index: 10001;
        display: none; 
    }
    
    /* --- TILE INDEX LABEL --- */
    .tile-index-label {
        position: absolute;
        color: rgba(0, 0, 0, 0.4);
        font-size: 18px;
        font-weight: 700;
        z-index: 50; 
        pointer-events: none;
        display: none; 
        font-family: 'Orbitron', sans-serif;
        text-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);
    }

    /* --- DEBUG MODE --- */
    body.debug-mode { cursor: auto !important; }
    body.debug-mode #gui-container { display: block; }
    body.debug-mode #debug-hotspot { display: block; }
    body.debug-mode #custom-cursor { opacity: 0.5; }
    body.debug-mode .tile-index-label { display: block; } 

  </style>
</head>

<body>

  <div id="barba-wrapper" data-barba="wrapper">
    <div data-barba="container" data-barba-namespace="home">
    
      <svg style="position: absolute; width: 100%; height: 100%; pointer-events: none; z-index: 15; top: 0; left: 0;">
        <defs>
          <clipPath id="panel-mask" clipPathUnits="userSpaceOnUse">
            <path id="mask-path-el" d="" /> 
          </clipPath>
        </defs>
        <path id="border-path-el" fill="none" stroke="#7ec1d9" stroke-width="2" stroke-linecap="square" />
      </svg>

      <div id="scene-container">
        <div id="primary-panel">
          <div id="canvas-wrapper"></div>
        </div>
        <div id="tile-label-container"></div> 
        
        <div id="clock">12:00</div>
        <div id="instructions">[~] Toggle Debug Config</div>
      </div>
      
    </div>
  </div>
  
  <div id="loading-screen">Loading...</div> <div id="gui-container"></div>

  <div id="custom-cursor">
    <img src="assets/wiicursor_sprite.png" alt="cursor">
    <div id="debug-hotspot"></div>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
        "dat.gui": "https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.module.js",
        "barba": "https://cdn.jsdelivr.net/npm/@barba/core@2.9.7/dist/barba.umd.js"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry.js';
    import { GUI } from 'dat.gui';
    import barba from 'barba'; // Imported Barba

    // --- ASSETS: TILE IMAGE MAPPING ---
    const ASSETS = {
        0: 'assets/channel_devil.jpg',
        1: 'assets/channel_wii.jpg',
        2: 'assets/channel_grassball.jpg',
        3: 'assets/channel_knot.jpg',
        4: null, 
        5: null,
        6: null,
        7: null,
        8: null,
        9: null,
        10: null,
        11: null,
    };
    
    // --- LINKS: TILE NAVIGATION MAPPING (NEW) ---
    const LINKS = {
        0: 'https://google.com', 
        1: '/local/wii.html', // Target a local page for Barba transition
        2: 'https://duckduckgo.com',
        3: '/local/knot.html',
        // Channels 4-11 have no link
    };

    // --- CONFIG ---
    const PARAMS = {
        transitionDuration: 1000,
        camX: 0, camY: -1.5, camZ: 10,
        aimX: 0, aimY: -1.5, aimZ: 0,
        camZoom: 2.7,
        gridSpacing: 1.2, 
        gridOffsetX: 0.0, 
        gridOffsetY: -1.2,
        borderRadius: 0.018,
        activeSlot: 1,
        splitHeight: 0.85
    };

    // --- STATE ---
    const cursorState = { 
        x: 0, y: 0, 
        prevX: 0, targetX: 0, targetY: 0, 
        angle: 0, 
        scale: 1, targetScale: 1 
    };
    
    let INTERSECTED = null;
    let cameraTween = null;
    let lastMoveTime = performance.now(); 
    let isMouseDown = false; // Track raw mouse state

    // --- SETUP ---
    const container = document.getElementById('canvas-wrapper');
    const labelContainer = document.getElementById('tile-label-container');
    const scene = new THREE.Scene();
    const aspect = container.clientWidth / container.clientHeight;
    const baseSize = 5;
    const camera = new THREE.OrthographicCamera(-aspect * baseSize, aspect * baseSize, baseSize, -baseSize, 0.1, 1000);
    camera.position.set(PARAMS.camX, PARAMS.camY, PARAMS.camZ);
    camera.zoom = PARAMS.camZoom;
    camera.updateProjectionMatrix();

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 1.6));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.8);
    dirLight.position.set(5, 10, 10);
    scene.add(dirLight);

    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();
    
    const worldPosition = new THREE.Vector3(); // Used for label positioning

    // --- BORDERS ---
    function updateBorders() {
        const w = window.innerWidth;
        const h = window.innerHeight;
        const splitY = h * PARAMS.splitHeight;
        document.getElementById('mask-path-el').setAttribute('d', `M 0,0 L ${w},0 L ${w},${splitY} L 0,${splitY} Z`);
        document.getElementById('border-path-el').setAttribute('d', `M 0,${splitY} L ${w},${splitY}`);
    }

    // --- TEXTURE LOADER SETUP ---
    const textureLoader = new THREE.TextureLoader();
    const materials = [];
    
    // --- GRID ---
    const COLS = 4; const ROWS = 3; const channelBlocks = [];
    const BLOCK_WIDTH = 1.12; 
    const BLOCK_HEIGHT = 0.72;
    const TILE_ASPECT = BLOCK_WIDTH / BLOCK_HEIGHT;

    for(let i=0; i<COLS*ROWS; i++) {
        const geo = new RoundedBoxGeometry(BLOCK_WIDTH, BLOCK_HEIGHT, 0.2, 4, PARAMS.borderRadius);
        
        let mat = new THREE.MeshPhongMaterial({ color: 0xe0e0e0, specular: 0x555555, shininess: 40 });
        const assetPath = ASSETS[i]; 

        if (assetPath) {
            textureLoader.load(assetPath, 
                (tex) => {
                    tex.colorSpace = THREE.SRGBColorSpace; 
                    tex.wrapS = THREE.RepeatWrapping; 
                    tex.wrapT = THREE.RepeatWrapping;

                    const imageAspect = tex.image.width / tex.image.height;
                    const tileAspect = TILE_ASPECT;
                    
                    if (imageAspect / tileAspect > 1) {
                        tex.repeat.set(tileAspect / imageAspect, 1);
                        tex.offset.set((1 - (tileAspect / imageAspect)) / 2, 0);
                    } else {
                        tex.repeat.set(1, imageAspect / tileAspect);
                        tex.offset.set(0, (1 - (imageAspect / tileAspect)) / 2);
                    }
                    
                    mat.map = tex;
                    mat.needsUpdate = true;
                },
                undefined, 
                (err) => {
                    console.error('Error loading texture for tile', i, err);
                    mat.color.setHex(0xe0e0e0); 
                    mat.needsUpdate = true;
                }
            );
        }

        const mesh = new THREE.Mesh(geo, mat);
        mesh.userData.index = i;
        
        mesh.userData.velocity = new THREE.Vector3();
        mesh.userData.targetScale = new THREE.Vector3(1, 1, 1);
        mesh.userData.wasClicked = false; 
        mesh.userData.isSpringing = false; 
        
        scene.add(mesh);
        channelBlocks.push(mesh);
        materials.push(mat); 

        const labelDiv = document.createElement('div');
        labelDiv.className = 'tile-index-label';
        labelDiv.textContent = i;
        labelContainer.appendChild(labelDiv);
        mesh.userData.label = labelDiv; 
    }

    function updateLayout() {
        const gap = PARAMS.gridSpacing - BLOCK_WIDTH;
        const autoSpacingY = gap + BLOCK_HEIGHT;
        const totalW = (COLS - 1) * PARAMS.gridSpacing;
        const xOffset = -totalW / 2 + PARAMS.gridOffsetX;
        const yOffset = ((ROWS - 1) * autoSpacingY) / 2 + PARAMS.gridOffsetY;

        channelBlocks.forEach((b, i) => {
            const col = i % COLS;
            const row = Math.floor(i / COLS);
            b.position.set(xOffset + col * PARAMS.gridSpacing, yOffset - row * autoSpacingY, 0);
        });
    }
    updateLayout();

    // --- BARBA TRANSITION LOGIC (NEW) ---
    const loadingScreen = document.getElementById('loading-screen');

    barba.init({
        transitions: [{
            name: 'tile-click-transition',
            leave({ current }) {
                // Show loading screen
                loadingScreen.classList.add('is-visible');
                
                // Return a Promise that resolves after 1000ms (1s loading state)
                return new Promise(resolve => {
                    setTimeout(() => {
                        loadingScreen.classList.remove('is-visible');
                        resolve(); 
                    }, 1000); 
                });
            },
            // Since this is a simple cover transition, Barba handles the enter phase automatically.
        }]
    });


    // --- EVENTS ---
    window.addEventListener('resize', () => {
        const asp = container.clientWidth / container.clientHeight;
        camera.left = -asp * baseSize; camera.right = asp * baseSize;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
        updateBorders();
    });

    window.addEventListener('keydown', (e) => {
        if (e.key === '`' || e.key === '~') {
            document.body.classList.toggle('debug-mode');
        }
    });

    window.addEventListener('mousedown', (e) => {
        if (document.body.classList.contains('debug-mode') && e.target.closest('.dg')) return;
        
        isMouseDown = true; 
        lastMoveTime = performance.now(); 
        cursorState.targetScale = 0.8; 
    });

    window.addEventListener('mouseup', () => {
        isMouseDown = false; 
        lastMoveTime = performance.now(); 
        cursorState.targetScale = 1.0; 
        
        if (INTERSECTED) { 
            const index = INTERSECTED.userData.index;
            const targetLink = LINKS[index];

            if (targetLink) {
                // Use Barba to navigate and trigger the custom transition
                barba.go(targetLink);
            }
            
            // Always trigger the tile spring animation, regardless of link
            INTERSECTED.userData.wasClicked = true; 
        } 
    });

    window.addEventListener('mousemove', (e) => {
        cursorState.targetX = e.clientX;
        cursorState.targetY = e.clientY;
        lastMoveTime = performance.now(); 
        
        const rect = container.getBoundingClientRect();
        pointer.x = ((e.clientX - rect.left) / container.clientWidth) * 2 - 1;
        pointer.y = -((e.clientY - rect.top) / container.clientHeight) * 2 + 1;
    });

    // --- ANIMATION ---
    function animate() {
        requestAnimationFrame(animate);
        
        if (cameraTween) { /* ... camera tween logic ... */ }

        camera.position.set(PARAMS.camX, PARAMS.camY, PARAMS.camZ);
        camera.lookAt(PARAMS.aimX, PARAMS.aimY, PARAMS.aimZ);

        raycaster.setFromCamera(pointer, camera);
        const intersects = raycaster.intersectObjects(channelBlocks, false);

        if (intersects.length > 0) {
            const target = intersects[0].object;
            if (INTERSECTED !== target) {
                if(INTERSECTED) INTERSECTED.material.emissive.setHex(0x000000);
                INTERSECTED = target;
                INTERSECTED.material.emissive.setHex(0x444444);
            }
        } else {
            if (INTERSECTED) {
                INTERSECTED.material.emissive.setHex(0x000000);
                INTERSECTED = null;
            }
        }

        // --- HYBRID TILE PHYSICS (SPRING FIX & REDUCED INTENSITY) ---
        const SPRING_TENSION = 0.14; 
        const SPRING_DAMPING = 0.85; 
        const OVERSHOOT_SCALE = 1.03; 
        const LERP_CLICK = 0.2; 
        const LERP_NORMAL = 0.08; 

        channelBlocks.forEach(b => {
            let targetS = 1.0;
            const currentlyHovered = b === INTERSECTED;

            // 1. Determine Target Scale and Spring Status
            if (currentlyHovered) {
                if (isMouseDown) {
                    targetS = 0.95; 
                    b.userData.isSpringing = false; 
                    b.userData.velocity.set(0,0,0);
                } else {
                    targetS = 1.05; 
                    
                    if (b.userData.wasClicked) {
                        b.userData.isSpringing = true;
                        const launchForce = OVERSHOOT_SCALE - b.scale.x;
                        b.userData.velocity.x += launchForce * 0.5; 
                        b.userData.wasClicked = false; 
                    }
                }
            } else {
                targetS = 1.0; 
                b.userData.wasClicked = false; 
            }
            
            // 2. Apply Animation Logic
            if (b.userData.isSpringing) {
                const tension = SPRING_TENSION; 
                const damping = SPRING_DAMPING; 
                const dist = targetS - b.scale.x;
                
                b.userData.velocity.x += dist * tension;
                b.userData.velocity.x *= damping;
                
                if (Math.abs(b.userData.velocity.x) < 0.001 && Math.abs(dist) < 0.005) {
                    b.userData.isSpringing = false;
                    b.scale.set(targetS, targetS, targetS);
                } else {
                    const next = b.scale.x + b.userData.velocity.x;
                    b.scale.set(next, next, next);
                }
            } else {
                let lerpFactor = currentlyHovered && isMouseDown ? LERP_CLICK : LERP_NORMAL;
                b.scale.lerp(new THREE.Vector3(targetS, targetS, targetS), lerpFactor);
            }
            
            // 3. Update HTML Label Position
            b.updateWorldMatrix(true, false);
            b.getWorldPosition(worldPosition);
            
            const screenPosition = worldPosition.clone();
            screenPosition.project(camera);
            
            const x = (screenPosition.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
            const y = (-screenPosition.y * 0.5 + 0.5) * renderer.domElement.clientHeight;
            
            if(b.userData.label) {
                b.userData.label.style.transform = `translate3d(${x}px, ${y}px, 0) translate(-50%, -50%) scale(${b.scale.x})`;
            }

        });

        renderer.render(scene, camera);
    }
    animate();

    // --- CURSOR PHYSICS LOOP ---
    const cursorEl = document.getElementById('custom-cursor');
    const IDLE_TIMEOUT = 200; 

    function animateCursor() {
        cursorState.x = cursorState.targetX;
        cursorState.y = cursorState.targetY;
        
        cursorState.scale += (cursorState.targetScale - cursorState.scale) * 0.2;
        
        if (cursorState.prevX === undefined) cursorState.prevX = cursorState.x;
        const dx = cursorState.x - cursorState.prevX;
        cursorState.prevX = cursorState.x;

        // --- ROTATION LOGIC (UPDATED) ---
        const isTrulyIdle = performance.now() - lastMoveTime > IDLE_TIMEOUT;
        const isIdle = isTrulyIdle && !isMouseDown; 
        
        let targetBaseRotation = -10; 

        if (isIdle) {
            targetBaseRotation = 0; 
        }
        
        const decayFactor = isIdle ? 0.1 : 1; 
        
        const baseRotation = THREE.MathUtils.lerp(cursorState.angle, targetBaseRotation, decayFactor);

        const velocityTilt = dx * 1.5; 
        const targetAngle = baseRotation + velocityTilt;
        
        cursorState.angle += (targetAngle - cursorState.angle) * 0.2; 


        if (cursorEl) {
            cursorEl.style.transform = `translate3d(${cursorState.x}px, ${cursorState.y}px, 0) translateX(-35%) rotate(${cursorState.angle}deg) scale(${cursorState.scale})`;
        }
        requestAnimationFrame(animateCursor);
    }
    animateCursor();

    function updateClock() {
        const d = new Date();
        let h = d.getHours(); const m = d.getMinutes();
        const ampm = h >= 12 ? 'PM' : 'AM';
        h = h % 12 || 12;
        const mStr = m < 10 ? '0'+m : m;
        document.getElementById('clock').innerHTML = `${h}:${mStr} <span style="font-size:0.4em; vertical-align: top;">${ampm}</span>`;
    }
    setInterval(updateClock, 1000);
    updateClock();
    updateBorders();

    const gui = new GUI({ autoPlace: false });
    document.getElementById('gui-container').appendChild(gui.domElement);
    const folder = gui.addFolder('Layout');
    folder.add(PARAMS, 'gridSpacing', 1, 3).onChange(updateLayout);
    folder.add(PARAMS, 'gridOffsetY', -5, 5).onChange(updateLayout);
    folder.add(PARAMS, 'splitHeight', 0.5, 1.0).onChange(updateBorders);
    folder.open();
  </script>
</body>
</html>