<!DOCTYPE html>
<html lang="en">
<head>
    <script>
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                window.location.href = 'https://sandbox.zakknowlton.com/';
            }
        });
    </script>
    <title>ZAK KNOWLTON | Creative Design & Dev</title>
    <link id="favicon" rel="icon" href="data:,">
    <style>
        /* PREMIUM RESET */
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif; }
        canvas { display: block; outline: none; }

        /* LANDING PAGE UI */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; /* Click through to 3D */
            display: flex; align-items: center;
            z-index: 5;
            padding-left: 5%;
        }

        .content-box {
            pointer-events: auto; 
            max-width: 600px; 
        }

        h1 {
            font-size: 6rem; font-weight: 900; margin: 0; line-height: 0.85;
            color: #ffffff; text-shadow: 0 10px 30px rgba(0,0,0,0.1);
            letter-spacing: -3px; text-transform: uppercase;
        }
        
        h2 {
            font-size: 1.4rem; font-weight: 500; margin: 25px 0 40px 5px;
            color: rgba(255,255,255,0.95); letter-spacing: 0.5px; text-transform: uppercase;
            line-height: 1.4;
        }

        .btn-group { display: flex; gap: 20px; margin-left: 5px; }

        /* BUTTON STYLES WITH MOUSE FX */
        .btn {
            position: relative;
            overflow: hidden;
            padding: 18px 45px; font-size: 14px; font-weight: 800;
            border-radius: 50px; cursor: pointer;
            text-transform: uppercase; letter-spacing: 1px;
            transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
            --x: 50%; --y: 50%;
        }
        
        /* The glow effect container */
        .btn::before {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            opacity: 0; transition: opacity 0.3s; pointer-events: none;
            background: radial-gradient(circle at var(--x) var(--y), rgba(255,255,255,0.8) 0%, transparent 60%);
        }
        .btn:hover::before { opacity: 1; }

        /* Primary */
        .btn-primary {
            background: rgba(255, 255, 255, 0.85); 
            color: #000; border: 1px solid rgba(255,255,255,0.4);
            backdrop-filter: blur(4px);
        }
        .btn-primary:hover { 
            background: rgba(255, 255, 255, 0.95); 
            box-shadow: 0 10px 30px rgba(255,255,255,0.2); 
        }

        /* Secondary (Contact Button) */
        .btn-secondary {
            /* Increased opacity/color to meet the primary button halfway */
            background: rgba(255,255,255,0.3); 
            color: #fff; 
            border: 1px solid rgba(255,255,255,0.5);
            backdrop-filter: blur(10px);
        }
        .btn-secondary:hover { 
            background: rgba(255,255,255,0.4); 
            border-color: rgba(255,255,255,0.6); 
        }

        /* SIDE PANEL */
        #side-panel {
            position: absolute; top: 50%; right: 5%; 
            transform: translateY(-50%) scale(0.95);
            width: 320px;
            /* Added subtle black tint to increase contrast */
            background: rgba(0, 0, 0, 0.2); 
            border: 1px solid rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(25px);
            -webkit-backdrop-filter: blur(25px);
            border-radius: 24px;
            padding: 30px;
            z-index: 20;
            opacity: 0;
            pointer-events: none;
            box-shadow: 0 20px 40px rgba(0,0,0,0.4);
            transition: all 0.5s cubic-bezier(0.19, 1, 0.22, 1); 
        }

        #side-panel.active {
            opacity: 1;
            pointer-events: auto;
            transform: translateY(-50%) scale(1);
        }

        #side-panel h3 {
            margin: 0 0 20px 0; color: #fff; font-size: 12px; 
            text-transform: uppercase; letter-spacing: 2px; opacity: 0.6;
        }

        .link-list { list-style: none; padding: 0; margin: 0; }
        .link-list li { 
            margin-bottom: 1px; 
            position: relative; /* Needed for hover tab */
        }
        
        /* Tab Glow Effect */
        .link-list li::before {
            content: '';
            position: absolute; top: 0; left: -30px;
            width: calc(100% + 60px); /* 30px padding on both sides */
            height: 100%;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 0; /* REMOVED CURVE */
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
            z-index: 0;
        }

        .link-list li:hover::before {
            opacity: 1;
        }

        .link-list a {
            color: #fff; text-decoration: none; font-size: 16px; font-weight: 600;
            display: block; transition: opacity 0.2s, transform 0.2s;
            position: relative; 
            padding: 10px 0; /* Vertical padding on links */
            z-index: 1; /* Keep text above the ::before glow */
            display: flex; justify-content: space-between; align-items: center;
        }
        .link-list a:hover { opacity: 1.0; }
        .link-list a { opacity: 0.9; }
        
        .link-list a span {
            font-size: 11px; text-transform: uppercase; 
            opacity: 0.7; /* Increased readability for subtitle */
            font-weight: 400; letter-spacing: 1px;
        }


        /* INSTRUCTIONS / DEBUG FOOTERS */
        #instructions, #copyright {
            position: absolute; bottom: 30px; 
            color: rgba(255, 255, 255, 0.6);
            font-size: 11px; text-transform: uppercase; letter-spacing: 2px; font-weight: 600;
            z-index: 5;
        }

        #instructions { left: 5%; }
        #copyright { right: 5%; }

        /* TOOLTIP */
        #tooltip {
            position: absolute; pointer-events: none;
            width: 240px; background: rgba(255, 255, 255, 0.95);
            padding: 15px; border-radius: 12px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.15);
            opacity: 0; transform: scale(0.9) translateY(10px);
            transform-origin: bottom center;
            transition: opacity 0.2s ease, transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 10;
        }
        #tooltip.visible { opacity: 1; transform: scale(1) translateY(0); }
        #tooltip h3 { margin: 0 0 5px 0; font-size: 12px; color: #888; text-transform: uppercase; letter-spacing: 1px; }
        #tooltip h2 { margin: 0 0 10px 0; font-size: 18px; color: #000; font-weight: 800; letter-spacing: -0.5px; }
        #tooltip .color-strip { height: 4px; width: 30px; border-radius: 2px; margin-bottom: 10px; background: #000; }
        
        /* GUI Tweak */
        .dg.ac { z-index: 1000 !important; display: none; } 
        .dg .close-button { text-align: center !important; }
    </style>
</head>
<body>

    <!-- DYNAMIC PROJECTS PANEL -->
    <div id="side-panel">
        <h3>Projects</h3>
        <ul class="link-list" id="project-list"></ul>
    </div>

    <div id="ui-layer">
        <div class="content-box">
            <h1>ZAK<br>KNOWLTON</h1>
            <h2>Creative Design & <br>Ecommerce Development</h2>
            <div class="btn-group">
                <button class="btn btn-primary" id="btn-projects">View Projects</button>
                <button class="btn btn-secondary" id="btn-contact">Contact</button>
            </div>
        </div>
    </div>

    <div id="instructions">Drag to Spin &bull; [1-9] Camera Spots &bull; [~] Controls</div>
    <div id="copyright">ZAK KNOWLTON 2026</div>

    <div id="tooltip">
        <div class="color-strip" id="tp-color"></div>
        <h3 id="tp-cat">Project</h3>
        <h2 id="tp-title">Title</h2>
    </div>

    <!-- GLOBAL THREE.JS IMPORTS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>

    <!-- Post-Processing / Loaders (Global namespace: THREE) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/OutputPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>


    <script>
        // --- DYNAMIC FAVICON ---
        (function() {
            const link = document.getElementById('favicon');
            const img = new Image();
            img.src = './eyeball-favi.jpg'; 

            img.onerror = () => { console.warn("Favicon image failed to load. Using fallback color."); link.href = 'data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>âœ¨</text></svg>'; };

            img.onload = () => {
                try {
                    const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 64;
                    const ctx = canvas.getContext('2d');
                    ctx.beginPath(); ctx.arc(32, 32, 32, 0, 2 * Math.PI); ctx.closePath(); ctx.clip();
                    ctx.drawImage(img, 0, 0, 64, 64);
                    link.href = canvas.toDataURL();
                } catch (e) {
                    console.error("Favicon canvas manipulation failed:", e);
                }
            };
        })();

        // --- BUTTON FX ---
        const controlsVisible = () => {
            const guiEl = document.querySelector('.dg.ac');
            return guiEl && window.getComputedStyle(guiEl).display !== 'none';
        };

        document.querySelectorAll('.btn').forEach(btn => {
            btn.addEventListener('mousemove', (e) => {
                const rect = btn.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                btn.style.setProperty('--x', x + 'px');
                btn.style.setProperty('--y', y + 'px');
            });
        });

        // --- DATA ---
        const PLANET_DATA = [
            { r: 1.5, color: 0xff3333, orbitR: 35, speed: 0.5, y: 6, name: "Shopify Analytics", cat: "Dev" },    
            { r: 1.2, color: 0x3388ff, orbitR: 42, speed: -0.3, y: -5, name: "Mazda Mods", cat: "Auto" },  
            { r: 0.9, color: 0xffaa00, orbitR: 30, speed: 0.7, y: 14, name: "Debt Payoff", cat: "Finance" },    
            { r: 2.0, color: 0x9933ff, orbitR: 48, speed: 0.2, y: 0, name: "Creative Dir", cat: "Branding" }     
        ];

        const listEl = document.getElementById('project-list');
        PLANET_DATA.forEach(p => {
            const li = document.createElement('li');
            li.innerHTML = `<a href="#">${p.name} <span>${p.cat}</span></a>`;
            listEl.appendChild(li);
        });

        const panel = document.getElementById('side-panel');
        document.getElementById('btn-projects').addEventListener('click', () => { loadKeyframe(2); panel.classList.add('active'); });
        document.getElementById('btn-contact').addEventListener('click', () => { loadKeyframe(1); panel.classList.remove('active'); });


        // --------------------------------------------------------
        // [CONFIGURATION BLOCK] - COPY THIS SECTION TO SAVE
        // --------------------------------------------------------
        const PARAMS = {
            sensitivity: 1.2, friction: 0.97, momentumEase: 0.1, snappiness: 0.85,
            grassAttack: 0.05, grassDecay: 0.94, bendPower: 4.0, maxBend: 3.0, 
            windSpeed: 1.2, keySpeed: 0.005,
            
            ballScale: 3.0, grassLength: 1.0, grassWidth: 1.0, skyTint: 0.3, 
            
            transitionDuration: 1000, easeIntensity: 1.0,
            
            // Current Camera State (Loaded from Keyframe 1)
            camX: -24, camY: -44, camZ: 65, aimX: -33, aimY: 29, aimZ: 0,
            activeSlot: 1
        };

        const VISUALS = { baseColor: 0x5C4033, radius: 10, geoDetail: 5, grassCount: 200000, grassBaseSize: 0.3 };

        const keyframes = {
            1: { camX: -24, camY: -44, camZ: 65, aimX: -33, aimY: 29, aimZ: 0 },
            2: { camX: -100, camY: -100, camZ: 10, aimX: -33, aimY: 29, aimZ: 0 },
            3: { camX: -24, camY: -44, camZ: 65, aimX: -33, aimY: 29, aimZ: 0 },
            4: { camX: -24, camY: -44, camZ: 65, aimX: -33, aimY: 29, aimZ: 0 },
            5: { camX: -24, camY: -44, camZ: 65, aimX: -33, aimY: 29, aimZ: 0 },
            6: { camX: -24, camY: -44, camZ: 65, aimX: -33, aimY: 29, aimZ: 0 },
            7: { camX: -24, camY: -44, camZ: 65, aimX: -33, aimY: 29, aimZ: 0 },
            8: { camX: -24, camY: -44, camZ: 65, aimX: -33, aimY: 29, aimX: 0 },
            9: { camX: -24, camY: -44, camZ: 65, aimX: -33, aimY: 29, aimX: 0 }
        };
        // --------------------------------------------------------


        // --- EXPORT FUNCTION ---
        function exportAllSettings() {
            PARAMS.camX = parseFloat(camera.position.x.toFixed(2));
            PARAMS.camY = parseFloat(camera.position.y.toFixed(2));
            PARAMS.camZ = parseFloat(camera.position.z.toFixed(2));
            
            let code = `// --- PASTE THIS OVER THE CONFIGURATION BLOCK ---\n\n`;
            
            code += `const PARAMS = ${JSON.stringify(PARAMS, null, 4)};\n\n`;
            code += `const VISUALS = ${JSON.stringify(VISUALS, null, 4)};\n\n`;
            code += `const keyframes = ${JSON.stringify(keyframes, null, 4)};\n\n`;
            
            console.log("%cðŸ“‹ SETTINGS EXPORT:", "color: #00ff00; font-weight: bold; font-size: 14px;");
            console.log(code);
            alert("All Settings exported to Console (F12). Copy/Paste to save.");
        }

        // --- TWEENING ENGINE ---
        let cameraTween = null;
        function saveKeyframe() {
            const s = PARAMS.activeSlot;
            keyframes[s] = { camX: parseFloat(PARAMS.camX.toFixed(1)), camY: parseFloat(PARAMS.camY.toFixed(1)), camZ: parseFloat(PARAMS.camZ.toFixed(1)), aimX: parseFloat(PARAMS.aimX.toFixed(1)), aimY: parseFloat(PARAMS.aimY.toFixed(1)), aimZ: parseFloat(PARAMS.aimZ.toFixed(1)) };
            console.log(`Saved View to Slot ${s}`);
        }
        function loadKeyframe(slot) {
            const target = keyframes[slot];
            if (!target) return;
            PARAMS.activeSlot = slot;
            cameraTween = {
                start: { camX: PARAMS.camX, camY: PARAMS.camY, camZ: PARAMS.camZ, aimX: PARAMS.aimX, aimY: PARAMS.aimY, aimZ: PARAMS.aimZ },
                end: target, startTime: performance.now(), duration: PARAMS.transitionDuration 
            };
        }
        function easeOutExpo(x) { return x === 1 ? 1 : 1 - Math.pow(2, -10 * x); }
        function customEase(t) { return easeOutExpo(t); }

        // --- SCENE & RENDERER SETUP ---
        // NOTE: We rely on global definitions from the script tags above
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
        renderer.outputEncoding = THREE.sRGBEncoding;
        document.body.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        // --- POST PROCESSING SETUP ---
        const renderPass = new THREE.RenderPass(scene, camera);
        const bloomPass = new THREE.UnrealBloomPass( new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.8;
        bloomPass.strength = 0.8;
        bloomPass.radius = 0.5;
        const outputPass = new THREE.OutputPass();
        const composer = new THREE.EffectComposer(renderer);
        composer.addPass(renderPass);
        composer.addPass(bloomPass);
        composer.addPass(outputPass);

        // --- SCENE OBJECTS ---
        let skyboxMesh;
        const loader = new THREE.TextureLoader();
        let mainModel; // Global reference for the GLTF model

        function loadSkybox(path) {
            loader.load(path, function(texture) {
                console.log(`Successfully loaded skybox texture: ${path}`);
                texture.mapping = THREE.EquirectangularReflectionMapping;
                scene.environment = texture; 
                if (!skyboxMesh) {
                    const skyGeo = new THREE.SphereGeometry(500, 60, 40);
                    skyGeo.scale(-1, 1, 1); 
                    const skyMat = new THREE.MeshBasicMaterial({ map: texture, color: 0xffffff });
                    skyboxMesh = new THREE.Mesh(skyGeo, skyMat);
                    scene.add(skyboxMesh);
                } else {
                    skyboxMesh.material.map = texture;
                    skyboxMesh.material.needsUpdate = true;
                }
                updateSkyTint(PARAMS.skyTint);
            }, undefined, function(error) {
                console.error(`Local texture failed: ${path}. Attempting CDN fallback...`, error);
                
                // Fallback: Use CDN placeholder for guaranteed visibility
                const CDN_URL = 'https://cdn.jsdelivr.net/gh/mrdoob/three.js@master/examples/textures/envmap_sunset.jpg';
                loader.load(CDN_URL, function(texture) {
                    console.log("Successfully loaded CDN fallback.");
                    texture.mapping = THREE.EquirectangularReflectionMapping;
                    if (!skyboxMesh) {
                         const skyGeo = new THREE.SphereGeometry(500, 60, 40);
                         const skyMat = new THREE.MeshBasicMaterial({ map: texture, color: 0xffffff });
                         skyboxMesh = new THREE.Mesh(skyGeo, skyMat);
                         skyGeo.scale(-1, 1, 1);
                         scene.add(skyboxMesh);
                    } else {
                        skyboxMesh.material.map = texture;
                        skyboxMesh.material.needsUpdate = true;
                    }
                    scene.environment = texture;
                    updateSkyTint(PARAMS.skyTint);
                });
            });
        }
        
        // Initial load attempt (targeting the correct file name)
        loadSkybox('./Daylight_Box_0.png');


        function updateSkyTint(val) { if(skyboxMesh) skyboxMesh.material.color.setScalar(1.0 - val); }

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8); scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.3); 
        dirLight.position.set(10, 30, 20); 
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.set(2048, 2048);
        dirLight.shadow.radius = 4;
        scene.add(dirLight);

        const orbGroup = new THREE.Group();
        orbGroup.scale.setScalar(PARAMS.ballScale);
        scene.add(orbGroup);
        
        // --- GLTF LOADER IMPLEMENTATION (Replacing Grass Ball) ---
        const gltfLoader = new THREE.GLTFLoader(); // Using global THREE.GLTFLoader
        const MODEL_PATH = './light_bulb/scene.gltf'; 

        gltfLoader.load(MODEL_PATH, (gltf) => {
            mainModel = gltf.scene;
            mainModel.scale.setScalar(0.2); // Initial guess scale (can be adjusted by ballScale param)
            mainModel.position.y = 0; // Center the model

            mainModel.traverse(child => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                    // Apply emissiveness or specific materials if needed for Bloom
                    if (child.name.includes('light')) {
                         child.material = new THREE.MeshBasicMaterial({ color: 0xffffaa, emissive: 0xffffaa, emissiveIntensity: 2.0 });
                    } else if (child.material) {
                         // Ensure non-emissive parts respond to light
                         child.material = child.material.clone();
                         child.material.metalness = 0.5; 
                         child.material.roughness = 0.3;
                    }
                }
            });

            // Add the model to the orbGroup (which handles scaling and rotation)
            orbGroup.add(mainModel);
            console.log("GLTF Lightbulb loaded and centered.");

        }, undefined, (error) => {
            console.error(`Failed to load GLTF model from ${MODEL_PATH}. Check file paths/Live Server.`, error);
            // Fallback: Add a placeholder cube if model fails
            const placeholder = new THREE.Mesh(new THREE.BoxGeometry(5, 5, 5), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
            orbGroup.add(placeholder);
        });
        
        // --- END GLTF LOADER ---

        // Retaining for loop stability/color handling
        const dirtMat = { color: new THREE.Color(VISUALS.baseColor) };
        const grassMaterial = { uniforms: { uColorTop: { value: new THREE.Color() }, uColorBottom: { value: new THREE.Color() }, uRotVel: { value: new THREE.Vector3() } } }; 
        
        const interactables = [];
        PLANET_DATA.forEach((data) => {
            const geo = new THREE.SphereGeometry(data.r, 32, 32);
            const mat = new THREE.MeshStandardMaterial({ color: data.color, roughness: 0.2, metalness: 0.1, emissive: data.color, emissiveIntensity: 1.0 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.userData = { angle: Math.random() * Math.PI * 2, orbitR: data.orbitR, speed: data.speed, y: data.y, color: new THREE.Color(data.color), type: 'planet', name: data.name, cat: data.cat };
            mesh.castShadow = true; mesh.receiveShadow = true;
            scene.add(mesh); interactables.push(mesh);
        });

        function createUFO() {
            const g = new THREE.Group();
            const matS = new THREE.MeshStandardMaterial({ color: 0xeeeeee, metalness: 0.9, roughness: 0.1, emissiveIntensity: 1.0 }); 
            const matG = new THREE.MeshStandardMaterial({ color: 0x00ffff, transparent: true, opacity: 0.5, emissive: 0x00ffff, emissiveIntensity: 1.5 });
            g.add(new THREE.Mesh(new THREE.CylinderGeometry(0.5, 1.5, 0.3, 16), matS));
            const d = new THREE.Mesh(new THREE.SphereGeometry(0.6, 16, 16, 0, Math.PI*2, 0, Math.PI*0.5), matG); d.position.y = 0.1; g.add(d);
            const l = new THREE.PointLight(0x00ffff, 5, 10); l.position.y = -0.5; g.add(l);
            g.userData = { angle: 0, orbitR: 25, speed: 0.8, y: 6, color: new THREE.Color(0x00ffff), type: 'ufo', name: "Contact", cat: "UFO" };
            scene.add(g); interactables.push(g); g.traverse(c => { if(c.isMesh) c.userData = g.userData; });
        }
        createUFO();

        // --- LOOP ---
        const clock = new THREE.Clock();
        const gui = new dat.GUI({ closed: true });
        setTimeout(() => { const b = document.querySelector('.dg .close-button'); if(b) b.innerHTML = 'Controls'; }, 1000);
        
        const camFolder = gui.addFolder('Camera & Layout');
        camFolder.add(PARAMS, 'ballScale', 0.5, 5.0).name('Model Size').onChange(v => {
            orbGroup.scale.setScalar(v);
            if(mainModel) mainModel.scale.setScalar(v * 0.2); // Adjust if model is already scaled
        });
        camFolder.add(PARAMS, 'camX', -100, 100).name('Cam X').listen();
        camFolder.add(PARAMS, 'camY', -100, 100).name('Cam Y').listen();
        camFolder.add(PARAMS, 'camZ', 10, 200).name('Cam Zoom').listen();
        camFolder.add(PARAMS, 'aimX', -100, 100).name('Aim X (Pan)').listen();
        camFolder.add(PARAMS, 'aimY', -100, 100).name('Aim Y (Tilt)').listen();
        camFolder.add(PARAMS, 'skyTint', 0.0, 1.0).name('Sky Tint').onChange(updateSkyTint);
        
        const bloomFolder = gui.addFolder('Bloom FX');
        bloomFolder.add(bloomPass, 'threshold', 0.0, 1.0).name('Threshold');
        bloomFolder.add(bloomPass, 'strength', 0.0, 3.0).name('Strength');
        bloomFolder.add(bloomPass, 'radius', 0.0, 1.0).name('Radius').step(0.01);

        const transFolder = gui.addFolder('Transitions');
        transFolder.add(PARAMS, 'transitionDuration', 100, 5000).name('Duration (ms)');
        transFolder.add(PARAMS, 'easeIntensity', 0.0, 3.0).name('Ease Overshoot');
        
        const keyFolder = gui.addFolder('Keyframes');
        keyFolder.add(PARAMS, 'activeSlot', [1,2,3,4,5,6,7,8,9]).name('Slot').listen();
        keyFolder.add({ save: saveKeyframe }, 'save').name('Save View');
        keyFolder.add({ export: exportAllSettings }, 'export').name('Export ALL Settings');
        
        const visFolder = gui.addFolder('Visuals');
        visFolder.add(VISUALS, 'grassCount', 10000, 300000).step(1000).name('Grass Count (Unused)'); 
        
        const physFolder = gui.addFolder('Physics');
        physFolder.add(PARAMS, 'sensitivity', 0.1, 3.0);
        physFolder.add(PARAMS, 'keySpeed', 0.001, 0.1).name('Key Override Speed'); 
        
        // END GUI SETUP ---

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const elTooltip = document.getElementById('tooltip');
        const elTitle = document.getElementById('tp-title'), elCat = document.getElementById('tp-cat'), elColor = document.getElementById('tp-color');
        let hoveredObj = null;
        const keys = {};
        let targetGrassColorTop = new THREE.Color(0x44cc00);
        let targetGrassColorBottom = new THREE.Color(0x115500);
        let targetDirtColor = new THREE.Color(VISUALS.baseColor); 

        window.addEventListener('keydown', (e) => { 
            if (e.key === '`' || e.key === '~') { const g = document.querySelector('.dg.ac'); if(g) g.style.display = g.style.display === 'none' ? 'block' : 'none'; }
            if (e.key >= '1' && e.key <= '9') loadKeyframe(parseInt(e.key));
            if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','w','a','s','d'].includes(e.key)) keys[e.key] = true;
        });
        window.addEventListener('keyup', (e) => keys[e.key] = false);
        window.addEventListener('mousemove', (e) => { mouse.x = (e.clientX/window.innerWidth)*2-1; mouse.y = -(e.clientY/window.innerHeight)*2+1; });
        window.addEventListener('click', () => {
            if (hoveredObj) {
                targetGrassColorTop.copy(hoveredObj.userData.color);
                targetDirtColor.copy(hoveredObj.userData.color);
                targetGrassColorBottom.copy(hoveredObj.userData.color).multiplyScalar(0.2);
            }
        });

        let isDrag=false, prev={x:0,y:0}, orbVel={x:0,y:0}, grassVel={x:0,y:0};
        document.addEventListener('mousedown', (e) => { if(controlsVisible()) { if(e.target.tagName !== 'BUTTON') isDrag = true; } });
        document.addEventListener('mouseup', () => isDrag = false);
        document.addEventListener('mousemove', (e) => {
            const dx = e.offsetX - prev.x, dy = e.offsetY - prev.y;
            if(isDrag) {
                const s = 0.005 * PARAMS.sensitivity;
                orbGroup.rotation.y += dx*s; orbGroup.rotation.x += dy*s;
                orbVel.x = dy*s; orbVel.y = dx*s;
            }
            prev = {x:e.offsetX, y:e.offsetY};
        });

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            const time = clock.getElapsedTime();

            // --- COLOR INTERPOLATION (LERP) ---
            const colorLerpFactor = 0.2; 
            // Update materials based on the target color
            dirtMat.color.lerp(targetDirtColor, colorLerpFactor); 
            
            if (mainModel) {
                 const baseMesh = mainModel.children.find(c => c.isMesh);
                 if (baseMesh) {
                     baseMesh.material.color.lerp(targetDirtColor, colorLerpFactor);
                 }
            }


            if (cameraTween) {
                let t = (performance.now() - cameraTween.startTime) / cameraTween.duration;
                if (t >= 1) { t = 1; cameraTween = null; }
                const eT = customEase(t);
                PARAMS.camX = THREE.MathUtils.lerp(cameraTween.start.camX, cameraTween.end.camX, eT);
                PARAMS.camY = THREE.MathUtils.lerp(cameraTween.start.camY, cameraTween.end.camY, eT);
                PARAMS.camZ = THREE.MathUtils.lerp(cameraTween.start.camZ, cameraTween.end.camZ, eT);
                PARAMS.aimX = THREE.MathUtils.lerp(cameraTween.start.aimX, cameraTween.end.aimX, eT);
                PARAMS.aimY = THREE.MathUtils.lerp(cameraTween.start.aimY, cameraTween.end.aimY, eT);
                PARAMS.aimZ = THREE.MathUtils.lerp(cameraTween.start.aimZ, cameraTween.end.aimZ, eT);
                for (var i in camFolder.__controllers) camFolder.__controllers[i].updateDisplay();
            }
            
            camera.position.set(PARAMS.camX, PARAMS.camY, PARAMS.camZ);
            camera.lookAt(PARAMS.aimX, PARAMS.aimY, PARAMS.aimZ);

            let kx=0, ky=0;
            if(keys.ArrowUp||keys.w) kx = -PARAMS.keySpeed; if(keys.ArrowDown||keys.s) kx = PARAMS.keySpeed;
            if(keys.ArrowLeft||keys.a) ky = -PARAMS.keySpeed; if(keys.ArrowRight||keys.d) ky = PARAMS.keySpeed;

            if(!isDrag && (kx!==0 || ky!==0)) {
                orbGroup.rotation.x += kx; orbGroup.rotation.y += ky;
                orbVel.x = kx; orbVel.y = ky;
            } else if(!isDrag) {
                orbVel.x *= PARAMS.friction; orbVel.y *= PARAMS.friction;
                orbGroup.rotation.x += orbVel.x; orbGroup.rotation.y += orbVel.y;
            }

            // --- MODEL MOMENTUM ---
            if (mainModel) {
                grassVel.x = THREE.MathUtils.lerp(grassVel.x, orbVel.x, PARAMS.grassAttack);
                grassVel.y = THREE.MathUtils.lerp(grassVel.y, orbVel.y, PARAMS.grassAttack);
                grassVel.x *= PARAMS.grassDecay; grassVel.y *= PARAMS.grassDecay;
                // No actual grass to apply shader uniforms to now.
            }

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(interactables, true);
            let found = null;
            if (intersects.length > 0) {
                const obj = intersects[0].object;
                found = (obj.parent && obj.parent.userData.type === 'ufo') ? obj.parent : obj;
            }
            hoveredObj = found;
            document.body.style.cursor = hoveredObj ? 'pointer' : 'default';

            if (hoveredObj) {
                elTooltip.classList.add('visible');
                const vec = new THREE.Vector3(); hoveredObj.getWorldPosition(vec); vec.project(camera);
                const x = (vec.x * 0.5 + 0.5) * window.innerWidth; const y = (-(vec.y * 0.5) + 0.5) * window.innerHeight;
                elTooltip.style.left = `${x + 20}px`; elTooltip.style.top = `${y - 60}px`;
                const tid = hoveredObj.uuid;
                if (elTooltip.dataset.target !== tid) {
                    elTooltip.dataset.target = tid; elTitle.innerText = hoveredObj.userData.name || "Unknown"; elCat.innerText = hoveredObj.userData.cat || "Project"; elColor.style.backgroundColor = '#' + hoveredObj.userData.color.getHexString();
                }
            } else { elTooltip.classList.remove('visible'); elTooltip.dataset.target = ''; }

            interactables.forEach(obj => {
                const d = obj.userData;
                const ts = (obj === hoveredObj) ? 1.5 : 1.0;
                obj.scale.lerp(new THREE.Vector3(ts, ts, ts), 0.1);
                if (obj !== hoveredObj) { d.angle += d.speed * dt; if(d.type==='ufo') obj.rotation.y+=2*dt; } 
                else { if(d.type==='ufo') obj.rotation.y+=10*dt; }
                obj.position.x = Math.cos(d.angle)*d.orbitR; obj.position.z = Math.sin(d.angle)*d.orbitR; obj.position.y = d.y + Math.sin(time + d.orbitR)*0.5;
            });

            // Use COMPOSER for post-processing render
            composer.render();
        }
        window.addEventListener('resize', () => {
            const width = window.innerWidth;
            const height = window.innerHeight;

            camera.aspect = width / height; 
            camera.updateProjectionMatrix(); 
            
            renderer.setSize(width, height);
            composer.setSize(width, height);
        });
        animate();
    </script>
</body>
</html>